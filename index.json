{
  "index.html": {
    "href": "index.html",
    "title": "OCS API",
    "keywords": "OCS API OSIsoft Cloud Services (OCS) is a highly flexible cloud-based platform that provides scalable, elastic, centralized environment to aggregate data for reporting, advanced analytics, and third-party applications. Sequential data store (SDS) A sequential data store (SDS) is used to store, retrieve, and analyze data. You create and write data to streams using a simple REST API. The streams are able to store simple or complex data types to suit the application needs. An assortment of methods with customizable behaviors are available to read data and easily obtain needed information. OSIsoft Cloud Services Management Client Roles Namespace NamespaceTier Roles RootAccessControl Tenant Tenant Feature States User Roles ServiceBlog Consent to OSIsoft Applications Sequential Data Store Introducing the Sequential Data Store Quick Start Types Streams Stream Metadata and Tags Stream Views Indexes Units of Measure Reading Data Reading Data API Writing Data Writing Data API Compression Searching Filter Expressions - Data Filter Expressions - Metadata Objects Table Format Data Ingress and OSIsoft Message Format Data Ingress to Cloud Services Using OMF Quick Start Using OMF with Cloud Services Publishers Topics Subscriptions Role-based Access Control Samples Getting Support"
  },
  "Documentation/support.html": {
    "href": "Documentation/support.html",
    "title": "Getting support",
    "keywords": "Getting support The following email address is available to participants of the Qi Preview for both product support and feedback: cloudservices@osisoft.com The OSIsoft team will endeavor to respond to all support request as quickly as possible during business hours (Pacific Time)"
  },
  "Documentation/DataIngress/Data_Ingress.html": {
    "href": "Documentation/DataIngress/Data_Ingress.html",
    "title": "Data Ingress and OSIsoft Message Format",
    "keywords": "Data Ingress and OSIsoft Message Format You use OSIsoft Message Format (OMF) to achieve high-throughput asynchronous data ingress into the OCS data store. The following terms might be useful for understanding the information in this and subsequent topics: A producer of OMF messages intended for OCS is called a Publisher . Messages are sent to a queue called a Topic . A Subscription recieves messages from a Topic and writes them either to the OCS data store or makes them available to an external consumer."
  },
  "Documentation/DataIngress/OMF_Ingress_Publishers.html": {
    "href": "Documentation/DataIngress/OMF_Ingress_Publishers.html",
    "title": "Publishers",
    "keywords": "Publishers A Publisher is a logical construct which is used by OSIsoft Cloud Services (OCS) to authenticate and categorize OSIsoft Message Format (OMF) messages. After creating a publisher using the API, a user can then generate a security token for that publisher. The token must be added to the headers of OMF messages that are sent to OCS. If a publisher is deleted, all security tokens generated for the Publisher become invalid. Individual tokens can be deleted as needed. The API calls in this section are all used to manage publishers. Tokens After creating a publisher, security tokens for that publisher can be created. These tokens are a type of bearer token, which means that any client that presents the token will be able to authenticate as that publisher, assuming the token is valid. Because of this, it is imperative that the token be stored in a secure location that is accessible only to the application that is sending data. If the security token is ever compromised, it is possible for an unauthorized client to impersonate the publisher until the token expires or is deleted. The security token contains information that uniquely identifies the publisher. The following information is contained in the token: Token Id: A unique Id for the token. The Id is generated by the API. Publisher Id: The Id of the publisher this token is for. Tenant Id: This Id identifies the owner of the publisher. Expiration Time: This determines when the security token expires. Signature: This is a cryptographic signature that verifies that the token is legitimate and has not been tampered with. The signature uses the HMAC-SHA256 algorithm. The security token should never be transported over an unsecure network connection. If, for example, you have a separate management service that performs token registration and renewal with the API and then pushes the token down to the publisher that generates OMF messages, you must ensure that your network connection to the publisher uses SSL/TLS or another secure protocol. Because each OMF message contains the token, never send OMF data to a service that does not implement SSL/TLS or other secure protocol. It is recommended that you keep token expiration times short and to have your application renew the token before it expires. For example, you could specify that the token expires after 24 hours and have your application renew the token every 12 hours. By following this example, if the token is compromised, you limit the amount of time the token is valid. Data Models Publisher information is contained in an object called Publisher and has the following format: Property Type Details TenantId string Identifies the owner of the publisher. Id string A unique ID generated by the API when the publisher is created. Name string A friendly name for the publisher. Description string A description for the publisher. CreationDate string The time that the Publisher was created. The string is formatted using ISO 8601 format. Token information is contained in an object called Token and has the following format: Property Type Details Id string A unique ID generated by the API when the token is created. PublisherId string Identifies the publisher this token belongs to. TokenString string A set of claims along with a cryptographic signature that verifies that the token is legitimate and has not been tampered with. It is usedwhen building OMF messages that are sent to the OCS. CreationDate string The time that the Token was created. The string is formatted using ISO 8601 format. ExpirationDate string The time that the Token will expire. The string is formatted using ISO 8601 format. IsDeleted boolean If a Token is revoked, any clients using that token are prevented from sending data. GET api/tenants/{tenantId}/publishers/count Returns the number of publishers assigned for a specified tenant. Parameters tenantId A unique Id for the Tenant Returns Integer count of the number of publishers found. GET api/tenants/{tenantId}/publishers?skip={skip}&count={count} Returns all publishers for a tenant. Parameters tenantId Unique Id for the tenant. int skip An optional parameter representing the zero-based offset of the first publisher to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of publishers to retrieve. If not specified, a default value of 100 is used. Returns A list of Publisher objects found. GET api/tenants/{tenantId}/publishers/{publisherId} Get a specific publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Returns The Publisher object found. GET api/tenants/{tenantId}/accesscontrol/publishers Get the Access Control List that is used by default for new publishers. Parameters tenantId Unique Id for the tenant. Returns An AccessControlList object. GET api/tenants/{tenantId}/publishers/{publisherId}/accesscontrol Get the Access Control List for a specific publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Returns An AccessControlList object. GET api/tenants/{tenantId}/publishers/{publisherId}/owner Get the Owner Trustee for a specific publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Returns A Trustee object. GET api/tenants/{tenantId}/publishers/{publisherId}/tokens?skip={skip}&count={count} Get all tokens for a publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. int skip An optional parameter representing the zero-based offset of the first token to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of tokens to retrieve. If not specified, a default value of 100 is used. Returns An array of Token objects. GET api/tenants/{tenantId}/publishers/{publisherId}/tokens/{tokenId} Get a specific token Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. tokenId Unique Id for the token. Returns The token object found. PUT api/tenants/{tenantId}/publishers Creates or updates a publisher. Only the name and description of a publisher can be updated. Parameters: tenantId Unique Id for the tenant. Body A Publisher object. Returns A Publisher object. PUT api/tenants/{tenantId}/publishers/{publisherId}/tokens Create or restore a token. If the token object provided does not have a tokenId, a new token is created. Otherwise, specify the id of an existing deleted token that isn't expired, and it will be undeleted. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Body A Token object. Returns A Token object. PUT api/tenants/{tenantId}/accesscontrol/publishers Update the default Access Control List for new publishers. Parameters tenantId Unique Id for the tenant. Body An AccessControlList object. PUT tenants/{tenantId}/publishers/{publisherId}/accesscontrol Update the Access Control List for a particular publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Body An AccessControlList object. PUT tenants/{tenantId}/publishers/{publisherId}/owner Update the Owner Trustee for a particular publisher. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. Body A Trustee object. DELETE api/tenants/{tenantId}/publishers/{publisherId} Deletes a publisher. All tokens for that publisher are deleted as well. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. DELETE api/tenants/{tenantId}/publishers/{publisherId}/tokens/{tokenId} Deletes a token. Parameters tenantId Unique Id for the tenant. publisherId Unique Id for the publisher. tokenId Unique Id for the token. Returns A Token object for the deleted token."
  },
  "Documentation/DataIngress/OMF_Ingress_Specification.html": {
    "href": "Documentation/DataIngress/OMF_Ingress_Specification.html",
    "title": "Using OMF with Cloud Services",
    "keywords": "Using OMF with Cloud Services The OMF specification (located here ) is generic in that it does not specify a particular back-end system. This topic is a companion to the OMF specification which describes how OMF is interpreted by OSIsoft Cloud Services back-end system. Headers A description of each of the headers can be found in the OMF spec . When sending messages to OSIsoft Cloud Services, the value of the producertoken header must be set to a security token obtained from the OCS Portal. The security token is used to authenticate the sender and to authorize the sender for use with a particular Tenant and Publisher. The omfversion header must match the version of the OMF spec used to construct the message. Version 1.0 of the spec is currently supported. Message Types OMF message types fall into three categories: Type, Container, and Data, which are described below. Type messages A Type message is interpreted by OSIsoft Cloud Services as an SdsType in the OCS Data Store. Because SdsTypes are immutable, update operations are not supported. The keywords in the Type definition are interpreted as follows: id : Corresponds to the SdsType Id field. It must conform to the rules defined for a typeId specified here: Types classification : Only the dynamic classification is currently supported. version : Versioning of SdsTypes is not supported. name : Corresponds to the SdsType Name field. This is the friendly name for the type. description : Corresponds to the SdsType Description field. tags : Currently unsupported. metadata : Currently unsupported. The isindex keyword corresponds to the iskey attribute of a SdsTypeProperty. SdsTypes support clustered indexes which can be specified with multiple properties marked with the isindex keyword with a value of true . For compound indexes, the index property order within the message corresponds to the Order field of an SdsTypeProperty. The isname keyword is not supported. Link Type Link Types are not supported in OCS Data Store. Span Type Span Types are not supported in OCS Data Store. Property Types and Formats OMF supports setting the format keyword to specify how a particular JSON type should be interpreted. The following is a mapping for the OCS Data Store supported types (see Types ) Type Format QiTypeCode array IEnumerable boolean boolean integer int64 Int64 integer int32 Int32 integer int16 Int16 integer uint64 Uint64 integer uint32 Uint32 number uint16 Uint16 number float64 Double number float32 Single number float16 Single object dictionary Idictionary string String string date-time DateTime Container messages A Container message is interpreted as a SdsStream in the OCS Data Store. The keywords in the Container definition are interpreted as follows: id : Corresponds to the SdsStream Id field. It must conform to the rules defined for an SdsStream.Id specified here : Streams . typeid : Corresponds to the SdsStream TypeId field. typeversion : Versioning of SdsTypes is not supported. name : Corresponds to the SdsStream Name field. This is a friendly name for the stream. description : Corresponds to the SdsStream Description field. tags : Corresponds to the SdsStream Tag field. metadata : Corresponds to the SdsStream Metadata field Data messages A Data message is mapped to generic Sds values in the OCS Data Store. The keywords in the Data definitions are interpreted as follows: typeid : Data that is not grouped by containerId is not supported. containerid : Stream Id for the associated Sds Stream. typeversion : Not supported. values : An array of the generic Sds values."
  },
  "Documentation/DataIngress/OMF_Ingress_Subscriptions.html": {
    "href": "Documentation/DataIngress/OMF_Ingress_Subscriptions.html",
    "title": "Subscriptions",
    "keywords": "Subscriptions A Subscription is used to consume data from a topic. Multiple subscriptions can retrieve data from a single topic. There are two types of Subscriptions with different behaviors. The API calls in this section are used to create and manipulate subscriptions. Standard Subscription A Standard Subscription provides an endpoint for an external application to query. It maintains a bookmark into the topic queue and serves up data in sequence. Standard Subscriptions are not yet supported. OCS Data Store Subscription An OCS Data Store Subscription retrieves data from a topic and writes it directly to a namespace in the OCS Data Store. Data Models Subscription information is contained in an object called Subscription which has the following format: Property Type Details Id string Unique Id generated by the API during creation. Name string A friendly name for the Subscription. TopicId string Unique Id for the Topic we are subscribing to. TopicTenantId string Identifies the owner of the Topic. TopicNamespaceId string Identifies the namespace for the Topic TenantId string Identifies the owner of the Subscription. NamespaceId string Identifies the namespace for the Subscription IsRevoked boolean Revocation status of the Subscription. Description string Description of the Subscription. Type integer An enumeration where OCSDataStore=1, Standard=2 CreatedDate string The time that the Subscription was created. The string is formatted using ISO 8601 format. Enabled boolean Whether the topic exists or not GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/count Get the number of subscriptions for a tenant. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An integer count of subscriptions. GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions?skip={skip}&count={count} Get all subscriptions for a tenant. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. int skip An optional parameter representing the zero-based offset of the first subscription to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of subscriptions to retrieve. If not specified, a default value of 100 is used. Returns An array of Subscription objects. GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId} Get a specific subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. Returns A Subscription object that was found. GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId}/{secondsUntilExpiration} Get a security token for a subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. secondsUntilExpiration Integer number of seconds until the token expires. Returns A token string for the subscription. GET api/tenants/{tenantId}/namespaces/{namespaceId}/accesscontrol/subscriptions Gets the default Access Control List for new subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An AccessControlList object. GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId}/accesscontrol Gets the Access Control List for a particular subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. Returns An AccessControlList object. GET api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId}/owner Gets the Owner Trustee for a particular subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. Returns A Trustee object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions Create or update a subscription. Only the name and description may be updated. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body A Subscription object. Returns A Subscription object that was created or updated. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/accesscontrol/subscriptions Updates the default Access Control List for new subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body An AccessControlList object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId}/accesscontrol Updates the Access Control List for a particular subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. Body An AccessControlList object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId}/owner Updates the Owner Trustee for a particular subscriptions Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the subscription. Body A Trustee object. DELETE api/tenants/{tenantId}/namespaces/{namespaceId}/subscriptions/{subscriptionId} Delete a Subscription. Parameters tenantId Unique Id for the tenant. subscriptionId Unique Id for the subscription."
  },
  "Documentation/DataIngress/OMF_Ingress_Topics.html": {
    "href": "Documentation/DataIngress/OMF_Ingress_Topics.html",
    "title": "Topics",
    "keywords": "Topics Topic information A Topic is used to aggregate data received from publishers and make it available for consumption via a Subscription. A topic must contain at least one publisher. Publishers may be added to or removed from an existing topic. A given publisher may also belong to multiple topics. When a topic is created, data sent from its assigned publishers is routed to a special queue where it can be consumed by a subscription. This queue provides a buffer of up to one day for subscriptions which are temporarily unable to receive data. While OMF messages may be sent to OCS immediately after creating a Topic, the messages cannot be made available for consumption until a Subscription is created. However, some messages are stored for later consumption in OCS databases. See OMF documentation for more information. The API calls in this section are used to create and manipulate topics. Data Models Topic information is contained in an object called Topic and has the following format: Property Type Details TenantId string Identifies the owner of the Topic Id string Unique Id generated by the API during creation NamespaceId string Identifies the namespace for the Topic Name string A friendly name for the Topic Description string An optional description for the Topic. CreationDate string The time that the Topic was created. The string is formatted using ISO 8601 format. Publishers string array An array of Publisher Ids mapped to the Topic GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/count Get the number of topics for a tenant. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An integer. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId} Get a specific topic. Parameters tenantId Unique Id for the tenant. topicId Unique Id for the topic. namespaceId Unique Id for the namespace. Returns A Topic object. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics?skip={skip}&count={count} Get all topics for a tenant. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. int skip An optional parameter representing the zero-based offset of the first topic to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of topics to retrieve. If not specified, a default value of 100 is used. Returns An array of Topic objects. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/subscriptions?skip={skip}&count={count} Get all subscriptions across all namespaces mapped to a topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace of the topic. topicId Unique Id for the topic. int skip An optional parameter representing the zero-based offset of the first subscription mapped to a topic to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of subscriptions mapped to a topic to retrieve. If not specified, a default value of 100 is used. Returns An array of Subscription objects. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/publishers?skip={skip}&count={count} Gets a list of publishers that are currently mapped to a topic Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace of the topic. topicId Unique Id for the topic. int skip An optional parameter representing the zero-based offset of the first publisher mapped to a topic to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of publishers mapped to a topic to retrieve. If not specified, a default value of 100 is used. Returns An array of Publisher objects. GET api/tenants/{tenantId}/namespaces/{namespaceId}/accesscontrol/topics Gets the default Access Control List for new topics. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An AccessControlList object. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/accesscontrol Gets the Access Control List for a particular topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the topic. Returns An AccessControlList object. GET api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/owner Gets the Owner Trustee for a particular topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the topic. Returns A Trustee object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/topics Creates or updates a topic. Only the topic name and description can be updated. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body A MappedTopic object. Returns A MappedTopic object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/accesscontrol/topics Update the default Access Control List for new topics Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body An AccessControlList object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/accesscontrol Update the Access Control List for a particular topic Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the topic. Body An AccessControlList object. PUT api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId}/owner Update the Owner Trustee for a particular topic Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the topic. Body A Trustee object. DELETE api/tenants/{tenantId}/namespaces/{namespaceId}/topics/{topicId} Delete a topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the topic."
  },
  "Documentation/DataIngress/OMF_Ingress_to_OCS.html": {
    "href": "Documentation/DataIngress/OMF_Ingress_to_OCS.html",
    "title": "Data ingress to Cloud Services using OMF",
    "keywords": "Data ingress to Cloud Services using OMF You can use OSIsoft Message Format (OMF) to achieve high-throughput asynchronous data ingress into the OCS data store. The following terms might be useful for understanding the information in this and subsequent topics: A producer of OMF messages intended for OCS is called a Publisher . Messages are sent to a queue called a Topic . A Subscription recieves messages from a Topic and writes them either to the OCS data store or makes them available to an external consumer."
  },
  "Documentation/Management/Account_ClientRole.html": {
    "href": "Documentation/Management/Account_ClientRole.html",
    "title": "Client Roles",
    "keywords": "Client Roles Client Roles authorize API requests made by clients to various OCS features. Clients can be assigned more than one Role , but all clients have the Account Member role. The following are currently available Client Roles : Account Administrator: Can add, edit, and remove data using APIs except for displays. Account Contributor: Can add, edit, and remove data using APIs for displays. Account Member: Can read data using most APIs, except displays. Account Viewer: Can read data using APIs for displays. Properties For HTTP requests and responses, the ClientRole object has the following properties and JSON-serialized body: Property Type Description ClientId string Client Id. RoleId string Role Id. { \"ClientId\": \"clientid\", \"RoleId\": \"roleid\" } AddRoleToClient() Assigns a Role to a specified client. Http PUT api/Tenants/{tenantId}/Clients/{clientId}/Roles/{roleId} Parameters [Required] string tenantId The identifier of the account in which the client belongs to. [Required] string clientId The identifier of the client who will be given the role. [Required] string roleId The identifier of the Role to be assigned. Security A Role can only be assigned to a client by an Account Administrator. Returns Status Code Return Type Description 200 Role Returns the Role with the specified roleId. 400 Nothing is returned Could not assign Role to client due to missing or invalid input. 403 Nothing is returned Unauthorized to add a Role to this client. 404 Nothing is returned The client was not found in the specified Tenant . ReplaceClientRoles() Replaces the Roles of a client with a new list of roles. Http PUT api/Tenants/{tenantId}/Clients/{clientId}/Roles Parameters [Required] string tenantId The identifier of the account the client belongs to. [Required] string clientId The identifier of the client whose roles will be replaced. [Required] [FromBody] [Role] roleList List of Role objects to set as the Roles for the specified client. Security Roles of a client can only be replaced by an Account Administrator. Returns Status Code Return Type Description 200 [Role] Returns a list of all Role objects assigned to the user specified by clientId after the replacement operation is complete. 400 Nothing is returned Could not replace Roles due to missing or invalid input. 403 Nothing is returned Unauthorized to replace Roles of this client. 404 Nothing is returned The client was not found in the specified Tenant . RemoveRoleFromClient() Removes a Role from a client. Http DELETE api/Tenants/{tenantId}/Clients/{clientId}/Roles/{roleId} Parameters [Required] string tenantId The identifier of the account in which the client belongs to. [Required] string clientId The identifier of the client whose role will be removed. [Required] string roleId The identifier of the Role to be removed. Security A Role can only be removed from a client by an Account Administrator. Returns Status Code Return Type Description 204 Nothing is returned The Role was removed from the client. 400 Nothing is returned Could not remove the Role from the client due to missing or invalid input. 403 Nothing is returned Unauthorized to remove a Role from this client. 404 Nothing is returned The client was not found in the specified Tenant . Find() Retrieves all Roles from a client. Http GET api/Tenants/{tenantId}/Clients/{clientId}/Roles Parameters [Required] string tenantId The identifier for the account in which the client belongs to. [Required] string clientId The identifier of the client whose Roles will be retrieved. [Required] string skip Number of Roles to ignore. [Required] string count Number of Roles to return. Security Roles can be retrieved by an Account Administrator. Returns Status Code Return Type Description 200 [Role] Returns a list of Role objects belonging to the client with the specified clientId. 400 Nothing is returned Could not retrieve Roles from the client due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve Roles from this client. 404 Nothing is returned The client was not found in the specified Tenant ."
  },
  "Documentation/SequentialDataStore/Compression.html": {
    "href": "Documentation/SequentialDataStore/Compression.html",
    "title": "Compression",
    "keywords": "Compression To more efficiently utilize network bandwidth the OCS Sequential Data Store supports compression for reading data and writing data through the REST API Supported compression schemes gzip deflate Request compression (writing data) The body content of an HTTP request can be compressed using the Supported compression schemes _ allowing you to send stream values to the REST API more efficiently. The Content-Encoding HTTP header must be used to specify the compression scheme of compressed-content requests. This header provides context to the API to properly decode the request content. Response compression (reading data) Compressed responses can be requested from the REST API by specifying one of the Supported compression schemes _ using the Accept-Encoding HTTP header. Compressed responses from the REST API will include a Content-Encoding HTTP header indicating the compression scheme used to compress the response content. Note that specifying a compression scheme through the use of the Accept-Encoding HTTP header does not guarantee a compressed response. Always refer to presence and value of the Content-Encoding HTTP header of the response to properly decode the response content."
  },
  "Documentation/SequentialDataStore/Data_Store_and_SDS.html": {
    "href": "Documentation/SequentialDataStore/Data_Store_and_SDS.html",
    "title": "Sequential Data Store",
    "keywords": "Sequential Data Store The OSIsoft Cloud Services (OCS) Sequential Data Store (SDS) is an optimized sequential data store based on Qi technology. SDS is an OSIsoft technology that implements a data store that is optimized for dynamic data. Some of the features of the data store include: Support for complex data types Support for complex indexes The Data store is hosted by OSIsoft, LLC, and provides an easy-to-use and access REST API."
  },
  "Documentation/SequentialDataStore/Filter_Expressions.html": {
    "href": "Documentation/SequentialDataStore/Filter_Expressions.html",
    "title": "Filter Expressions: Values",
    "keywords": "Filter Expressions: Values Filter expressions can be applied to certain read operations that return Sequential Data Store values or objects. This section covers data values. For filtering on metadata objects refer to Filter Expressions: Metadata Objects . Filter expressions can be applied to any read that returns multiple values, including Get Values , Get Range Values , Get Window Values , and Get Intervals .” QiTypeCodes Supported The following types are supported for use within a filter expression: Boolean Byte Char DateTime DateTimeOffset Decimal Double Guid Int16 Int32 Int64 Sbyte Single String Timespan UInt16 UInt32 Uint64 Types that are not supported The following types are not supported for use within a filter expression: Array IEnumerable IDictionary IList QiType QiTypeProperty Nullable Types Logical operators Supported The following logical operators are supported for use within a filter expression: Operator Comment eq Equal to ne Not equal ge Greater than or equal to le Less than or equal to lt Less than gt Greater than ( ) Parenthesis can be used to affect the order of the operation or Or logical operator and And logical operator not Not logical operator - Negation Logical Operator Examples For the following examples, assume that the Qi Type event includes a field named Value of type double : Value eq 1.0 Value ne 15.6 Value ge 5.0 Value le 8.0 Value gt 5.0 Value lt 4.0 Value gt 2.0 and Value lt 9.0 Value gt 6.0 or Value lt 2.0 not (Value eq 1.0) Math functions Supported The following math functions are supported for use within a filter expression: Function Comment add Addition sub Subtraction mul Multiplication div Division mod Modulo round Rounds to the nearest numeric component without a decimal, with the midpoint rounded away from 0. For example, 0.5 rounds to 1; -0.5 rounds to -1) floor Rounds down to the nearest numeric component without a decimal ceiling Rounds up to the nearest numeric component without a decimal Math Function Examples For the following examples, assume that the Qi Type event includes a field named Value of type double : Value eq (6.0 add 3.0) Value eq (6.0 sub 3.0) Value eq (6.0 mul 3.0) Value eq (6.0 div 3.0) Value eq (7.0 mod 3.0) round(Value) eq 16 floor(Value) eq 15 ceiling(Value) eq 16 String functions Supported String operations are case sensitive. The character index in a string is 0-based. The following string functions are supported for use within a filter expression: function Comment endswith Compare the character at the end of the input string startwith Compare the character at the start of the input string length Examines the string length indexof Examines the character starting at a given index substring Examine characters within another string at a specific location substringof Search for characters anywhere in another string tolower Convert characters to lowercase toupper Convert characters to uppercase trim Remove whitespace from front and end of a string concat Concatenate strings together replace Replace one set of characters with another String function examples The following examples assume that the Qi Type event includes a field named sValue of type string : Example Result endswith(sValue, 'XYZ') True if sValue ends with the characters ‘XYZ’ startswith(sValue, 'Val' True if sValue starts with the characters ‘Val’ length(sValue) eq 11 True if sValue is 11 characters indexof(sValue, 'ab') eq 4 True if the 5th and 6th characters are ‘ab’ substring(sValue, 10) eq 'a b' True if ‘a b’ is found in sValue at index 10 substringof('ab',sValue) True if characters ‘ab’ are found anywhere in sValue tolower(sValue) eq 'val5' Change sValue to lowercase and compare to ‘val5’ toupper(sValue) eq 'ABC' Change sValue to uppercase and compare to ‘ABC’ trim(sValue) eq 'vall22' Trim whitespace from front and end of sValue and compare to ‘val22’ concat(sValue,'xyz') eq 'dataValue_7xyz' Add characters to sValue and compare to ‘dataValue_7xyz’ replace(sValue,'L','D') eq 'Dog1' Replace any ‘L’ in sValue with ‘D’ and compare to ‘Dog1’ DateTime functions Supported The following DateTime functions are supported for use within a filter expression: Function Comment year Get year value from DateTime month Get month value from DateTime day Get day value from DateTime hour Get hour value from DateTime minute Get minute value from DateTime second Get second value from DateTime DateTime Function Examples The following examples assume that the Qi Type event includes a field named TimeId of type DateTime : year(TimeId) eq 2015 month(TimeId) eq 11 day(TimeId) eq 3 hour(TimeId) eq 1 minute(TimeId) eq 5 second(TimeId) eq 3 TimeSpan functions Supported The following TimeSpan functions are supported for use within a filter expression: function Comment years Get year value from TimeSpan days Get day value from TimeSpan hours Get hour value from TimeSpan minutes Get minute value from TimeSpan seconds Get second value from TimeSpan TimeSpan Function Examples For the following examples, assume that the Qi Type event includes a field named TimeSpanValue of type TimeSpan : years(TimeSpanValue) eq 1 days(TimeSpanValue) eq 22 hours(TimeSpanValue) eq 1 minutes(TimeSpanValue) eq 1 seconds(TimeSpanValue) eq 2"
  },
  "Documentation/SequentialDataStore/Filter_Expressions_Metadata.html": {
    "href": "Documentation/SequentialDataStore/Filter_Expressions_Metadata.html",
    "title": "Filter Expressions: Metadata Objects",
    "keywords": "Filter Expressions: Metadata Objects This section focuses on filter expressions that can be applied to certain read operations that return Sequential Data Store objects (e.g. Streams, Types). For filtering on read operations of Sequential Data Store values refer to Filter Expressions: Values . Filter expressions can be applied to any read operation that returns multiple values, including Get Types and Get Streams . Fields For Streams and Types, filter expressions are valid for the same properties that are valid for the Search parameter. Valid fields for both Streams and Types are Name , Id , and Description . Streams have an additional TypeId field that is filterable. Additionally, Types have a collection of SdsTypeProperty objects held in a field named Properties (see Types ). When filtering on these property objects, the filter is applied to the Name or Id of the property. If the Type derives from a base Type, the inherited properties will be filtered as well. To perform a filter on this collection, the Any() or All() functions must be used (see Lambda Operators ). String functions Supported String operations are case insensitive for both the search value and the field name provided. The following string functions are supported for use within a filter expression: function Comment endswith Compare the character at the end of the input string startwith Compare the character at the start of the input string substringof Search for characters anywhere in another string String function examples Example Result endswith(Name, 'xyz') True if Name ends with the string ‘xyz’ startswith(Id, 'abc') True if Id starts with the string ‘abc’ substringof('bc', Name) True if string ‘bc’ is found anywhere in Name Logical operators Supported The following logical operators are supported for use within an object filter expression: Operator Comment eq Equal to ( ) Parenthesis can be used to affect the order of the operation or Or logical operator and And logical operator not Not logical operator Not all operators supported for values are supported for filtering on object metadata string fields. Logical Operator Examples The following examples show logical operators and string functions. Name eq 'abcxyz' startswith(Id, 'abc') and endswith(Id, 'xyz') startswith(Id, 'abc') or startswith(Name, 'abc') not (Name eq 'abcxyz') startswith(Id, 'abc') and not endswith(Id, 'xyz') (startswith(Id, 'abc') and endswith(Id, 'xyz')) or (startswith(Name, 'abc') and endswith(Name, 'abc')) Lambda operators Lambda operators are used for operations against a field which is a collection of strings. The lambda operators require defining a lambda parameter and a boolean expression. Note that currently the only supported boolean expressions for the nested clause of the lambda operators are the three string functions and the equals logical operator. Other logical operators are not allowed. Supported The following lambda operators are supported for use within an object filter expression: Operator Comment any Match if any elements of the collection match the criteria all Match if all elements of the collection match the criteria Lambda Operator Examples The following examples show logical operators which have a body defining the required lambda parameter and a single boolean expression. The lambda parameter is defined initially, and in the provided examples the user has chosen a query time lambda parameter named \"parameter\". After the ':' proceed to define your expression as defined in the aforementioned examples for string functions (or the 'eq' logical operator ) but replace all references to your SdsType/SdsStream field name with the lambda parameter name. Properties/any(parameter: parameter eq 'value') Properties/all(parameter: startswith(parameter, 'abc'))"
  },
  "Documentation/SequentialDataStore/indexes.html": {
    "href": "Documentation/SequentialDataStore/indexes.html",
    "title": "Indexes",
    "keywords": "Indexes Indexes speed up and order the results of searches. A key uniquely identifies a record within a collection of records. Keys are unique within the collection. In Sds, the key of an SdsType is also an index. The key is often referred to as the primary index, while all other indexes are referred to as secondary indexes or secondaries . An SdsType that is used to define an SdsStream must specify a key. When inserting data into an SdsStream, every key value must be unique. Sds will not store more than a single event for a given key; an event with a particular key may be deleted or updated, but two events with the same key cannot exist. In .NET, the SdsType properties that define the key are identified using an OSIsoft.Sds.SdsMemberAttribute and setting its IsKey field to true. If the key consists of only a single property it is permissible to use the System.ComponentModel.DataAnnotations.KeyAttribute . In the SdsType, the Property or Properties representing the key have their SdsTypeProperty.IsKey field set to true. Secondary indexes are defined on SdsStreams and are applied to a single property. You can define many secondary indexes. Secondary index values need not be unique. The following table contains supported index types: Type SdsTypeCode Boolean 3 Byte 6 Char 4 DateTime 16 DateTimeOffset 20 Decimal 15 Double 14 Guid 19 Int16 7 Int32 9 Int64 11 SByte 5 Single 13 String 18 TimeSpan 21 UInt16 8 UInt32 10 UInt64 12 Compound Indexes Often, a single property (such as a DateTime), is adequate for defining an index; however, for more complex scenarios, Sds allows you to define multiple properties. Indexes defined by multiple properties are known as compound indexes . When defining a compound index in .NET, you should apply the OSIsoft.Sds.SdsMemberAttribute on each of the type’s properties that are combined to define the index. Set the IsKey property to true and give Orderfield a zero-based index value. The Order field defines the precedence of the property when sorting. A property with an order of 0 has highest precedence. When defining compound indexes outside of .NET, specify the IsKey and Order fields on the SdsTypePropertyor Properties. Only the primary index (or key) supports compound indexes. You can specify a maximum of three Properties to define a compound index. The Sds REST API methods that use tuples were created to assist you when using compound indexes. Working with Indexes Using .NET Simple Indexes When working in .NET, use the SdsTypeBuilder together with either the OSIsoft.Sds.SdsMemberAttribute or the System.ComponentModel.DataAnnotations.KeyAttribute to identify the Property that defines the simple Key. The SdsMemberAttribute is preferred. Using SdsTypeBuilder eliminates potential errors that might occur when working with SdsTypes manually. public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType<Simple>(); To read data that is located between two indexes, ordered by the Key, define both a start index and an end index. For DateTime, use ISO 8601 representation of dates and times. For example, to query for a window of simple values between January 1, 2010 and February 1, 2010, you can define indexes and query as follows. IEnumerable<Simple> values = await client.GetWindowValuesAsync<Simple>(simpleStream.Id, \"2010-01-01T08:00:00.000Z\",\"2010-02-01T08:00:00.000Z\"); More information about querying data can be found in Reading data . Secondary Indexes Secondary indexes are defined at the SdsStream. To add indexes to an SdsStream, you add them to the SdsStream’s Indexes field. For example, to add a second index on Measurement, use the following code: SdsStreamIndex measurementIndex = new SdsStreamIndex() { SdsTypePropertyId = simpleType.Properties.First(p => p.Id.Equals(\"Measurement\")).Id }; SdsStream secondary = new SdsStream() { Id = \"Simple with Secondary\", TypeId = simpleType.Id, Indexes = new List<SdsStreamIndex>() { measurementIndex } }; secondary = await config.GetOrCreateStreamAsync(secondary); To read data indexed by a secondary Index, use a filtered Get, as in the following: await client.UpdateValuesAsync<Simple>(secondary.Id, new List<Simple>() { new Simple() { Time = time, State = State.Ok, Measurement = 5 }, new Simple() { Time = time + TimeSpan.FromSeconds(1), State = State.Ok, Measurement = 4 }, new Simple() { Time = time + TimeSpan.FromSeconds(2), State = State.Ok, Measurement = 3 }, new Simple() { Time = time + TimeSpan.FromSeconds(3), State = State.Ok, Measurement = 2 }, new Simple() { Time = time + TimeSpan.FromSeconds(4), State = State.Ok, Measurement = 1 }, }); IEnumerable<Simple> orderedByKey = await client.GetWindowValuesAsync<Simple>(secondary.Id, time.ToString(\"o\"), time.AddSeconds(4).ToString(\"o\")); foreach (Simple value in orderedByKey) Console.WriteLine(\"{0}: {1}\", value.Time, value.Measurement); Console.WriteLine(); IEnumerable<Simple> orderedBySecondary = await client.GetFilteredValuesAsync<Simple>(secondary.Id, \"Measurement gt 0 and Measurement lt 6\"); foreach (Simple value in orderedBySecondary) Console.WriteLine(\"{0}: {1}\", value.Time, value.Measurement); Console.WriteLine(); // Output: // 1/20/2017 12:00:00 AM: 5 // 1/20/2017 12:00:01 AM: 4 // 1/20/2017 12:00:02 AM: 3 // 1/20/2017 12:00:03 AM: 2 // 1/20/2017 12:00:04 AM: 1 // // 1/20/2017 12:00:04 PM: 1 // 1/20/2017 12:00:03 PM: 2 // 1/20/2017 12:00:02 PM: 3 // 1/20/2017 12:00:01 PM: 4 // 1/20/2017 12:00:00 PM: 5 Compound Indexes Compound indexes are defined using the SdsMemberAttribute as follows: public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } public class DerivedCompoundIndex : Simple { [SdsMember(IsKey = true, Order = 1)] public DateTime Recorded { get; set; } } Events of type DerivedCompoundIndex are sorted first by the Time parameter and then by the Recorded parameter. A collection of times would be sorted as follows: Time Recorded Measurement 01:00 00:00 0 01:00 01:00 2 01:00 14:00 5 02:00 00:00 1 02:00 01:00 3 02:00 02:00 4 02:00 14:00 6 If the Order parameters were swapped, Recorded set to zero, and Time set to one, the results would sort as follows: Time Recorded Measurement 01:00 00:00 0 02:00 00:00 1 01:00 01:00 2 02:00 01:00 3 02:00 02:00 4 01:00 14:00 5 02:00 14:00 6 // estimates at 1/20/2017 00:00 await client.UpdateValuesAsync(compoundStream.Id, new List<DerivedCompoundIndex>() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 01:00\"), Recorded = DateTime.Parse(\"1/20/2017 00:00\"), State = State.Ok, Measurement = 0 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 02:00\"), Recorded = DateTime.Parse(\"1/20/2017 00:00\"), State = State.Ok, Measurement = 1 }, }); // measure and estimates at 1/20/2017 01:00 await client.UpdateValuesAsync(compoundStream.Id, new List<DerivedCompoundIndex>() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 01:00\"), Recorded = DateTime.Parse(\"1/20/2017 01:00\"), State = State.Ok, Measurement = 2 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 02:00\"), Recorded = DateTime.Parse(\"1/20/2017 01:00\"), State = State.Ok, Measurement = 3 }, }); // measure at 1/20/2017 02:00 await client.UpdateValuesAsync(compoundStream.Id, new List<DerivedCompoundIndex>() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 02:00\"), Recorded = DateTime.Parse(\"1/20/2017 02:00\"), State = State.Ok, Measurement = 4 }, }); // adjust earlier values at 1/20/2017 14:00 await client.UpdateValuesAsync(compoundStream.Id, new List<DerivedCompoundIndex>() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 01:00\"), Recorded = DateTime.Parse(\"1/20/2017 14:00\"), State = State.Ok, Measurement = 5 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/20/2017 02:00\"), Recorded = DateTime.Parse(\"1/20/2017 14:00\"), State = State.Ok, Measurement = 6 }, }); var from = new Tuple<DateTime, DateTime>(DateTime.Parse(\"1/20/2017 01:00\"), DateTime.Parse(\"1/20/2017 00:00\")); var to = new Tuple<DateTime, DateTime>(DateTime.Parse(\"1/20/2017 02:00\"), DateTime.Parse(\"1/20/2017 14:00\")); var compoundValues = await client.GetWindowValuesAsync<DerivedCompoundIndex, DateTime, DateTime>(compoundStream.Id, from, to); foreach (DerivedCompoundIndex value in compoundValues) Console.WriteLine(\"{0}:{1} {2}\", value.Time, value.Recorded, value.Measurement); // Output: // 1/20/2017 1:00:00 AM:1/20/2017 12:00:00 AM 0 // 1/20/2017 1:00:00 AM:1/20/2017 1:00:00 AM 2 // 1/20/2017 1:00:00 AM:1/20/2017 2:00:00 PM 5 // 1/20/2017 2:00:00 AM:1/20/2017 12:00:00 AM 1 // 1/20/2017 2:00:00 AM:1/20/2017 1:00:00 AM 3 // 1/20/2017 2:00:00 AM:1/20/2017 2:00:00 AM 4 // 1/20/2017 2:00:00 AM:1/20/2017 2:00:00 PM 6 Note that the GetWindowValuesAsync() call specifies an expected return type and the index types as generic parameters. Not Using .NET Simple Indexes When the .NET SdsTypeBuilder is unavailable, indexes must be built manually. The following discusses the types defined in the Python <https://github.com/osisoft/Qi-Samples/tree/master/Basic/Python> and Java Script <https://github.com/osisoft/Qi-Samples/tree/master/Basic/JavaScript> samples. Samples in other languages can be found here <https://github.com/osisoft/Qi-Samples/tree/master/Basic> __. To build a SdsType representation of the following sample class, see code_example_1_: Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Aalrm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } code_example_1 The following code is used to build an SdsType representation of the sample class above: Python # Create the properties # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime # State is not a pre-defined type. An SdsType must be defined to represent the enum stateTypePropertyOk = SdsTypeProperty() stateTypePropertyOk.Id = \"Ok\" stateTypePropertyOk.Measurement = State.Ok stateTypePropertyWarning = SdsTypeProperty() stateTypePropertyWarning.Id = \"Warning\" stateTypePropertyWarning.Measurement = State.Warning stateTypePropertyAlarm = SdsTypeProperty() stateTypePropertyAlarm.Id = \"Alarm\" stateTypePropertyAlarm.Measurement = State.Alarm stateType = SdsType() stateType.Id = \"State\" stateType.Name = \"State\" stateType.Properties = [ stateTypePropertyOk, stateTypePropertyWarning,\\ stateTypePropertyAlarm ] state = SdsTypeProperty() state.Id = \"State\" state.Name = \"State\" state.SdsType = stateType # Measurement property is a simple non-indexed, pre-defined type measurement = SdsTypeProperty() measurement.Id = \"Measurement\" measurement.Name = \"Measurement\" measurement.SdsType = SdsType() measurement.SdsType.Id = \"Double\" measurement.SdsType.Name = \"Double\" # Create the Simple SdsType simple = SdsType() simple.Id = str(uuid.uuid4()) simple.Name = \"Simple\" simple.Description = \"Basic sample type\" simple.SdsTypeCode = SdsTypeCode.Object simple.Properties = [ time, state, measurement ] JavaScript // Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); // State is not a pre-defined type. A SdsType must be defined to represent the enum var stateTypePropertyOk = new SdsObjects.SdsTypeProperty({ \"Id\": \"Ok\", \"Value\": State.Ok }); var stateTypePropertyWarning = new SdsObjects.SdsTypeProperty({ \"Id\": \"Warning\", \"Value\": State.Warning }); var stateTypePropertyAlarm = new SdsObjects.SdsTypeProperty({ \"Id\": \"Alarm\", \"Value\": State.Alarm }); var stateType = new SdsObjects.SdsType({ \"Id\": \"State\", \"Name\": \"State\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Int32Enum, \"Properties\": [stateTypePropertyOk, stateTypePropertyWarning, stateTypePropertyAlarm, stateTypePropertyRed] }); // Value property is a simple non-indexed, pre-defined type var valueProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Value\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"doubleType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Double }) }); // Create the Simple SdsType var simpleType = new SdsObjects.SdsType({ \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": \"This is a simple Sds type\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [timeProperty, stateProperty, valueProperty] }); The Time property is identified as the Key by define its SdsTypeProperty as follows: Python # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime JavaScript // Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); Note that the time.IsKey field is set to true. To read data using the key, you define a start index and an end index. For DateTime, use ISO 8601 representation of dates and times. To query for a window of values between January 1, 2010 and February 1, 2010, you would define indexes as “2010-01-01T08:00:00.000Z” and “2010-02-01T08:00:00.000Z”, respectively. Additional information can be found in Reading data . Secondary Indexes Secondary Indexes are defined at the SdsStream. To create an SdsStream using the Simple class and add a Secondary index on the Measurement, you use the previously defined SdsType. Then you create a SdsStreamIndex specifying the measurement property and define a SdsStream identifying the Measurement as a Secondary Index as shown in the following example: Python # Create the properties measurementIndex = SdsStreamIndex() measurementIndex.SdsTypePropertyId = measurement.Id stream = SdsStream() stream.Id = str(uuid.uuid4()) stream.Name = \"SimpleWithSecond\" stream.Description = \"Simple with secondary index\" stream.TypeId = simple.Id stream.Indexes = [ measurementIndex ] JavaScript var measurementIndex = new SdsObjects.SdsStreamIndex({ \"SdsTypePropertyId\": valueProperty.Id }); var stream = new SdsObjects.SdsStream({ \"Id\": \"SimpleWithSecond\", \"Name\": \"SimpleWithSecond\", \"Description\": \"Simple with secondary index\", \"TypeId\": simpleTypeId, \"Indexes\": [ measurementIndex ] }); Compound Indexes Consider the following Python and JavaScript types: Python class Simple(object): # First-order Key property Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement class DerivedCompoundIndex(Simple): # Second-order Key property @property def Recorded(self): return self.__recorded @Recorded.setter def Recorded(self, recorded): self.__recorded = recorded JavaScript var Simple = function () { this.Time = null; this.State = null; this.Value = null; } var DerivedCompoundIndex = function() { Simple.call(this); this.Recorded = null; } To turn the simple SdsType shown in the example into a type supporting the DerivedCompoundIndex type with a compound index based on the Simple.Time and DerivedCompoundIndex.Recorded , extend the type as follows: Python # We set the Order for this property. The order of the first property defaulted to 0 recorded = SdsTypeProperty() recorded.Id = \"Recorded\" recorded.Name = \"Recorded\" recorded.IsKey = True recorded.Order = 1 recorded.SdsType = SdsType() recorded.SdsType.Id = \"DateTime\" recorded.SdsType.Name = \"DateTime\" recorded.SdsType.SdsTypeCode = SdsTypeCode.DateTime # Create the Derived SdsType derived = SdsType() derived.Id = str(uuid.uuid4()) derived.Name = \"Compound\" derived.Description = \"Derived compound index sample type\" derived.BaseType = simple derived.SdsTypeCode = SdsTypeCode.Object derived.Properties = [ recorded ] JavaScript // We set the Order for this property. The order of the first property defaulted to 0 var recordedProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Recorded\", \"Name\": \"Recorded\", \"IsKey\": true, \"Order\": 1, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"DateTime\", \"Name\": \"DateTime\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); // Create the Derived SdsType var derivedType = new SdsObjects.SdsTyp({ \"Id\": \"Compound\", \"Name\": \"Compound\", \"Description\": \"Derived compound index sample type\", \"BaseType\": simpleType, \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [recordedProperty] }); Data in the stream will be ordered as follows: Time Recorded Measurement 01:00 00:00 0 01:00 01:00 2 01:00 14:00 5 02:00 00:00 1 02:00 01:00 3 02:00 02:00 4 02:00 14:00 6 If the Order was swapped, and Recorded set as zero, the results would sort as follows: Time Recorded Measurement 01:00 00:00 0 02:00 00:00 1 01:00 01:00 2 02:00 01:00 3 02:00 02:00 4 01:00 14:00 5 02:00 14:00 6"
  },
  "Documentation/SequentialDataStore/Introducing_SDS.html": {
    "href": "Documentation/SequentialDataStore/Introducing_SDS.html",
    "title": "Introducing the Sequential Data Store",
    "keywords": "Introducing the Sequential Data Store The Sequential Data Store (SDS) is a highly flexible cloud-based sequential data store that you use to store, retrieve, and analyze data. You create and write data to streams using a simple REST ( REpresentational State Transfer ) API ( Application Programming Interface ). The streams you create can be used to store simple or complex data types to suit your application needs. You can define simple or complex indexing to arrange and relate your data. An assortment of methods with customizable behaviors are available to read data and easily obtain needed information. Access to SDS You must acquire a Tenant, security credentials, and a Namespace before interacting with the Data Store. If you do not have a Tenant, you can request access to the SDS Preview at OSIsoft Cloud Services . The SDS Preview program is limited; contacting OSIsoft does not assure participation. If you are selected to participate in the preview, you will receive an email notifying you of the name of your Tenant. Use the credentials you were provided to sign into the portal. Signing in grants you access to additional functionality. Samples The best way to get started with SDS is to run one or more of the code samples. Code samples are provided in a number of different programming languages to illustrate how to easily and effectively interact with SDS. The code samples can be found in the SDS-Samples repository on GitHub. Obtain SDS REST API access keys from https://cloud.osisoft.com before running the sample code. Each sample includes a readme file which describes the steps required to run the sample and a brief description that highlights some of the sample’s functionality. Be sure to read the readme file to understand how the sample works. After you have finished this introduction and worked with one of the samples, refer to the Quick start section, which describes the interaction of various SDS objects and helps you get started with your own application. Architecture A Tenant represents a client or organization that owns and manages a collection of OSIsoft Cloud Services, including the Sequential Data Store. Tenants are divided into one or more logical units called Namespaces. Each Namespace is distinct and separate from other Namespaces, with its own instances of the various OSIsoft Cloud Services and data stores. Namespaces provide isolation of resources. Isolation provided by Tenants and Namespaces prevent accidental or malicious data access. Getting help The following email address is available to participants of the SDS Preview for both product support and feedback: CloudServices@osisoft.com The OSIsoft team will respond to all support requests as quickly as possible during business hours (Pacific Time)."
  },
  "Documentation/SequentialDataStore/Quick_Start.html": {
    "href": "Documentation/SequentialDataStore/Quick_Start.html",
    "title": "Quick start",
    "keywords": "Quick start .. contents:: Topics in this section: :depth: 3 SDS quick start SDS is a sophisticated data store. The information in this section describes a very simple interaction with SDS. To follow along with the steps in this section, you will first need a Tenant and associated security credentials. If you have not already acquired a tenant, email SDS support at: OSIsoft Cloud Services . The Preview is limited; contacting OSIsoft does not assure participation. Throughout this guide, you will be instructed to interact with the Portal. To access the section identified, you must sign into the Portal using the credentials associated with the Tenant. You will also need a Namespace and administrative client keys. Step 1: Acquire a Namespace Navigate to the OSIsoft Cloud Services page. Then, select the Manage tab and select Namespaces . For the steps in this section, you can use either an existing Namespace or you can create a new Namespace. Step 2: Acquire client keys For this example, the application acts as a confidential client – an application that is capable of securely maintaining a secret. In Azure Active Directory, the confidential client authentication flow is accomplished using an Application Identity . OSIsoft Cloud Services supports this authentication with a Client Key and a Secret. To acquire the Client Key from the portal, select Client Keys under Manage , as shown in the following image: You can either select an existing key or create a new key. Click the eye icon next to the desired key to see configuration information. You will need the Tenant Identity, Client Identity, and Client Secret to proceed. The Tenant Identity, Client Identity, and Client Secret are used to acquire a security Token from an identity provider (Azure Active Directory). Step 3: Acquire authentication token You use the Tenant Identity, Client Identity, and Client Secret to acquire an access token from Azure Active Directory. Click on the eye icon next to the desired key to see the values and code samples for various languages. Step 4: Create data types An SdsType describes the structure of a single measured event or object. An SdsStream has an associated SdsType and stores a stream of events or objects that take the shape of that type. An SdsType consists of one or more data properties, one of which must represent an index. Indexes can be simple, such as a single integer property, or compound, represented by multiple properties. DateTime is a common index for time-series stores. SDS supports a wide variety of property types, including simple types like integers, strings and floats and complex types like lists, arrays and enumerations. Properties can be of any complex SdsType. For additional information, including a detailed list of supported data types, refer to Types . To create an SdsType in .NET, use the .NET SDS libraries SdsTypeBuilder. public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType<Simple>(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; simpleType.Description = \"Basic sample type\"; await config.CreateTypeAsync(simpleType); When working outside of .NET, SDS libraries are unavailable. The SdsType is defined using JSON and is posted to the OSIsoft Cloud Services endpoint. POST /api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId} HTTP/1.1 Authorization: Bearer <bearer-token> Content-Length: 1562 Content-Type: application/json Host: dat-a.osisoft.com { \"$id\":\"1\", \"Id\":\"Simple\", \"Name\":\"Simple\", \"Description\":\"Basic sample type\", \"SdsTypeCode\":1, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":[ { \"Id\":\"Time\", \"Name\":\"Time\", \"Description\":null, \"Order\":0, \"IsKey\":true, \"FixedSize\":0, \"SdsType\":{ \"$id\":\"2\", \"Id\":\"c48bfdf5-a271-384b-bf13-bd21d931c1bf\", \"Name\":\"DateTime\", \"Description\":null, \"SdsTypeCode\":16, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":null, \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null }, { \"Id\":\"State\", \"Name\":\"State\", \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":{ \"$id\":\"3\", \"Id\":\"ba5d20e1-cd21-3ad0-99f3-c3a3b0146aa1\", \"Name\":\"State\", \"Description\":null, \"SdsTypeCode\":609, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":[ { \"Id\":\"Ok\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":0 }, { \"Id\":\"Warning\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":1 }, { \"Id\":\"Alarm\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":2 } ], \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null }, { \"Id\":\"Measurement\", \"Name\":\"Measurement\", \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":{ \"$id\":\"4\", \"Id\":\"0f4f147f-4369-3388-8e4b-71e20c96f9ad\", \"Name\":\"Double\", \"Description\":null, \"SdsTypeCode\":14, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":null, \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null } ], \"BaseType\":null, \"DerivedTypes\":null } Step 5: Create a stream An SdsStream has an associated SdsType and stores a stream of events or objects that take the shape of that type. Detailed information about streams can be found in SdsStreams. Create an SdsStream of Simple events using the .NET SDS libraries as follows: SdsStream simpleStream = new SdsStream() { Id = \"Simple\", Name = \"Simple\", TypeId = simpleType.Id }; simpleStream = config.CreateStreamAsync(simpleStream); To create the stream without the libraries, post a JSON representation of the SdsStream to OSIsoft Cloud Services. POST /api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId} HTTP/1.1 Authorization: Bearer <bearer-token> Content-Length: 139 Content-Type: application/json Host: dat-a.osisoft.com { \"$id\":\"1\", \"Id\":\"Simple\", \"Name\":\"Simple\", \"Description\":null, \"TypeId\":\"Simple\", \"BehaviorId\":null, \"Indexes\":null } Step 6: Write data SDS supports many methods for adding and updating data. In this section, you will insert data. Inserts fail if events with the same index already exist in the database. Update adds new events and replaces existing events. To insert an event using the .NET SDS libraries: Simple value = new Simple() { Time = DateTime.UtcNow, State = State.Ok, Measurement = 123.45 }; await client.InsertValueAsync(simpleStream.Id, value); To POST a JSON serialized event to the OSIsoft Cloud Services: POST /api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ InsertValue HTTP/1.1 Authorization: Bearer <bearer-token> Content-Length: 57 Content-Type: application/json Host: dat-a.osisoft.com { \"Time\":\"2017-08-17T17:21:36.3494129Z\", \"State\":0, \"Measurement\":123.45 } Additional information about writing data can be found in Writing data . Step 7: Read data SDS includes many different read methods for retrieving data from streams. In this section, you will read the value that was recently written. Reads typically require an index or indexes. The index in the example is the Time property of Simple . Retrieving the distinct value just written requires index timestamp of that value. Most read calls also require one or more indexes to determine which data to read. The simplest way to supply an index is as a string. In .NET a DateTime index could be supplied as follows: string index = DateTime.Parse(\"2017-08-17T17:21:36.3494129Z\") .ToUniversalTime().ToString(\"o\"); To read a value at a distinct index, use the .NET SDS libraries: value = await client.GetDistinctValueAsync<Simple>(simpleStream.Id, index); To read using REST: GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/ Data/GetDistinctValue?index={index} HTTP/1.1 Authorization: Bearer <bearer-token> Content-Length: 0 Content-Type: Host: dat-a.osisoft.com Additional information about reading data can be found in Reading data . Handling transient service interruptions All applications that communicate with remote systems must manage transient faults. Temporary service interruptions are a fact of life in real-world cloud applications. If you access SDs using the SDS .NET libraries, transient fault handling is built in; the SDS client automatically retries error codes identified as transient. If you access the SDS API directly from the OSIsoft Cloud Services endpoint, you should consider creating your own retry logic to automatically retry when encountering errors identified as transient. For SDS, the only error you should retry is Http response code 503: service unavailable. An immediate first retry is recommended, followed by an exponential backoff. SDS client error If you access SDS using the .NET libraries, be aware that any non-success responses returned to the client are packaged in an SdsHttpClientException, which is an Exception with the following additional properties: string ReasonPhrase HttpStatusCode StatusCode Dictionary<string, object> Errors The StatusCode provides the HttpStatusCode from the response. The ReasonPhrase might provide additional information regarding the cause of the exception. You should always evaluate the ReasonPhrase in addition to the StatusCode to determine the cause of the exception. The Errors collection may provide additional specific error information based on the response. For example, if an InsertValues call failed because it conflicted with an existing event in the stream, the index of the conflicting event will be included in this dictionary. SDS Timeout Request Header Handling timeout issues can be difficult and confusing in a distributed programming environment. Often, when a client times out, the request is terminated before a response is received from the server, resulting in the application being unaware of the state of the server. One solution is to use the Request-Timeout header, which is recognized by many OSIsoft Cloud Services. Using the header, you can tell the server how long to spend on a particular request before timing out. If possible, the server terminates the request if the time it takes to process the request exceeds the timeout value set in the header. To specify the request timeout value, include the Request-Timeout header and specify the value in seconds."
  },
  "Documentation/SequentialDataStore/Reading_Data.html": {
    "href": "Documentation/SequentialDataStore/Reading_Data.html",
    "title": "Reading data",
    "keywords": "Reading data The .NET and REST APIs provide programmatic access to read and write data. This section identifies and describes the APIs used to read Stream data. Results are influenced by Types , Sds Views , Filter expressions , and Table format . If you are working in a .NET environment, convenient SDS Client libraries are available. The ISdsDataServiceinterface , which is accessed using the SdsService.GetDataService() helper, defines the functions that are available. The following methods for reading a single value are available: Get Value returns a value at a specified index, calculated if no stored value exists at that index. Get First Value returns the first value in the stream. Get Last Value returns the last value in the stream. Get Distinct Value returns a value at the specified index, only if a stored value exists at that index. Find Distinct Value searches for a value based on a starting index and search criteria. In addition, the following methods support reading multiple values: Get Values retrieves a collection of values at specified indexes, calculated if no stored value exists at the index(es). Get values supports specifying the desired indexes as a list of indexes, a filter expression and count, or a starting index, ending index, and count. Get Range Values retrieves a collection of stored values based on the specified start index and count. Get Window Values retrieves a collection of stored values based on specified start and end indexes. Get Intervals retrieves a collection of evenly spaced summary intervals based on a count and specified start and end indexes. All reads are HTTP GET actions. Reading data involves getting events from streams. The base reading URI is as follows: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data where: string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response Format Supported response formats include json, verbose json, and Sds. The default response format for is json, which is used in all examples in this document. Default json responses do not include any values that are equal to the default value for their type. Verbose json responses include all values, including defaults, in the returned json payload. To specify verbose json return, add the header Accept-Verbosity with a value of verbose to the request. To specify SDS format, set the Accept header in the request to application/Sds . Indexes and reading data Most read operations take at least one index as a parameter. Indexes may be specified as strings, or, when using the Sds Client libraries, the index may be passed as-is to read methods that take the index type as a generic argument. Additional details about working with indexes can be found on the Indexes page. Read Characteristics When data is requested at an index for which no stored event exists, the read characterisitics determine whether the result is an error, null event, interpolated event, or extrapolated event. The combination of the type of the index and the interpolation and extrapolation modes of the SdsType and the SdsStream determine the read characteristics. For more information on read characteristics, see Types and Streams . Methods affected by Read Characteristics GetValueAsync Read characteristics are applied when the index is between, before, or after all data. GetValuesAsync Read characteristics applied when an index determined by the call is between, before, or after all data. GetWindowValuesAsync Read characteristics applied to indexes between, before, or after data when the calls Boundary parameter is set to ExactOrCalculated. GetRangeValuesAsync Read characteristics applied to indexes between, before, or after data when the calls Boundary parameter is set to ExactOrCalculated. SdsView and reading data All reads support specifying a SdsView identifier in the query string to shape the results of the read: viewId={viewId} Working with views is covered in detail in the Sds Views section. When data is requested with a SdsView the read characteristics defined by the target type of the SdsView determine what is returned. The read characteristics are discussed in the Get Value , GetValues and GetWindowValues code samples. Filter Expressions Filter expressions can be applied to any read that returns multiple values, including Get Values, Get Range Values, Get Window Values, and Get Intervals. The filter expression is applied to the collection events conditionally filtering events that do not meet the filter conditions. Filter expressions are covered in detail in the Filter expressions section. Table Format Results of a query can be organized into tables by directing the form parameter to return a table. Two forms of table are available: table and header table. When the form parameter is specified as table, ?form=table , events are returned in row column form. Results include a collection named Columns that lists column name and type and a collection named Rows containing a collection of rows matching the order of the columns. Specifying a form of type table-headers , ?form=tableh , results in a collection where the Rows collection contains a column header list. Table formats are covered in detail in the Table format section. SdsBoundaryType SdsBoundaryType defines how data on the boundary of queries is handled: around the start index for range value queries, and around the start and end index for window values. The following are valid values for SdsBoundaryType: Boundary Enumeration value Operation Exact 0 Results include the event at the specified index boundary if a stored event exists at that index. Inside 1 Results include only events within the index boundaries Outside 2 Results include up to one event that falls immediately outside of the specified index boundary. ExactOrCalculated 3 Results include the event at the specified index boundary. If no stored event exists at that index, one is calculated based on the index type and interpolation and extrapolation settings. SdsSearchMode The SdsSearchMode enum defines search behavior when seeking a stored event near a specified index. The following are available SdsSearchModes: Mode Enumeration value Operation Exact 0 If a stored event exists at the specified index, that event is returned. Otherwise no event is returned. ExactOrNext 1 If a stored event exists at the specified index, that event is returned. Otherwise the next event in the stream is returned. Next 2 Returns the stored event after the specified index. ExactOrPrevious 3 If a stored event exists at the specified index, that event is returned. Otherwise the previous event in the stream is returned. Previous 4 Returns the stored event before the specified index. Unit conversion of data SDS supports assigning Units of Measure (Uom) to stream data. If stream data has Uom information associated, SDS supports reading data with unit conversions applied. On each read data request, unit conversions are specified by a user defined collection of SdsStreamPropertyOverride objects in read requests. The SdsStreamPropertyOverride object has the following structure: Property Type Optionality Details SdsTypePropertyId String Required Identifier for a SdsTypeProperty with a Uom assigned Uom String Required Target unit of measure InterpolationMode SdsInterpolationMode N/A Currently not supported in context of data reads This is supported in the .NET API via overloads that accept a collection of SdsStreamPropertyOverride objects, and in the REST API via HTTP POST calls with a request body containing a collection of SdsStreamPropertyOverride objects. See API calls for reading data for more information."
  },
  "Documentation/SequentialDataStore/Reading_Data_API.html": {
    "href": "Documentation/SequentialDataStore/Reading_Data_API.html",
    "title": "API calls for reading data",
    "keywords": "API calls for reading data Reading and writing data with the Sds Client Libraries is performed through the ISdsDataService interface, which can be accessed with the SdsService.GetDataService( ) helper. Sample Types Many of the API methods described below contain sample JSON and sample code. When specifying a parameter of type enum, the API accepts both the name of the field and the numeric value of the field. Samples vary to highlight enum flexibility. Samples use the following types: Type with a simple index, named Simple : .NET public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } [SdsMember(Uom = \"meter\")] public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } Has values as follows: 11/23/2017 12:00:00 PM: Ok 0 11/23/2017 1:00:00 PM: Ok 10 11/23/2017 2:00:00 PM: Ok 20 11/23/2017 3:00:00 PM: Ok 30 11/23/2017 4:00:00 PM: Ok 40 Type with Compound Index, named DerivedCompoundIndex .NET public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } public class DerivedCompoundIndex : Simple { [SdsMember(IsKey = true, Order = 1)] public DateTime Recorded { get; set; } } Python class Simple(object): # First-order Key property Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement class DerivedCompoundIndex(Simple): # Second-order Key property @property def Recorded(self): return self.__recorded @Recorded.setter def Recorded(self, recorded): self.__recorded = recorded JavaScript var Simple = function () { this.Time = null; this.State = null; this.Value = null; } var DerivedCompoundIndex = function() { Simple.call(this); this.Recorded = null; } Has values as follows: 1/20/2017 1:00:00 AM : 1/20/2017 12:00:00 AM 0 1/20/2017 1:00:00 AM : 1/20/2017 1:00:00 AM 2 1/20/2017 1:00:00 AM : 1/20/2017 2:00:00 PM 5 1/20/2017 2:00:00 AM : 1/20/2017 12:00:00 AM 1 1/20/2017 2:00:00 AM : 1/20/2017 1:00:00 AM 3 1/20/2017 2:00:00 AM : 1/20/2017 2:00:00 AM 4 1/20/2017 2:00:00 AM : 1/20/2017 2:00:00 PM 6 All times are represented at offset 0, GMT. Get Value Get Value supports two ways to retrieve an event: Standard : Returns the value at the specified index. If no stored event exists at the specified index, the stream’s read characteristics determines how the returned event is calculated. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValue ?index={index}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized event. Consider a stream of type Simple with the default InterpolationMode of Continuous and ExtrapolationMode of All. In the following request, the specified index matches an existing stored event: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetValue ?index=2017-11-23T13:00:00Z The response will contain the event stored at the specified index: Response body HTTP/1.1 200 Content-Type: application/json { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 } Note that State is not included in the JSON as its value is the default value. The following request specifies an index for which no stored event exists: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetValue ?index=2017-11-23T13:30:00Z Because the index is a valid type for interpolation and the stream type specifies a mode of interpolate, this request receives a response with an event interpolated at the specified index: Response body HTTP/1.1 200 Content-Type: application/json { \"Time\":\"2017-11-23T13:30:00Z\", \"Measurement\":15.0 } .NET Library Task<T> GetValueAsync<T>(string streamId, string index, string viewId = null); Task<T> GetValueAsync<T, T1>(string streamId, Tuple<T1> index, string viewId = null); Task<T> GetValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValue ?index={index}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized event similar to the standard request above (without Uom conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 } .NET Library Task<T> GetValueAsync<T>(string streamId, string index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<T> GetValueAsync<T, T1>(string streamId, Tuple<T1> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<T> GetValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get First Value Get First Value supports two ways to retrieve an event: Standard : Returns the first value in the stream. If no values exist in the stream, null is returned. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetFirstValue ?viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized event. .NET Library Task<T> GetFirstValueAsync<T>(string streamId, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetFirstValue ?viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and a response body containing a serialized event with unit conversions applied. .NET Library Task<T> GetFirstValueAsync<T>(string streamId, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get Last Value Get Last Value supports two ways to retrieve an event: Standard : Returns the last value in the stream. If no values exist in the stream, null is returned. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetLastValue ?viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized event. .NET Library Task<T> GetLastValueAsync<T>(string streamId, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetLastValue ?viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and a response body containing a serialized event with unit conversions applied. .NET Library Task<T> GetLastValueAsync<T>(string streamId, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get Distinct Value Get Distinct Value supports two ways to retrieve an event: Standard : Returns the value at the specified index. If no value exists at the specified index, Get Distinct Value returns HTTP Status Code Not Found, 404. The stream’s read characteristics do not affect Get Distinct Value. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetDistinctValue ?index={index}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized event. For a stream of type Simple, when making a Get Distinct Value request at an existing stored index: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetDistinctValue?index=2017-11-23T13:00:00Z The event at that index is returned in the response: Response body HTTP/1.1 200 Content-Type: application/json { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 } Note that State is not included in the JSON as its value is the default value. For a request at an index for which no stored event exists: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetDistinctValue?index=2017-11-23T13:30:00Z No distinct value is found at the specified index, and an error response is returned: Response body HTTP/1.1 404 Content-Type: application/json { \"Message\":\"Resource not found\" } .NET Library Task<T> GetDistinctValueAsync<T>(string streamId, string index, string viewId = null); Task<T> GetDistinctValueAsync<T, T1>(string streamId, Tuple<T1> index, string viewId = null); Task<T> GetDistinctValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetDistinctValue ?index={index}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized event similar to the standard request above (without Uom conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 } .NET Library Task<T> GetDistinctValueAsync<T>(string streamId, string index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<T> GetDistinctValueAsync<T, T1>(string streamId, Tuple<T1> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<T> GetDistinctValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Find Distinct Value Get Last Value supports two ways to retrieve an event: Standard : Returns a stored event found based on the specified SdsSearchMode and index. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/FindDistinctValue ?index={index}&mode={mode}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string mode The SdsSearchMode string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized event. For a stream of type Simple the following request, api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ FindDistinctValue?index=2017-11-23T13:00:00Z&mode=Next The request has an index that matches the index of an existing event, but because a SdsSearchMode of next was specified, the response contains the next event in the stream after the specified index: Response body HTTP/1.1 200 Content-Type: application/json Formatted JSON Data { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 } Note that State is not included in the JSON as its value is the default value. For the following request, api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ FindDistinctValue?index=2017-11-23T13:30:00Z&mode=Next The request specifies an index that does not match an index of an existing event. The next event in the stream is retrieved. Response body HTTP/1.1 200 Content-Type: application/json Formatted JSON Data { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 } .NET Library Task<T> FindDistinctValueAsync<T>(string streamId, string index, SdsSearchMode mode, string viewId = null); Task<T> FindDistinctValueAsync<T, T1>(string streamId, Tuple<T1> index, SdsSearchMode mode, string viewId = null); Task<T> FindDistinctValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, SdsSearchMode mode, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/FindDistinctValue ?index={index}&mode={mode}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string mode The SdsSearchMode string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized event similar to the standard request above (without Uom conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json Formatted JSON Data { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 } .NET Library Task<T> FindDistinctValueAsync<T>(string streamId, string index, IList<SdsStreamPropertyOverride> propertyOverrides, SdsSearchMode mode, string viewId = null); Task<T> FindDistinctValueAsync<T, T1>(string streamId, Tuple<T1> index, IList<SdsStreamPropertyOverride> propertyOverrides, SdsSearchMode mode, string viewId = null); Task<T> FindDistinctValueAsync<T, T1, T2>(string streamId, Tuple<T1, T2> index, IList<SdsStreamPropertyOverride> propertyOverrides, SdsSearchMode mode, string viewId = null); Get Values Returns a collection of values at indexes based on request parameters. As with the single event call to Get Value, the stream’s read characteristics determine how events are calculated for indexes at which no stored event exists. Get Values supports six ways of specifying which events to return. Ranged : A range can be specified with a start index, end index, and count. This will return the specified count of events evenly spaced from start index to end index. Index Collection : Multiple indexes can be passed to the request in order to retrieve events at exactly those indexes. Filtered : A filtered request accepts a filter expression that limits results by applying an expression against event fields. Filter expressions are explained in detail in the Filter expressions section. Ranged with Uom Conversion : Same as Ranged, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Index Collection with Uom Conversion : Same as Index Collection, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Filtered with Uom Conversion : Same as Filtered, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. Note that the filter is applied before any unit conversions. See Units of Measure for additional information Request (Ranged) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValues ?startIndex={startIndex}&endIndex={endIndex}&count={count}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The index defining the beginning of the range string endIndex The index defining the end of the range int count The number of events to return. Read characteristics of the stream determine how the form of the event. string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of events. For a stream of type Simple, the following request, api/Tenants/{tenantId}}/Namespaces/{namespaceId}/Streams/Simple/Data/GetValues ?startIndex=2017-11-23T13:00:00Z&endIndex=2017-11-23T15:00:00Z&count=3 For this request, the start and end fall exactly on event indexes and the number of events from start to end match the count of three (3). Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 } ] Note that State is not included in the JSON as its value is the default value. .NET Library Task<IEnumerable<T>> GetValuesAsync<T>(string streamId, string startIndex, string endIndex, int count, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1, T2>string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, string viewId = null); Request (Index collection) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValues ?index={index}[&index={index} …]&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index One or more indexes of values to retrieve string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of events. For a stream of type Simple, the following request, api/Tenants/{tenantId}}/Namespaces/{namespaceId}/Streams/Simple/Data/GetValues ?index=2017-11-23T12:30:00Z&index=2017-11-23T13:00:00Z&index=2017-11-23T14:00:00Z For this request, the response contains events for each of the three specified indexes. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T12:30:00Z\", \"Measurement\":5.0 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 } ] Note that State is not included in the JSON as its value is the default value. .NET Library Task<IEnumerable<T>> GetValuesAsync<T>(string streamId, IEnumerable<string> index, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1>(string streamId, IEnumerable<T1> index, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1, T2>(string streamId, IEnumerable<Tuple< T1, T2>> index, string viewId = null); Request (Filtered) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ GetValues?filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string filter The filter expression (see Filter expressions ) string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of events. For a stream of type Simple, the following request, api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetValues ?filter=Measurement gt 10 The events in the stream whose Measurement is less than or equal to 10 are not returned. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":40.0 } ] Note that State is not included in the JSON as its value is the default value. .NET Library Task<IEnumerable<T>> GetFilteredValuesAsync<T>(string streamId, string filter, string viewId = null); Request (Ranged with Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValues ?startIndex={startIndex}&endIndex={endIndex}&count={count}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The index defining the beginning of the range string endIndex The index defining the end of the range int count The number of events to return. Read characteristics of the stream determine how the form of the event. string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":3000.0 } ] .NET Library Task<IEnumerable<T>> GetValuesAsync<T>(string streamId, string startIndex, string endIndex, int count, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1, T2>string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Request (Index collection with Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValues ?index={index}[&index={index} …]&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index One or more indexes of values to retrieve string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T12:30:00Z\", \"Measurement\":500.0 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 } ] .NET Library Task<IEnumerable<T>> GetValuesAsync<T>(string streamId, IEnumerable<string> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1>(string streamId, IEnumerable<T1> index, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetValuesAsync<T, T1, T2>(string streamId, IEnumerable<Tuple< T1, T2>> index, string viewId = null); Request (Filtered with Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetValues ?filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string filter The filter expression (see Filter expressions ) string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Note that the filter expression is applied to values before unit conversion. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":3000.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":4000.0 } ] .NET Library Task<IEnumerable<T>> GetFilteredValuesAsync<T>(string streamId, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get Range Values Get Range Values supports two ways to retrieve events: Standard : Returns a collection of values as determined by a start index and count. Additional optional parameters specify the direction of the range, how to handle events near or at the start index, whether to skip a certain number of events at the start of the range, and how to filter the data. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetRangeValues ?startIndex={startIndex}&count={count}&skip={skip}&reversed={reversed} &boundaryType={boundaryType}&filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index identifying the beginning of the series of events to return int count The number of events to return int skip Optional value specifying the number of events to skip at the beginning of the result bool reversed Optional specification of the direction of the request. By default, range requests move forward from startIndex, collecting events after startIndex from the stream. A reversed request will collect events before startIndex from the stream. SdsBoundaryType boundaryType Optional SdsBoundaryType specifies the handling of events at or near startIndex string filter Optional filter expression string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of events. For a stream of type Simple, the following request will return a response with up to 100 events starting at 13:00 and extending forward toward the end of the stream: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetRangeValues?startIndex=2017-11-23T13:00:00Z&count=100 Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":40.0 } ] Note that State is not included in the JSON as its value is the default value. To reverse the direction of the request, set reversed to true. This request will return up to 100 events starting at 13:00 and extending back toward the start of the stream: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetRangeValues?startIndex=2017-11-23T13:00:00Z&count=100&reversed=true Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T12:00:00Z\" } ] Note that State is not included in the JSON as its value is the default value. Further, Measurement is not include in the second, 12:00:00, event as zero is the default value for numbers. The following request specifies a boundary type of Outside for a reversed-direction range request. The response will contain up to 100 events. The boundary type Outside indicates that up to one event outside the boundary will be included in the response. For a reverse direction range request, this means one event forward of the specified start index. In a default direction range request, it would mean one event before the specified start index. api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetRangeValues?startIndex=2017-11-23T13:00:00Z&count=100&reversed=true &boundaryType=2 Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T12:00:00Z\" } ] The event outside of the index is the next event or the event at 14:00 because the request operates in reverse. Note that State is not included in the JSON as its value is the default value. Further Measurement is not included in the last event as its value is default. Adding a filter to the request means only events that meet the filter criteria are returned: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetRangeValues?startIndex=2017-11-23T13:00:00Z&count=100&reversed=true &boundaryType=2&filter=Measurement gt 10 Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, ] .NET Library Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, bool reversed, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, bool reversed, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, bool reversed, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T>(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string viewId = null); Request (Unit Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetRangeValues ?startIndex={startIndex}&count={count}&skip={skip}&reversed={reversed} &boundaryType={boundaryType}&filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index identifying the beginning of the series of events to return int count The number of events to return int skip Optional value specifying the number of events to skip at the beginning of the result bool reversed Optional specification of the direction of the request. By default, range requests move forward from startIndex, collecting events after startIndex from the stream. A reversed request will collect events before startIndex from the stream. SdsBoundaryType boundaryType Optional SdsBoundaryType specifies the handling of events at or near startIndex string filter Optional filter expression string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":3000.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":4000.0 } ] .NET Library Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, bool reversed, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, bool reversed, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, bool reversed, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int count, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int count, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int count, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T>(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1>(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T>(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetRangeFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get Window Values Get Window Values supports two ways of retrieving events: Standard : Get Window Values returns a collection of stored events based on specified start and end indexes. For handling events at and near the boundaries of the window, a single SdsBoundaryType that applies to both the start and end indexes can be passed with the request, or separate boundary types may be passed for the start and end individually. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Get Window Values also supports paging for large result sets. Results for paged requests are returned as a SdsResultPage. Property Type Details Results IList Collection of events of type T ContinuationToken String The token used to retrieve the next page of data To retrieve the next page of values, include the ContinuationToken from the results of the previous request. For the first request, specify a null or empty string for the ContinuationToken. Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&endIndex={endIndex}&boundaryType={boundaryType} &filter={filter}&count={count}&viewId={viewId} GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&startBoundaryType={startBoundaryType} &endIndex={endIndex}&endBoundaryType={endBoundaryType}&filter={filter}&count={count} &viewId={viewId} GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&endIndex={endIndex}&boundaryType={boundaryType} &filter={filter}&count={count}&continuationToken={continuationToken}&viewId={viewId} GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&startBoundaryType={startBoundaryType} &endIndex={endIndex}&endBoundaryType={endBoundaryType}&filter={filter}&count={count} &continuationToken={continuationToken}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index bounding the beginning of the series of events to return string endIndex Index bounding the end of the series of events to return int count Optional maximum number of events to return SdsBoundaryType boundaryType Optional SdsBoundaryType specifies handling of events at or near the start and end indexes SdsBoundaryType startBoundaryType Optional SdsBoundaryType specifies the first value in the result in relation to the start index SdsBoundaryType endBoundaryType Optional SdsBoundaryType specifies the last value in the result in relation to the end index string filter Optional filter expression string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of events. For a stream of type Simple, the following requests all stored events between 13:30 and 15:30: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex=2017-11-23T12:30:00Z&endIndex=2017-11-23T15:30:00Z The response will contain the event stored at the specified index: Response body Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 } ] Note that State is not included in the JSON as its value is the default value. When the request is modified to specify a boundary type of Outside, the value before 13:30 and the value after 15:30 are included: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex=2017-11-23T12:30:00Z&endIndex=2017-11-23T15:30:00Z &boundaryType=2 Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T12:00:00Z\" }, { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":40.0 } ] Note that State is not included in the JSON as its value is the default value. Further, Measurement is not include in the second, 12:00:00, event as zero is the default value for numbers. If instead a start boundary of Inside, only values inside the start boundary (after 13:30) are included in the result. With an end boundary of Outside one value outside the end index (after 15:30) is included: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex=2017-11-23T12:30:00Z&&startBoundaryType=1 &endIndex=2017-11-23T15:30:00Z&endBoundaryType=2 Response body HTTP/1.1 200 Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"Measurement\":40.0 } ] Note that State is not included in the JSON as its value is the default value. In order to page the results of the request, a continuation token may be specified. This requests the first page of the first two stored events between start index and end index by indicating count is 2 and continuationToken is an empty string: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex=2017-11-23T12:30:00Z&endIndex=2017-11-23T15:30:00Z &count=2&continuationToken= Response body * HTTP/1.1 200 Content-Type: application/json { \"Results\":[ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":20.0 } ], \"ContinuationToken\":\"2017-11-23T14:00:00.0000000Z\" } Note that State is not included in the JSON as its value is the default value. This Get Window Values request uses the continuation token from the previous page to request the next page of stored events: api/Tenants/{tenantId}}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex=2017-11-23T12:30:00Z&endIndex=2017-11-23T15:30:00Z &count=2&continuationToken=2017-11-23T14:00:00Z Response body HTTP/1.1 200 Content-Type: application/json { \"Results\":[ { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":30.0 } ] } In this case, the results contain the final event. The returned continuation token is null (not shown because it null is the default value for a JSON string). Note that State is not included in the JSON as its value is the default value. .NET Library Task<IEnumerable<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, T uple<T1, T2> startIndex, Tuple<T1, T2> endIndex, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, string filter, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&endIndex={endIndex}&boundaryType={boundaryType} &filter={filter}&count={count}&viewId={viewId} POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&startBoundaryType={startBoundaryType} &endIndex={endIndex}&endBoundaryType={endBoundaryType}&filter={filter}&count={count} &viewId={viewId} POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&endIndex={endIndex}&boundaryType={boundaryType} &filter={filter}&count={count}&continuationToken={continuationToken}&viewId={viewId} POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetWindowValues ?startIndex={startIndex}&startBoundaryType={startBoundaryType} &endIndex={endIndex}&endBoundaryType={endBoundaryType}&filter={filter}&count={count} &continuationToken={continuationToken}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index bounding the beginning of the series of events to return string endIndex Index bounding the end of the series of events to return int count Optional maximum number of events to return SdsBoundaryType boundaryType Optional SdsBoundaryType specifies handling of events at or near the start and end indexes SdsBoundaryType startBoundaryType Optional SdsBoundaryType specifies the first value in the result in relation to the start index SdsBoundaryType endBoundaryType Optional SdsBoundaryType specifies the last value in the result in relation to the end index string filter Optional filter expression string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body Content-Type: application/json [ { \"Time\":\"2017-11-23T13:00:00Z\", \"Measurement\":1000.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"Measurement\":2000.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"Measurement\":3000.0 } ] .NET Library Task<IEnumerable<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, T uple<T1, T2> startIndex, Tuple<T1, T2> endIndex, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<IEnumerable<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, string filter, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T>(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1>(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Task<SdsResultPage<T>> GetWindowFilteredValuesAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, SdsBoundaryType startBoundaryType, Tuple<T1, T2> endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, IList<SdsStreamPropertyOverride> propertyOverrides, string viewId = null); Get Intervals Get Intervals supports two ways to retrieve events: Standard : Returns summary intervals between a specified start and end index. Uom Conversion : Same as Standard, but with unit conversion(s) applied to data when the SdsStream or SdsType contains unit of measure information. See Units of Measure for additional information Index types that cannot be interpolated do not support GetIntervals requests. Strings are an example of indexes that cannot be interpolated. The Get Intervals method does not support compound indexes. Interpolating between two indexes that consist of multiple properties is not defined and results in non-determinant behavior. Results are returned as a collection of SdsIntervals. Each SdsInterval has a start, end, and collection of summary values. Property Type Details Start T The start of the interval End T The end of the interval Summaries IDictionary<SdsSummaryType, The summary values for the interval, keyed by IDictionary<string, object> summary type. The nested dictionary contains Summaries property name keys and summary calculation result values. Summary values supported by SdsSummaryType enum: Summary Enumeration value Count 1 Minimum 2 Maximum 4 Range 8 Mean 16 StandardDeviation 64 Total 128 Skewness 256 Kurtosis 512 WeightedMean 1024 WeightedStandardDeviation 2048 WeightedPopulationStandardDeviatio 4096 Request (Standard) GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetIntervals ?startIndex={startIndex}&endIndex={endIndex}&count={count}&filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The start index for the intervals string endIndex The end index for the intervals int count The number of intervals requested string filter Optional filter expression string viewId Optional view identifier Response The response includes a status code and a response body containing a serialized collection of SdsIntervals. For a stream of type Simple, the following requests calculates two summary intervals between the first and last events: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetIntervals?startIndex=2017-11-23T12:00:00Z&endIndex=2017-11-23T16:00:00Z&count=2 Response body [{ \"Start\":{ \"Time\":\"2017-11-24T20:00:00Z\" }, \"End\":{ \"Time\":\"2017-11-24T22:00:00Z\", \"Measurement\":20.0 }, \"Summaries\":{ \"Count\":{ \"Measurement\":2 }, \"Minimum\":{ \"Measurement\":0.0 }, \"Maximum\":{ \"Measurement\":20.0 }, \"Range\":{ \"Measurement\":20.0 }, \"Total\":{ \"Measurement\":20.0 }, \"Mean\":{ \"Measurement\":10.0 }, \"StandardDeviation\":{ \"Measurement\":7.0710678118654755 }, \"PopulationStandardDeviation\":{ \"Measurement\":5.0 }, \"WeightedMean\":{ \"Measurement\":10.0 }, \"WeightedStandardDeviation\":{ \"Measurement\":7.0710678118654755 }, \"WeightedPopulationStandardDeviation\":{ \"Measurement\":5.0 }, \"Skewness\":{ \"Measurement\":0.0 }, \"Kurtosis\":{ \"Measurement\":-2.0 } } }, { \"Start\":{ \"Time\":\"2017-11-24T22:00:00Z\", \"Measurement\":20.0 }, \"End\":{ \"Time\":\"2017-11-25T00:00:00Z\", \"Measurement\":40.0 }, \"Summaries\":{ \"Count\":{ \"Measurement\":2 }, \"Minimum\":{ \"Measurement\":20.0 }, \"Maximum\":{ \"Measurement\":40.0 }, \"Range\":{ \"Measurement\":20.0 }, \"Total\":{ \"Measurement\":60.0 }, \"Mean\":{ \"Measurement\":30.0 }, \"StandardDeviation\":{ \"Measurement\":7.0710678118654755 }, \"PopulationStandardDeviation\":{ \"Measurement\":5.0 }, \"WeightedMean\":{ \"Measurement\":30.0 }, \"WeightedStandardDeviation\":{ \"Measurement\":7.0710678118654755 }, \"WeightedPopulationStandardDeviation\":{ \"Measurement\":5.0 }, \"Skewness\":{ \"Measurement\":0.0 }, \"Kurtosis\":{ \"Measurement\":-2.0 } } }] .NET Library Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T>(string streamId, string startIndex, string endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T>(string streamId, string startIndex, string endIndex, int count, string filter, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, string filter, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, string filter, string viewId = null); Request (Uom Conversion) POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/GetIntervals ?startIndex={startIndex}&endIndex={endIndex}&count={count}&filter={filter}&viewId={viewId} Request Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The start index for the intervals string endIndex The end index for the intervals int count The number of intervals requested string filter Optional filter expression string viewId Optional view identifier Request Body The Request Body contains a collection of SdsStreamPropertyOverride objects. The example request body below requests Sds convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] Response The response includes a status code and response body containing a serialized collection of events similar to the standard request above (without unit conversion). In this response, the system will have applied the conversion factor for the base unit (in this case Meters) to the Measurement property of the event. Response body [{ \"Start\":{ \"Time\":\"2017-11-24T20:00:00Z\" }, \"End\":{ \"Time\":\"2017-11-24T22:00:00Z\", \"Measurement\":2000.0 }, \"Summaries\":{ \"Count\":{ \"Measurement\":2 }, \"Minimum\":{ \"Measurement\":0.0 }, \"Maximum\":{ \"Measurement\":2000.0 }, \"Range\":{ \"Measurement\":2000.0 }, \"Total\":{ \"Measurement\":2000.0 }, \"Mean\":{ \"Measurement\":1000.0 }, \"StandardDeviation\":{ \"Measurement\":707.10678118654755 }, \"PopulationStandardDeviation\":{ \"Measurement\":500.0 }, \"WeightedMean\":{ \"Measurement\":1000.0 }, \"WeightedStandardDeviation\":{ \"Measurement\":707.10678118654755 }, \"WeightedPopulationStandardDeviation\":{ \"Measurement\":500.0 }, \"Skewness\":{ \"Measurement\":000.0 }, \"Kurtosis\":{ \"Measurement\":-200.0 } } }, { \"Start\":{ \"Time\":\"2017-11-24T22:00:00Z\", \"Measurement\":2000.0 }, \"End\":{ \"Time\":\"2017-11-25T00:00:00Z\", \"Measurement\":4000.0 }, \"Summaries\":{ \"Count\":{ \"Measurement\":2 }, \"Minimum\":{ \"Measurement\":2000.0 }, \"Maximum\":{ \"Measurement\":4000.0 }, \"Range\":{ \"Measurement\":2000.0 }, \"Total\":{ \"Measurement\":6000.0 }, \"Mean\":{ \"Measurement\":3000.0 }, \"StandardDeviation\":{ \"Measurement\":707.10678118654755 }, \"PopulationStandardDeviation\":{ \"Measurement\":500.0 }, \"WeightedMean\":{ \"Measurement\":3000.0 }, \"WeightedStandardDeviation\":{ \"Measurement\":707.10678118654755 }, \"WeightedPopulationStandardDeviation\":{ \"Measurement\":500.0 }, \"Skewness\":{ \"Measurement\":0.0 }, \"Kurtosis\":{ \"Measurement\":-200.0 } } }] .NET Library Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T>(string streamId, string startIndex, string endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetIntervalsAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T>(string streamId, string startIndex, string endIndex, int count, string filter, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T, T1>(string streamId, T1 startIndex, T1 endIndex, int count, string filter, string viewId = null); Task<IEnumerable<SdsInterval<T>>> GetFilteredIntervalsAsync<T, T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex, int count, string filter, string viewId = null);"
  },
  "Documentation/SequentialDataStore/SdsStreamExtra.html": {
    "href": "Documentation/SequentialDataStore/SdsStreamExtra.html",
    "title": "Stream Metadata and Tags",
    "keywords": "Stream Metadata and Tags SdsStream metadata is represented as a dictionary of string keys and associated string values. It can be used to associate additional information with a stream. SdsStream tags are represented as a list of strings. Tags can be used to categorize or denote special attributes of streams. SdsStream Metadata API Get stream metadata Returns the metadata dictionary for the specified stream. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The metadata for the specified SdsStream. Sample response body HTTP/1.1 200 Content-Type: application/json { \"a metadata key\":\"a metadata value\", \"another key\":\"another value\" } .NET Library Task<IDictionary<string, string>> GetStreamMetadataAsync(string streamId); Security Allowed for administrator and user accounts Get stream metadata value Returns the value for the specified key in the metadata dictionary of the specified stream. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Metadata/{key} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string key The key specifying the metadata value of interest Response The response includes a status code and a response body. Response body The metadata for the specified SdsStream. Sample response body HTTP/1.1 200 Content-Type: application/json { \"a metadata value” } .NET Library Task<string> GetStreamMetadataValueAsync(string streamId, string key); Security Allowed for administrator and user accounts Update stream metadata Replaces the metadata for the specified stream with the metadata in the request body. Overwrites any existing metadata; does not merge. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task UpdateStreamMetadataAsync(string streamId, IDictionary<string, string> metadata); Security Allowed for administrator accounts Delete stream metadata Deletes the metadata for the specified stream. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamMetadataAsync(string streamId); Security Allowed for administrator accounts SdsStream Tags API Get stream tags Returns the tag list for the specified stream. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The tags for the specified SdsStream. Sample response body HTTP/1.1 200 Content-Type: application/json [ \"a tag\", \"another tag\" ] .NET Library Task<IList<string>> GetStreamTagsAsync(string streamId); Security Allowed for administrator and user accounts Update stream tags Replaces the tag list for the specified stream with the tags listed in the request body. Overwrites any existing tags; does not merge. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized list of tags. Response The response includes a status code. .NET Library Task UpdateStreamTagsAsync(string streamId, IList<string> tags); Security Allowed by administrator accounts. Delete stream metadata Deletes the tag list for the specified stream. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamTagsAsync(string streamId); Security Allowed for administrator accounts."
  },
  "Documentation/SequentialDataStore/SDS_Streams.html": {
    "href": "Documentation/SequentialDataStore/SDS_Streams.html",
    "title": "Streams",
    "keywords": "Streams SDS stores collections of events and provides convenient ways to find and associating events. Events of consistent structure are stored in streams, called SdsStreams. An SdsType defines the structure of events in an SdsStream. SdsStreams are referenced by their identifier or Id field. SdsStream identifiers must be unique within a Namespace. An SdsStream must include a TypeId that references the identifier of an existing SdsType. When an SdsStream contains data, you must use a view to update the stream type. SdsStream management using the .NET SDS Client Libraries is performed through ISdsMetadataService. Create the ISdsMetadataService, using one of the SdsService.GetMetadataService() factory methods. The following table shows the required and optional SdsStream fields. Fields not listed are reserved for internal SDS use. Property Type Optionality Details Id String Required An identifier for referencing the stream TypeId String Required The SdsType identifier of the type to be used for this stream Name String Optional Friendly name Description String Optional Description text Indexes IList Optional Used to define secondary indexes for stream InterpolationMode SdsInterpolationMode Optional Interpolation setting of the stream. Default is null. ExtrapolationMode SdsExtrapolationMode Optional Extrapolation setting of the stream. Default is null. PropertyOverrides IList Optional Used to define unit of measure and interpolation mode overrides for a stream Rules for Identifier (SdsStream.Id) Is not case sensitive. Can contain spaces. Cannot start with two underscores (\"__\"). Can contain a maximum of 100 characters. Cannot use the following characters: ( / : ? # [ ] @ ! $ & ' ( ) \\* + , ; = %) Cannot start or end with a period. Cannot contain consecutive periods. Cannot consist of only periods. Indexes The Key or Primary Index is defined at the SdsType. Secondary Indexes are defined at the SdsStream. Secondary Indexes are applied to a single property; there are no compound secondary indexes. Only SdsTypeCodes that can be ordered are supported for use in a secondary index. Indexes are discussed in greater detail here: Indexes Interpolation and Extrapolation The InterpolationMode, ExtrapolationMode, and PropertyOverrides_ can be used to determine how a specific stream reads data. These read characteristics are inherited from the type if they are not defined at the stream level. For more information about type read characteristics and how these characteristics dictate how events are read see Types . PropertyOverrides PropertyOverrides provide a way to override interpolation behavior and unit of measure for individual SdsType Properties for a specific stream. The SdsStreamPropertyOverride object has the following structure: Property Type Optionality Details SdsTypePropertyId String Required SdsTypeProperty identifier InterpolationMode SdsInterpolationMode Optional Interpolation setting. Default is null Uom String Optional Unit of measure The unit of measure can be overridden for any type property defined by the stream type, including primary keys and secondary indexes. For more information about type property units of measure see Types . Read characteristics of the stream are determined by the type and the PropertyOverrides of the stream. The interpolation mode for non-index properties can be defined and overridden at the stream level. For more information about type read characteristics see Types . When specifying property interpolation overrides, if the SdsType InterpolationMode is Discrete , it cannot be overridden at any level. When InterpolationMode is set to Discrete and an event it not defined for that index, a null value is returned for the entire event. SdsStream API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsStreams. When working in .NET convenient SDS Client libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Streams for general SdsStream information. Get Stream Returns the specified stream. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response body The requested SdsStream. Sample response body: HTTP/1.1 200 Content-Type: application/json { \"Id\":\"Simple\" \"Name\":\"Simple\" \"TypeId\":\"Simple\", } .NET Library Task<SdsStream> GetStreamAsync(string streamId); Security Allowed by administrator accounts Get Streams Returns a list of streams. If specifying the optional search parameter or optional filter parameter, the list of streams returned are filtered to match the search/filter criteria. If neither parameter is specified, the list includes all streams in the Namespace. See Searching and Filter Expressions: Metadata Objects for information about specifying those respective parameters. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query={query}&filter={filter}&skip={skip}&count={count}&orderby={orderby} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string query An optional parameter representing a string search. See Searching for information about specifying the search parameter. string filter An optional filter string to match which SdsStreams will be returned. See the Filter Expressions: Metadata Objects topic for information about specifying the filter parameter. int skip An optional parameter representing the zero-based offset of the first SdsStream to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsStreams to retrieve. If not specified, a default value of 100 is used. string orderby An optional parameter representing sorted order which SdsStreams will be returned. A field name is required. The sorting is based on the stored values for the given field (of type string). For example, orderby=name would sort the returned results by the name values (ascending by default). Additionally, a value can be provided along with the field name to identify whether to sort ascending or descending, by using values asc or desc , respectively. For example, orderby=name desc would sort the returned results by the name values, descending. If no value is specified, there is no sorting of results. Response The response includes a status code and a response body. Response body A collection of zero or more SdsStreams. Sample response body: HTTP/1.1 200 Content-Type: application/json [ { \"Id\":\"Simple\", \"TypeId\":\"Simple\" }, { \"Id\":\"Simple with Secondary\", \"TypeId\":\"Simple\", \"Indexes\":[ { \"SdsTypePropertyId\":\"Measurement\" } ] }, { \"Id\":\"Compound\", \"TypeId\":\"Compound\" }, ... ] .NET Library Task<IEnumerable<SdsStream>> GetStreamsAsync(string query = \"\", int skip = 0, int count = 100); Security Allowed for administrator and user accounts Get Stream Type Returns the type definition that is associated with a given stream. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Type Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The requested SdsType. .NET Library Task<SdsType> GetStreamTypeAsync(string streamId); Security Allowed by administrator and user accounts Create Stream Creates the specified stream. If a stream with a matching identifier already exists, SDS compares the existing stream with the stream that was sent. If the streams are identical, a Found (302) error is returned with the Location header set to the URI where the stream may be retrieved using a Get function. If the streams do not match, a Conflict (409) error is returned. For a matching stream (Found), clients that are capable of performing a redirect that includes the authorization header can automatically redirect to retrieve the stream. However, most clients, including the .NET HttpClient, consider redirecting with the authorization token to be a security vulnerability. When a client performs a redirect and strips the authorization header, SDS cannot authorize the request and returns Unauthorized (401). For this reason, it is recommended that when using clients that do not redirect with the authorization header, you should disable automatic redirect. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier. The stream identifier must match the identifier in content. The request content is the serialized SdsStream. Response The response includes a status code and a response body. Response body The newly created SdsStream. .NET Library Task<SdsStream> GetOrCreateStreamAsync(SdsStream SdsStream); If a stream with a matching identifier already exists and it matches the stream in the request body, the client redirects a GET to the Location header. If the existing stream does not match the stream in the request body, a Conflict error response is returned and the client library method throws an exception. Security Allowed for administrator accounts Create or Update Stream Creates the specified stream. If a stream with the same Id already exists, the definition of the stream is updated. The following changes are permitted: • Name • Description • PropertyOverrides Unpermitted changes result in an error. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId} Parameters string tenantId The tenant identifier of the tenant where you want to update the stream string namespaceId The namespace identifier of the namespace where you want to update the stream string streamId The stream identifier to be updated The request content is the serialized SdsStream. Response The response includes a status code. .NET Library Task CreateOrUpdateStreamAsync(SdsStream SdsStream); Security Allowed for administrator accounts Update Stream Type Updates a stream’s type. The type is modified to match the specified view. Defined Indexes and PropertyOverrides are removed when updating a stream type. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Type?viewId={viewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string viewId The view identifier The request contains no content. Response The response includes a status code. Response body On failure, the content contains a message describing the issue. .NET Library Task UpdateStreamTypeAsync(string streamId, string viewId); Security Allowed for administrator accounts Delete Stream Deletes a stream. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamAsync(string streamId); Security Allowed for administrator accounts"
  },
  "Documentation/SequentialDataStore/SDS_Types.html": {
    "href": "Documentation/SequentialDataStore/SDS_Types.html",
    "title": "Types",
    "keywords": "Types The Sequential Data Store (SDS) stores streams of events and provides convenient ways to find and associate events. Events are stored in streams, called SdsStreams. An SdsType defines the shape or structure of the event and how to associate events within the SdsStream. SdsTypes can define simple atomic types, such as integers, floats, strings, arrays, and dictionaries, or they can define complex types using SdsTypes. You can define complex, nested types using the Properties collection of an SdsType. An SdsType used to define an SdsStream must have a Key. A Key is a Property, or a combination of Properties that constitute an ordered, unique identity. The Key is ordered, so it functions as an index; it is known as the Primary Index. While a timestamp (DateTime) is a very common type of Key, any type that can be ordered is permitted. Other indexes (secondary indexes), are defined in the SdsStream. Indexes are discussed in greater detail here: Indexes When defining a type, consider how the events will be represented in a stream. The SdsType defines each event in the stream. An event is a single unit whose properties have values that relate to the index; that is, each property of an SdsType event is related to the event’s index. Each event is a single unit. An SdsType is referenced by its identifier or Id field. SdsType identifiers must be unique within a Namespace. SdsTypes define how events are associated and read within a collection of events, or SdsStream. The read characteristics when attempting to read non-existent indexes, indexes that fall between, before or after existing indexes, are determined by the interpolation and extrapolation settings of the SdsType. For more information about read characteristics see Interpolation_ and Extrapolation_. SdsTypes are mostly immutable. When an SdsType is referenced by a stream or a view, its form cannot be changed. Certain fields, such as the friendly name or description, can be changed because they do not affect the function of the SdsType. In addition, the SdsType may be deleted only if no streams or views reference it. Only SdsTypes used to define SdsStreams or SdsViews are required to be added to the Sequential data store. SdsTypes that define Properties or base types are contained within the parent SdsType and are not required to be added to the Data Store independently. The following table shows the required and optional SdsType fields. Fields that are not included are reserved for internal SDS use. Property Type Optionality Details Id String Required Identifier for referencing the type Name String Optional Friendly name Description String Optional Description text SdsTypeCode SdsTypeCode Required Numeric code identifying the base SdsType InterpolationMode SdsInterpolationMode Optional Interpolation setting of the type. Default is Continuous. ExtrapolationMode SdsExtrapolationMode Optional Extrapolation setting of the type. Default is All. Properties IList Required List of SdsTypeProperty items Rules for typeId Is not case sensitive Can contain spaces Cannot begin with two underscores (\"__\") Cannot contain forward slash or backslash characters (\"/\" or \"\\\") Can contain a maximum of 100 characters Cannot start or end with a period. Cannot contain consecutive periods. Cannot consist of only periods. SdsType management using the .NET SDS Client Libraries is performed through the ISdsMetadataService . You can create the ISdsMetadataService using one of the SdsService.GetMetadataService() factory methods. The .NET libraries provide SdsTypeBuilder to help build SdsTypes from .NET types. SdsTypeBuilder is discussed in greater detail below. SdsTypeCode The SdsTypeCode is a numeric identifier used by the Data Store to identify SdsTypes. A SdsTypeCode exists for every supported type. Atomic types, such as strings, floats and arrays, are defined entirely by the SdsTypeCode. Atomic types do not need fields to define the type. Types requiring additional definition, such as enums and objects, are identified using a generic SdsTypeCode, such as ByteEnum, Int32Enum, NullableInt32Enum, or Object, plus additional SdsProperty fields. Supported Types The following types are supported and defined by the SdsTypeCode: Type SdsTypeCode Array 400 Boolean 3 BooleanArray 203 Byte 6 ByteArray 206 ByteEnum 606 Char 4 CharArray 204 DateTime 16 DateTimeArray 216 DateTimeOffset 20 DateTimeOffsetArray 220 DBNull 2 Decimal 15 DecimalArray 215 Double 14 DoubleArray 214 Empty 0 Guid 19 GuidArray 219 IDictionary 402 IEnumerable 403 IList 401 Int16 7 Int16Array 207 Int16Enum 607 Int32 9 Int32Array 209 Int32Enum 609 Int64 11 Int64Array 211 Int64Enum 611 NullableBoolean 103 NullableByte 106 NullableByteEnum 706 NullableChar 104 NullableDateTime 116 NullableDateTimeOffset 120 NullableDecimal 115 NullableDouble 114 NullableGuid 119 NullableInt16 107 NullableInt16Enum 707 NullableInt32 109 NullableInt32Enum 709 NullableInt64 111 NullableInt64Enum 711 NullableSByte 105 NullableSByteEnum 705 NullableSingle 113 NullableTimeSpan 121 NullableUInt16 108 NullableUInt16Enum 708 NullableUInt32 110 NullableUInt32Enum 710 NullableUInt64 112 NullableUInt64Enum 712 Object 1 SdsColumn 510 SdsObject 512 SdsStream 507 SdsStreamIndex 508 SdsTable 509 SdsType 501 SdsTypeProperty 502 SdsValues 511 SdsView 503 SdsViewMap 505 SdsViewMapProperty 506 SdsViewProperty 504 SByte 5 SByteArray 205 SByteEnum 605 Single 13 SingleArray 213 String 18 StringArray 218 TimeSpan 21 TimeSpanArray 221 UInt16 8 UInt16Array 208 UInt16Enum 608 UInt32 10 UInt32Array 210 UInt32Enum 610 UInt64 12 UInt64Array 212 UInt64Enum 612 Version 22 VersionArray 222 Interpolation Interpolation determines how a stream behaves when asked to return an event at an index between two existing events. InterpolationMode determines how the returned event is constructed. The table below lists InterpolationModes: Mode Enumeration value Operation Default 0 The default InterpolationMode is Continuous Continuous 0 Interpolates the data using previous and next index values StepwiseContinuousLeading 1 Returns the data from the previous index StepwiseContinuousTrailing 2 Returns the data from the next index Discrete 3 Returns ‘null’ Note that Continuous cannot return events for values that cannot be interpolated, such as when the type is not numeric. The table below describes how the Continuous InterpolationMode affects indexes that occur between data in a stream: InterpolationMode = Continuous or Default Type Result for an index between data in a stream Comment Numeric Types Interpolated* Rounding is done as needed for integer types Time related Types Interpolated DateTime, DateTimeOffset, TimeSpan Nullable Types Returns ‘null’ Cannot reliably interpolate due to possibility of a null value Array and List Types Returns ‘null’ String Type Returns ‘null’ Boolean Type Returns value of nearest index Enumeration Types Returns Enum value at 0 This may have a value for the enumeration GUID Version Returns ‘null’ IDictionary or IEnumerable Returns ‘null’ Dictionary, Array, List, and so on. *When extreme values are involved in an interpolation (for example Decimal.MaxValue) the call might result in a BadRequest exception. If the InterpolationMode is not assigned, the events are interpolated in the default manner, unless the interpolation mode is overridden in the TypeProperty or the SdsStream. For more information on overriding the interpolation mode on a specific type property see SdsTypeProperty_. For more information on overriding the interpolation mode for a specific stream see Sds Streams . Extrapolation Extrapolation defines how a stream responds to requests with indexes that precede or follow all data in the steam. ExtrapolationMode acts as a master switch to determine whether extrapolation occurs and at which end of the data. ExtrapolationMode works with the InterpolationMode to determine how a stream responds. The following tables show how ExtrapolationMode affects returned values for each InterpolationMode value: ExtrapolationMode with Mode\\ =Default or Continuous ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns first data value Returns last data value None 1 Returns ‘null’ Returns ‘null’ Forward 2 Returns ‘null’ Returns last data value Backward 3 Returns first data value Returns ‘null’ ExtrapolationMode with InterpolationMode\\ =Discrete ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns ‘null’ Returns ‘null’ None 1 Returns ‘null’ Returns ‘null’ Forward 2 Returns ‘null’ Returns ‘null’ Backward 3 Returns ‘null’ Returns ‘null’ ExtrapolationMode with InterpolationMode\\ =StepwiseContinuousLeading ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns first data value Returns last data value None 1 Returns ‘null’ Returns ‘null’ Forward 2 Returns ‘null’ Returns last data value Backward 3 Returns first data value Returns ‘null’ ExtrapolationMode with InterpolationMode\\ =StepwiseContinuousTrailing ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns first data value Returns last data value None 1 Returns ‘null’ Returns ‘null’ Forward 2 Returns ‘null’ Returns last data value Backward 3 Returns first data value Returns ‘null’ If the ExtrapolationMode is not assigned, the events are extrapolated in the default manner, unless the extrapolation mode is overridden on the SdsStream. For more information on overriding the extrapolation mode on a specific stream see Sds Streams . For additional information about the effect of read characteristics, see the documentation on the read method you are using. SdsTypeProperty The Properties collection define the fields in an SdsType. The following table shows the required and optional SdsTypeProperty fields. Fields that are not included are reserved for internal SDS use. Property Type Optionality Details Id String Required Identifier for referencing the type Name String Optional Friendly name Description String Optional Description text SdsType SdsType Required Field defining the property's Type IsKey Boolean Required Identifies the property as the Key (Primary Index) Value Object Optional Value of the property Order Int Optional Order of comparison within a compound index InterpolationMode SdsInterpolationMode Optional Interpolation setting of the property. Default is null. Uom String Optional Unit of Measure of the property The SdsTypeProperty’s identifier follows the same rules as the SdsType’s identifier. IsKey is a Boolean value used to identify the SdsType’s Key. A Key defined by more than one Property is called a compound key. The maximum number of Properties that can define a compound key is three. In a compound key, each Property that is included in the Key is specified as IsKey. The Order field defines the precedence of fields applied to the Index. The Value field is used for properties that represent a value. An example of a property with a value is an enum’s named constant. When representing an enum in a SdsType, the SdsType’s Properies collection defines the enum’s constant list. The SdsTypeProperty’s Identifier represents the constant’s name and the SdsTypeProperty’s Value represents the constant’s value (see the enum State definitions below). InterpolationMode is assigned when the Property of the event should be interpolated in a specific way that differs from the InterpolationMode of the SdsType. InterpolationMode is only applied to a Property that is not part of the Index. If the InterpolationMode is not set, the Property is are interpolated in the manner defined by the SdsType’s IntepolationMode. An SdsType with the InterpolationMode set to Discrete cannot have a Property with an InteroplationMode. For more information on interpolation of events see Interpolation_. Uom is the unit of measure for the Property. The Uom of a Property may be specified by the name or the abbreviation. The names and abbreviations of Uoms are case sensitive. The InterpolationMode and Uom of a Property can be overriden on the stream. For more information, see Sds Streams . Supported Units of Measure For a list of units of measures that are supported for an SdsTypeProperty, see Units of Measure . Working with SdsTypes using .NET When working in .NET, use the SdsTypeBuilder to create SdsTypes. The SdsTypeBuilder eliminates potential errors that can occur when working with SdsTypes manually. There are several ways to work with the builder. The most convenient is to use the static methods, as shown here: public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType<Simple>(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; simpleType.Description = \"Basic sample type\"; SdsTypeBuilder recognizes the System.ComponentModel.DataAnnotations.KeyAttribute and its own OSIsoft.Sds.SdsMemberAttribute . When using the SdsMemberAttribute to specify the Primary Index, set the IsKey to true. The type is created with the following parameters. SdsTypeBuilder automatically generates unique identifiers. Note that the following table contains only a partial list of fields. Field Values Id Simple Name Simple Description Basic sample type Properties Count = 3 [0] Id Time Name Time Description null Order 0 IsKey true SdsType Id c48bfdf5-a271-384b-bf13-bd21d931c1bf Name DateTime Description null Properties null Value null [1] Id State Name State Description null Order 0 IsKey false SdsType Id 02728a4f-4a2d-3588-b669-e08f19c35fe5 Name State Description null Properties Count = 3 [0] Id Name Description Order SdsType Value [1] Id Name Description Order SdsType Value [2] Id Name Description Order SdsType Value Value null [2] Id Measurement Name Measurement Description null Order 0 IsKey false SdsType Id 0f4f147f-4369-3388-8e4b-71e20c96f9ad Name Double Description null Properties null Value null The SdsTypeBuilder also supports derived types. Note that you need not add the base types to the Data Store before using SdsTypeBuilder. Base types are maintained within the SdsType. Working with SdsTypes when not using .NET SdsTypes must be built manually when .NET SdsTypeBuilder is unavailable. The following discussion refers to the following types and are defined in Python <https://github.com/osisoft/Qi-Samples/tree/master/Basic/Python> and JavaScript <https://github.com/osisoft/Sds-Samples/tree/master/Basic/JavaScript> samples. Samples in other languages can be found here: Samples <https://github.com/osisoft/Qi-Samples/tree/master/Basic> __. In the sample code, SdsType , SdsTypeProperty , and SdsTypeCode are defined as in the code snippets shown here: Python class SdsTypeCode(Enum): Empty = 0 Object = 1 DBNull = 2 Boolean = 3 Char = 4 ... class SdsTypeProperty(object): \"\"\"SDS type property definition\"\"\" def __init__(self): self.__isKey = False @property def Id(self): return self.__id @Id.setter def Id(self, id): self.__id = id ... @property def IsKey(self): return self.__isKey @IsKey.setter def IsKey(self, iskey): self.__isKey = iskey @property def SdsType(self): return self.__SdsType @SdsType.setter def SdsType(self, SdsType): self.__SdsType=SdsType ... class SdsType(object): \"\"\"SDS type definitions\"\"\" def __init__(self): self.SdsTypeCode = SdsTypeCode.Object @property def Id(self): return self.__id @Id.setter def Id(self, id): self.__id = id ... @property def BaseType(self): return self.__baseType @BaseType.setter def BaseType(self, baseType): self.__baseType = baseType @property def SdsTypeCode(self): return self.__typeCode @SdsTypeCode.setter def SdsTypeCode(self, typeCode): self.__typeCode = typeCode @property def Properties(self): return self.__properties @Properties.setter def Properties(self, properties): self.__properties = properties JavaScript SdsTypeCodeMap: { Empty: 0, \"Object\": 1, DBNull: 2, \"Boolean\": 3, Char: 4, ... SdsTypeProperty: function (SdsTypeProperty) { if (SdsTypeProperty.Id) { this.Id = SdsTypeProperty.Id; } if (SdsTypeProperty.Name) { this.Name = SdsTypeProperty.Name; } if (SdsTypeProperty.Description) { this.Description = SdsTypeProperty.Description; } if (SdsTypeProperty.SdsType) { this.SdsType = SdsTypeProperty.SdsType; } if (SdsTypeProperty.IsKey) { this.IsKey = SdsTypeProperty.IsKey; } }, SdsType: function (SdsType) { if (SdsType.Id) { this.Id = SdsType.Id } if (SdsType.Name) { this.Name = SdsType.Name; } if (SdsType.Description) { this.Description = SdsType.Description; } if (SdsType.SdsTypeCode) { this.SdsTypeCode = SdsType.SdsTypeCode; } if (SdsType.Properties) { this.Properties = SdsType.Properties; } }, Working with the following types (both Python and JavaScript classes are shown): Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getMeasurement, setMeasurement) def getMeasurement(self): return self.__measurement def setMeasurement(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Aalrm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Measurement = null; } Define the SdsType as follows: Python # Create the properties # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime # State is not a pre-defined type. A SdsType must be defined to represent the enum stateTypePropertyOk = SdsTypeProperty() stateTypePropertyOk.Id = \"Ok\" stateTypePropertyOk.Value = State.Ok stateTypePropertyWarning = SdsTypeProperty() stateTypePropertyWarning.Id = \"Warning\" stateTypePropertyWarning.Value = State.Warning stateTypePropertyAlarm = SdsTypeProperty() stateTypePropertyAlarm.Id = \"Alarm\" stateTypePropertyAlarm.Value = State.Alarm stateType = SdsType() stateType.Id = \"State\" stateType.Name = \"State\" stateType.Properties = [ stateTypePropertyOk, stateTypePropertyWarning, \\ stateTypePropertyAlarm ] state = SdsTypeProperty() state.Id = \"State\" state.Name = \"State\" state.SdsType = stateType # Value property is a simple non-indexed, pre-defined type value = SdsTypeProperty() value.Id = \"Measurement\" value.Name = \"Measurement\" value.SdsType = SdsType() value.SdsType.Id = \"Double\" value.SdsType.Name = \"Double\" # Create the Simple SdsType simpleType = SdsType() simpleType.Id = \"Simple\" simpleType.Name = \"Simple\" simpleType.Description = \"Basic sample type\" simpleType.SdsTypeCode = SdsTypeCode.Object simpleType.Properties = [ time ] JavaScript // Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); // State is not a pre-defined type. An SdsType must be defined to represent the enum var stateTypePropertyOk = new SdsObjects.SdsTypeProperty({ \"Id\": \"Ok\", \"Value\": State.Ok }); var stateTypePropertyWarning = new SdsObjects.SdsTypeProperty({ \"Id\": \"Warning\", \"Value\": State.Warning }); var stateTypePropertyAlarm = new SdsObjects.SdsTypeProperty({ \"Id\": \"Alarm\", \"Value\": State.Alarm }); var stateType = new SdsObjects.SdsType({ \"Id\": \"State\", \"Name\": \"State\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Int32Enum, \"Properties\": [stateTypePropertyOk, stateTypePropertyWarning, stateTypePropertyAlarm, stateTypePropertyRed] }); // Measurement property is a simple non-indexed, pre-defined type var measurementProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"doubleType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Double }) }); // Create the Simple SdsType var simpleType = new SdsObjects.SdsType({ \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": \"This is a simple SDS type \", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [timeProperty, stateProperty, measurementProperty] }); Working with a derived class is easy. For the following derived class: class Derrived(Simple): @property def Observation(self): return self.__observation @Observation.setter def Observation(self, observation): self.__observation = observation Extend the SdsType as follows: Python # Observation property is a simple non-inexed, standard data type observation = SdsTypeProperty() observation.Id = \"Observation\" observation.Name = \"Observation\" observation.SdsType = SdsType() observation.SdsType.Id = \"String\" observation.SdsType.Name = \"String\" observation.SdsType.SdsTypeCode = SdsTypeCode.String # Create the Derived SdsType derived = SdsType() derived.Id = \"Derived\" derived.Name = \"Derived\" derived.Description = \"Derived sample type\" derived.BaseType = simpleType # Set the base type to the derived type derived.SdsTypeCode = SdsTypeCode.Object derived.Properties = [ observation ] JavaScript var observationProprety = new SdsObjects.SdsTypeProperty({ \"Id\": \"Observation\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"strType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.String }) }); var derivedType = new SdsObjects.SdsType({ \"Id\": \"Derived\", \"Name\": \"Derived\", \"Description\": \" Derived sample type\", \"BaseType\": simpleType, \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [ observationProprety ] }); SdsType API The REST APIs provide programmatic access to read and write Sds data. The APIs in this section interact with SdsTypes. When working in .NET convenient Sds Client libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Types_ for general SdsType information. Get Type Returns the type corresponding to the specified typeId within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response body The requested SdsType Sample response body: HTTP/1.1 200 Content-Type: application/json { \"Id\":\"f1a7ef61-d47f-3007-a260-449643a7c219\", \"Name\":\"Simple\", \"SdsTypeCode\":1, \"Properties\":[ { \"Id\":\"Time\", \"Name\":\"Time\", \"IsKey\":true, \"SdsType\":{ \"$id\":\"567\", \"Id\":\"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\":\"DateTime\", \"SdsTypeCode\":16 } }, { \"Id\":\"State\", \"Name\":\"State\", \"SdsType\":{ \"$id\":\"569\", \"Id\":\"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\":\"State\", \"SdsTypeCode\":609, \"Properties\":[ { \"$id\":\"570\", \"Id\":\"Ok\", \"Value\":0 }, { \"$id\":\"571\", \"Id\":\"Warning\", \"Value\":1 }, { \"$id\":\"572\", \"Id\":\"Aalrm\", \"Value\":2 } ] } }, { \"$id\":\"573\", \"Id\":\"Measurement\", \"Name\":\"Measurement\", \"SdsType\":{ \"$id\":\"574\", \"Id\":\"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\":\"Double\", \"SdsTypeCode\":14 } } ] } .NET Library Task<SdsType> GetTypeAsync(string typeId); Security Allowed by administrator and user accounts Get Types Returns a list of types within a given namespace. If specifying the optional search parameter or optional filter parameter, the list of types returned are filtered to match the search/filter criteria. If neither parameter is specified, the list includes all types in the Namespace. See Searching and Filter Expressions: Metadata Objects for information about specifying those respective parameters. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types?query={query}&filter={filter}&skip={skip}&count={count}&orderby={orderby} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string query An optional query string to match which SdsTypes will be returned. See the Searching topic for information about specifying the query parameter. string filter An optional filter string to match which SdsTypes will be returned. See the Filter Expressions: Metadata Objects topic for information about specifying the filter parameter. int skip An optional value representing the zero-based offset of the first SdsType to retrieve. If not specified, a default value of 0 is used. int count An optional value representing the maximum number of SdsTypes to retrieve. If not specified, a default value of 100 is used. string orderby An optional parameter representing sorted order which SdsTypes will be returned. A field name is required. The sorting is based on the stored values for the given field (of type string). For example, orderby=name would sort the returned results by the name values (ascending by default). Additionally, a value can be provided along with the field name to identify whether to sort ascending or descending, by using values asc or desc , respectively. For example, orderby=name desc would sort the returned results by the name values, descending. If no value is specified, there is no sorting of results. Response The response includes a status code and a response body. Response body A collection of zero or more SdsTypes. Sample response body: HTTP/1.1 200 Content-Type: application/json [ { \"Id\":\"f1a7ef61-d47f-3007-a260-449643a7c219\", \"Name\":\"Simple\", \"SdsTypeCode\":1, \"Properties\":[ { \"Id\":\"Time\", \"Name\":\"Time\", \"IsKey\":true, \"SdsType\":{ \"Id\":\"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\":\"DateTime\", \"SdsTypeCode\":16 } }, { \"Id\":\"State\", \"Name\":\"State\", \"SdsType\":{ \"Id\":\"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\":\"State\", \"SdsTypeCode\":609, \"Properties\":[ { \"Id\":\"Ok\", \"Value\":0 }, { \"Id\":\"Warning\", \"Value\":1 }, { \"Id\":\"Aalrm\", \"Value\":2 } ] } }, { \"Id\":\"Measurement\", \"Name\":\"Measurement\", \"SdsType\":{ \"$id\":\"574\", \"Id\":\"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\":\"Double\", \"SdsTypeCode\":14 } } ] }, … ] .NET Library Task<IEnumerable<SdsType>> GetTypesAsync(string query = \"\", int skip = 0, int count = 100); Security Allowed by administrator and user accounts Create Type Creates the specified type. If a type with a matching identifier already exists, The Data Store compares the existing type with the type that was sent. If the types are identical, a Found (302) error is returned with the Location header set to the URI where the type may be retrieved using a Get function. If the types do not match, a Conflict (409) error is returned. For a matching type ( Found ), clients that are capable of performing a redirect that includes the authorization header can automatically redirect to retrieve the type. However, most clients, including the .NET HttpClient, consider redirecting with the authorization token to be a security vulnerability. When a client performs a redirect and strips the authorization header, SDS cannot authorize the request and returns Unauthorized (401). For this reason, it is recommended that when using clients that do not redirect with the authorization header, you should disable automatic redirect and perform the redirect manually. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier. The identifier must match the SdsType.Id field. Response The response includes a status code and a response body. Response body The request content is the serialized SdsType. If you are not using the SDS client libraries, it is recommended that you use JSON. Sample SdsType content: { \"Id\":\"Simple\", \"Name\":\"Simple\", \"Description\":\"Basic sample type\", \"SdsTypeCode\":1, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":[ { \"Id\":\"Time\", \"Name\":\"Time\", \"Description\":null, \"Order\":0, \"IsKey\":true, \"FixedSize\":0, \"SdsType\":{ \"Id\":\"c48bfdf5-a271-384b-bf13-bd21d931c1bf\", \"Name\":\"DateTime\", \"Description\":null, \"SdsTypeCode\":16, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":null, \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null }, { \"Id\":\"State\", \"Name\":\"State\", \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":{ \"Id\":\"ba5d20e1-cd21-3ad0-99f3-c3a3b0146aa1\", \"Name\":\"State\", \"Description\":null, \"SdsTypeCode\":609, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":[ { \"Id\":\"Ok\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":0 }, { \"Id\":\"Warning\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":1 }, { \"Id\":\"Alarm\", \"Name\":null, \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":null, \"Value\":2 } ], \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null }, { \"Id\":\"Measurement\", \"Name\":\"Measurement\", \"Description\":null, \"Order\":0, \"IsKey\":false, \"FixedSize\":0, \"SdsType\":{ \"Id\":\"0f4f147f-4369-3388-8e4b-71e20c96f9ad\", \"Name\":\"Double\", \"Description\":null, \"SdsTypeCode\":14, \"IsGenericType\":false, \"IsReferenceType\":false, \"GenericArguments\":null, \"Properties\":null, \"BaseType\":null, \"DerivedTypes\":null }, \"Value\":null } ], \"BaseType\":null, \"DerivedTypes\":null } Response The response includes a status code and a response body. Response body HTTP/1.1 200 Content-Type: application/json { \"Id\":\"Simple\", \"Name\":\"Simple\", \"Description\":\"Basic sample type\", \"SdsTypeCode\":1, \"Properties\":[ { \"Id\":\"Time\", \"Name\":\"Time\", \"IsKey\":true, \"SdsType\":{ \"$id\":\"596\", \"Id\":\"c48bfdf5-a271-384b-bf13-bd21d931c1bf\", \"Name\":\"DateTime\", \"SdsTypeCode\":16 } }, { \"Id\":\"State\", \"Name\":\"State\", \"SdsType\":{ \"$id\":\"598\", \"Id\":\"ba5d20e1-cd21-3ad0-99f3-c3a3b0146aa1\", \"Name\":\"State\", \"SdsTypeCode\":609, \"Properties\":[ { \"Id\":\"Ok\", \"Value\":0 }, { \"Id\":\"Warning\", \"Value\":1 }, { \"Id\":\"Alarm\", \"Value\":2 } ] } }, { \"Id\":\"Measurement\", \"Name\":\"Measurement\", \"SdsType\":{ \"Id\":\"0f4f147f-4369-3388-8e4b-71e20c96f9ad\", \"Name\":\"Double\", \"SdsTypeCode\":14 } } ] } .NET Library Task<SdsType> GetOrCreateTypeAsync(SdsType SdsType); If a type with a matching identifier already exists and it matches the type in the request body, the client redirects a GET to the Location header. If the existing type does not match the type in the request body, a Conflict error response is returned and the client library method throws an exception. The SDS .NET Libraries manage redirects. Security Allowed by administrator accounts Create or Update Type Creates the specified type. If a type with the same Id already exists, the definition of the type is updated. Note that a type cannot be updated if any streams or views are associated with it. Also, certain parameters, including the type id, cannot be changed after they are defined. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response body The content is set to true on success. .NET Library Task CreateOrUpdateTypeAsync(SdsType SdsType) Security Allowed by administrator accounts Delete Type Deletes a type from the specified tenant and namespace. Note that a type cannot be deleted if any streams or views reference it. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code. .NET Library Task DeleteTypeAsync(string typeId); Security Allowed by administrator accounts"
  },
  "Documentation/SequentialDataStore/SDS_Views.html": {
    "href": "Documentation/SequentialDataStore/SDS_Views.html",
    "title": "Stream Views",
    "keywords": "Stream Views An SdsView provides a way to map Stream data requests from one data type to another. You can apply a Stream View to any read or GET operation. SdsView is used to specify the mapping between source and target types. Sds attempts to determine how to map Properties from the source to the destination. When the mapping is straightforward, such as when the properties are in the same position and of the same data type, or when the properties have the same name, SDS will map the properties automatically. When SDS is unable to determine how to map a source property, the property is removed. If SDS encounters a target property that it cannot map to, the property is added and configured with a default value. To map a property that is beyond the ability of Sds to map on its own, you should define an SdsViewProperty and add it to the SdsView’s Properties collection. The following table shows the required and optional SdsView fields. Fields that are not included are reserved for internal Sds use. Property Type Optionality Details Id String Required Identifier for referencing the stream view Name String Optional Friendly name Description String Optional Description text SourceTypeId String Required Identifier of the SdsType of the SdsStream TargetTypeId String Required Identifier of the SdsType to convert events to Properties IList Optional Property level mapping Rules for type identifier Is not case sensitive Can contain spaces Cannot begin with two underscores (\"__\") Cannot contain forward slash or backslash characters (\"/\" or \"\\\") Can contain a maximum of 100 characters Cannot start or end with a period. Cannot contain consecutive periods. Cannot consist of only periods. Properties / SdsViewProperty The SdsView Properties collection provides detailed instructions for specifying the mapping of event properties. Each SdsViewProperty in the Properties collection defines the mapping of an event’s property. SdsView Properties are required only when property mapping is not straightforward. Additionally, if you do not want a type property mapped, it is not necessary to create a SdsView property for it. The following table shows the required and optional SdsViewProperty fields. Property Type Optionality Details SourceId String Required Identifier of the SdsTypeProperty from the source SdsType Properties list TargetId String Required Identifier of the SdsTypeProperty from the target SdsType Properties list SdsView SdsView Optional Additional mapping instructions for derived types The SdsView field supports nested Properties. SdsViewMap When a SdsView is added, Sds defines a plan mapping. Plan details are retrieved as a SdsViewMap. The SdsViewMap provides a detailed Property-by-Property definition of the mapping. The following table shows the SdsViewMap fields. The SdsViewMap cannot be written to Sds, so required and optional have no meaning. Property Type Optionality Details SourceTypeId String Required Identifier of the SdsType of the SdsStream TargetTypeId String Required Identifier of the SdsType to convert events to Properties IList Optional Property level mapping Properties / SdsViewMapProperty The SdsViewMapProperty is similar a SdsViewProperty but adds a Mode detailing one or more actions taken on the Property. The following table shows the SdsViewMapProperty fields. The SdsViewMap cannot be written; it can only be retrieved from Sds, so required and optional have no meaning. Property Type Details SourceTypeId String Identifier of the SdsType of the SdsStream TargetTypeId String Identifier of the SdsType to convert events to Mode SdsViewMode Aggregate of actions applied to the properties. SdsViewModes are combined via binary arithmetic SdsViewMap SdsViewMap Mapping for derived types The available SdsViewModes are shown in the table below. Name Value Description None 0x0000 No action FieldAdd 0x0001 Add a property matching the specified SdsTypeProperty FieldRemove 0x0002 Remove the property matching the specified SdsTypeProperty FieldRename 0x0004 Rename the property matching the source SdsTypeProperty to the target SdsTypeProperty FieldMove 0x0008 Move the property from the location in the source to the location in the target FieldConversion 0x0016 Converts the source property to the target type InvalidFieldConversion 0x0032 Cannot perform the specified mapping Changing Stream Type Stream Views can be used to change the Type defining a Stream. You cannot modify the SdsType; types are immutable. But you can map a stream from its current type to a new type. To update a Stream Type, define an SdsView and PUT the stream view to the following: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Type?viewId={viewId} For details, see SdsView API . Working with Stream Views when using .NET Using .Net When working in .NET, use the Sds Client libraries’ ISdsMetadataService. Given the following: public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType<Simple>(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; await config.GetOrCreateTypeAsync(simpleType);//.CreateOrUpdateTypeAsync(simpleType);//.GetOrCreateTypeAsync(simpleType); SdsStream simpleStream = await config.GetOrCreateStreamAsync(new SdsStream() { Id = \"Simple\", Name = \"Simple\", TypeId = simpleType.Id }); DateTime start = new DateTime(2017, 4, 1).ToUniversalTime(); for (int i = 0; i < 10; i++) { Simple value = new Simple() { Time = start + TimeSpan.FromMinutes(i), State = State.Warning, Measurement = i }; await client.InsertValueAsync(simpleStream.Id, value); } IEnumerable<Simple> simpleValues = await client.GetWindowValuesAsync<Simple>(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\")); foreach (Simple value in simpleValues) Console.WriteLine($\"{value.Time}: {value.State}, {value.Measurement}\"); // The example displays the following output: // 4 / 1 / 2017 7:00:00 AM: Warning, 0 // 4 / 1 / 2017 7:01:00 AM: Warning, 1 // 4 / 1 / 2017 7:02:00 AM: Warning, 2 // 4 / 1 / 2017 7:03:00 AM: Warning, 3 // 4 / 1 / 2017 7:04:00 AM: Warning, 4 // 4 / 1 / 2017 7:05:00 AM: Warning, 5 // 4 / 1 / 2017 7:06:00 AM: Warning, 6 // 4 / 1 / 2017 7:07:00 AM: Warning, 7 // 4 / 1 / 2017 7:08:00 AM: Warning, 8 // 4 / 1 / 2017 7:09:00 AM: Warning, 9 To map the Measurement property to a property in the same location of the same type, allow Sds to automatically determine mapping. public class Simple1 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public double Value { get; set; } } SdsType simple1Type = SdsTypeBuilder.CreateSdsType<Simple1>(); simple1Type.Id = \"Simple1\"; simple1Type.Name = \"Simple1\"; simple1Type = await config.GetOrCreateTypeAsync(simple1Type); SdsView view = new SdsView() { Id = \"View\", Name = \"View\", SourceTypeId = simpleType.Id, TargetTypeId = simple1Type.Id, }; view = await config.GetOrCreateViewAsync(view); SdsViewMap map = await config.GetViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i < map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable<Simple1> simple1Values = await client.GetWindowValuesAsync<Simple1>(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple1 value in simple1Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); // The example displays the following output: // Simple to Simple1 // 0) Time to Time - None // 1) State to State - None // 2) Measurement to Value - FieldRename // // 4 / 1 / 2017 7:00:00 AM: Warning, 0 // 4 / 1 / 2017 7:01:00 AM: Warning, 1 // 4 / 1 / 2017 7:02:00 AM: Warning, 2 // 4 / 1 / 2017 7:03:00 AM: Warning, 3 // 4 / 1 / 2017 7:04:00 AM: Warning, 4 // 4 / 1 / 2017 7:05:00 AM: Warning, 5 // 4 / 1 / 2017 7:06:00 AM: Warning, 6 // 4 / 1 / 2017 7:07:00 AM: Warning, 7 // 4 / 1 / 2017 7:08:00 AM: Warning, 8 // 4 / 1 / 2017 7:09:00 AM: Warning, 9 A quick look at the SdsViewMap shows that Sds was able to determine that mapping from Measurement to Value involved a rename. Sds can also determine mapping of properties of the same name but different type. Note that the location of the Measurement property is also different yet it is still mapped. public class Simple2 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public int Measurement { get; set; } public State State { get; set; } } SdsType simple2Type = SdsTypeBuilder.CreateSdsType<Simple2>(); simple2Type.Id = \"Simple2\"; simple2Type.Name = \"Simple2\"; simple2Type = await config.GetOrCreateTypeAsync(simple2Type); view = new SdsView() { Id = \"View1\", Name = \"View1\", SourceTypeId = simpleType.Id, TargetTypeId = simple2Type.Id, }; view = await config.GetOrCreateViewAsync(view); map = await config.GetViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i < map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable<Simple2> simple2Values = await client.GetWindowValuesAsync<Simple2>(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple2 value in simple2Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Measurement}\"); //The example displays the following output: // Simple to Simple2 // 0) Time to Time - None // 1) State to State - None // 2) Measurement to Measurement - FieldConversion // // 4 / 1 / 2017 7:00:00 AM: Warning, 0 // 4 / 1 / 2017 7:01:00 AM: Warning, 1 // 4 / 1 / 2017 7:02:00 AM: Warning, 2 // 4 / 1 / 2017 7:03:00 AM: Warning, 3 // 4 / 1 / 2017 7:04:00 AM: Warning, 4 // 4 / 1 / 2017 7:05:00 AM: Warning, 5 // 4 / 1 / 2017 7:06:00 AM: Warning, 6 // 4 / 1 / 2017 7:07:00 AM: Warning, 7 // 4 / 1 / 2017 7:08:00 AM: Warning, 8 // 4 / 1 / 2017 7:09:00 AM: Warning, 9 The SdsViewMap shows that the source, floating point Measurement is converted to the target, integer Measurement. When neither the field name nor field type and location match, Sds does not determine mapping. The source is eliminated and target is added and assigned the default value. public class Simple3 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public int Value { get; set; } } SdsType simple3Type = SdsTypeBuilder.CreateSdsType<Simple3>(); simple3Type.Id = \"Simple3\"; simple3Type.Name = \"Simple3\"; simple3Type = await config.GetOrCreateTypeAsync(simple3Type); view = new SdsView() { Id = \"View2\", Name = \"View2\", SourceTypeId = simpleType.Id, TargetTypeId = simple3Type.Id, }; view = await config.GetOrCreateViewAsync(view); map = await config.GetViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i < map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable<Simple3> simple3Values = await client.GetWindowValuesAsync<Simple3>(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple3 value in simple3Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); //The example displays the following output: // Simple to Simple3 // 0) Time to Time - None // 1) State to State - None // 2) Measurement to -FieldRemove // 3) to Value -FieldAdd // // 4 / 1 / 2017 7:00:00 AM: Warning, 0 // 4 / 1 / 2017 7:01:00 AM: Warning, 0 // 4 / 1 / 2017 7:02:00 AM: Warning, 0 // 4 / 1 / 2017 7:03:00 AM: Warning, 0 // 4 / 1 / 2017 7:04:00 AM: Warning, 0 // 4 / 1 / 2017 7:05:00 AM: Warning, 0 // 4 / 1 / 2017 7:06:00 AM: Warning, 0 // 4 / 1 / 2017 7:07:00 AM: Warning, 0 // 4 / 1 / 2017 7:08:00 AM: Warning, 0 // 4 / 1 / 2017 7:09:00 AM: Warning, 0 To map when Sds cannot determine mapping, use SdsView Properties. view = new SdsView() { Id = \"View3\", Name = \"View3\", SourceTypeId = simpleType.Id, TargetTypeId = simple3Type.Id, Properties = new List<SdsViewProperty>() { new SdsViewProperty() { SourceId = \"Time\", TargetId = \"Time\" }, new SdsViewProperty() { SourceId = \"Status\", TargetId = \"Status\" }, new SdsViewProperty() { SourceId = \"Measurement\", TargetId = \"Value\" } } }; view = await config.GetOrCreateViewAsync(view); map = await config.GetViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i < map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); simple3Values = await client.GetWindowValuesAsync<Simple3>(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple3 value in simple3Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); //The example displays the following output: // Simple to Simple3 // 0) Time to Time - None // 1) State to State - None // 2) Measurement to Value - FieldRename, FieldConversion // // 4 / 1 / 2017 7:00:00 AM: Warning, 0 // 4 / 1 / 2017 7:01:00 AM: Warning, 1 // 4 / 1 / 2017 7:02:00 AM: Warning, 2 // 4 / 1 / 2017 7:03:00 AM: Warning, 3 // 4 / 1 / 2017 7:04:00 AM: Warning, 4 // 4 / 1 / 2017 7:05:00 AM: Warning, 5 // 4 / 1 / 2017 7:06:00 AM: Warning, 6 // 4 / 1 / 2017 7:07:00 AM: Warning, 7 // 4 / 1 / 2017 7:08:00 AM: Warning, 8 // 4 / 1 / 2017 7:09:00 AM: Warning, 9 Working with SdsViews when not using .NET When working with Stream Views and not using .NET, either invoke HTTP directly or use some of the sample code. Both Python and JavaScript samples have SdsView definitions. The JSON for a simple mapping between a source type with identifier Sample and a target type with identifier Sample1 would appear as follows. { \"Id\":\"View\", \"Name\":\"View\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple1\" } The SdsViewMap would appear as follows. { \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple1\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"State\", \"TargetId\":\"State\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\", \"Mode\":4 } ] } SdsView API The REST APIs provide programmatic access to read and write Sds data. The APIs in this section interact with SdsViews. When working in .NET convenient Sds Client libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService() helper, defines the available functions. See Sds View information for general SdsView information. Get Stream View Returns the stream view corresponding to the specified viewId within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews/{viewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string viewId The stream view identifier Response The response includes a status code and a response body. Response body The requested SdsView. Sample response body: HTTP/1.1 200 Content-Type: application/json { \"Id\":\"View\", \"Name\":\"View\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"Status\", \"TargetId\":\"Status\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\" } ] } .NET Library Task<SdsView> GetViewAsync(string viewId); Security Allowed for administrator and user accounts Get Stream View Map Returns the stream view map corresponding to the specified viewId within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews/{viewId}/Map Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string viewId The stream view identifier Response The response includes a status code and a response body. Response body The requested SdsView. Sample response body: HTTP/1.1 200 Content-Type: application/json { \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\", \"Mode\":20 }, { \"SourceId\":\"State\", \"Mode\":2 }, { \"TargetId\":\"State\", \"Mode\":1 } ] } .NET Library Task<SdsViewMap> GetViewMapAsync(string viewId); Security Allowed for administrator and user accounts Get Stream Views Returns a list of stream views within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews?skip={skip}&count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier int skip An optional value representing the zero-based offset of the first SdsView to retrieve. If not specified, a default value of 0 is used. int count An optional value representing the maximum number of SdsViews to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and a response body. Response body A collection of zero or more SdsViews. .NET Library Task<IEnumerable<SdsView>> GetViewsAsync(int skip = 0, int count = 100); Security Allowed for administrator and user accounts Get or Create Stream View If a stream view with a matching identifier already exists, the stream view passed in is compared with the existing stream view. If the stream views are identical, the stream view is returned. If the stream views are different, the Found (302) error is returned. If no matching identifier is found, the specified stream view is created. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews/{viewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string viewId The stream view identifier. The identifier must match the SdsView.Id field. The request content is the serialized SdsView. If you are not using the Sds client libraries, using JSON is recommended. Response The response includes a status code and a response body. Response body The newly created or matching SdsView. .NET Library Task<SdsView> GetOrCreateViewAsync(SdsView SdsView); Security Allowed for administrator accounts Create or Update Stream View Creates or updates the definition of a stream view. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews/{viewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string viewId The stream view identifier Response The response includes a status code and a response body. Response body The content is set to true on success. .NET Library Task CreateOrUpdateViewAsync(SdsView SdsView); Security Allowed for administrator accounts Delete Stream View Deletes a stream view from the specified tenant and namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/StreamViews/{viewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string viewId The stream view identifier Response The response includes a status code. .NET Library Task DeleteViewAsync(string viewId); Security Allowed for administrator accounts"
  },
  "Documentation/SequentialDataStore/Searching.html": {
    "href": "Documentation/SequentialDataStore/Searching.html",
    "title": "Searching",
    "keywords": "Searching SdsSearch provides a way to search text, phrases, fields, etc. cross the Sequential Data Store. This document covers the searching for SdsStreams and SdsTypes. Searching for Streams The search functionality for streams is exposed through the REST API and the client libraries method GetStreamsAsync . GetStreamsAsync is an overloaded method that is used to search for and return streams (also see Streams for information about using GetStreamAsync to return streams). When you call an overloaded method, the software determines the most appropriate method to use by comparing the argument types specified in the call to the method definition. The syntax of the client libraries method is as follows: _metadataService.GetStreamsAsync(query:\"QueryString\", skip:0, count:100); Searching for streams is also possible using the REST API and specifying the optional query parameter, as shown here: GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query={query}&skip={skip}&count={count} Searching for Types Similarly, the search functionality for types is also exposed through REST API and the client libraries method GetTypesAsync . The query syntax and the request parameters are the same. The only difference is the resource you're searching on, and you can filter on different properties for types than for streams. See Types for more information. GetTypesAsync is an overloaded method that is used to search for and return types. The syntax of the client libraries method is as follows: _metadataService.GetTypesAsync(query:\"QueryString\", skip:0, count:100); As previously mentioned, searching for types is also possible using the REST API and specifying the optional query parameter, as shown here: GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Types?query={query}&skip={skip}&count={count} How Searching Works The GetStreamsAsync or GetTypesAsync overload return items that match specific search criteria within a given namespace. The query parameter will be applied across all properties of items we’re searching on by default, such as Name or Description . For example, assume that a namespace contains the following Streams: streamId Name Description stream1 tempA The temperature from DeviceA stream2 pressureA The pressure from DeviceA stream3 calcA calculation from DeviceA values Using the stream data above, the following table shows the results of a GetStreamsAsync call with different Query values: QueryString Streams returned “temperature” stream1 and stream3 returned. “calc*” Only stream3 returned. “DeviceA*” All three streams returned. “humidity*” No streams returned. The skip and count parameters determine which items are returned when a large number of them match the query criteria. count indicates the maximum number of items returned by the GetStreamsAsync() or GetTypesAsync() call. The maximum value of the count parameter is 1000. skip indicates the number of matched items to skip over before returning matching items. You use the skip parameter when more items match the search criteria than can be returned in a single call. For example, assume there are 175 streams that match the search criteria: “temperature”. The following call returns the first 100 matches: _metadataService.GetStreamsAsync(“temperature”, 0, 100) After the previous call, you can use the following call to return the remaining 75 matches, skipping over the first 100 matches because of the skip parameter set at 100): _metadataService.GetStreamsAsync(“temperature”, 100, 100) The orderby parameter is supported for searching both the streams and types. The basic functionality of it is to search the items and then return the result in sorted order. The default value for orderby parameter is ascending order. It can be changed to descending order by specifying desc alongside the orderby field value. It can be used in conjunction with query , filter , skip , and count parameters. REST API examples GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=name:pump name:pressure&orderby=name GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=name:pump name:pressure&orderby=id asc GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=name:pump name:pressure&orderby=name desc GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=name:pump name:pressure&orderby=name desc&skip=10&count=20 Search operators You can specify search operators in the query string to return more specific search results. Operators Description AND AND operator. For example, \"cat AND dog\" searches for streams containing both \"cat\" and \"dog\". AND must be in all caps. OR OR operator. For example, \"cat OR dog\" searches for streams containing either \"cat\" or \"dog\" or both. OR must be in all caps. NOT NOT operator. For example, \"cat NOT dog\" searches for streams that have the \"cat\" term or do not have \"dog\". NOT must be in all caps. * Wildcard operator. For example, \"cat*\" searches for streams that have a term that starts with \"cat\", ignoring case. : Field-scoped query. For example, id:stream* will search for streams where the id field starts with \"stream\", but will not search on other fields like name or description . Note that field names are camel case and are case sensitive. \" \" Phrase search operator. For example, while Roach Motel (without quotes) would search for streams containing Roach Motel anywhere in any order, \"Roach Motel\" (with quotes) will only match documents that contain the whole phrase together and in that order. ( ) Precedence operator. For example, motel AND (wifi OR luxury) searches for streams containing the motel term and either wifi or luxury (or both). Notes regarding wildcard: The wildcard * can only be used once for each search term, except for the case of a Contains type query clause. In that case two wildcards are allowed: one as prefix and one as suffix e.g. *Tank* is valid but *Ta*nk , Ta*nk* , and *Ta*nk* are currently not supported. The wildcard * can't be combined when searching for a phrase using the \" \" operators which combine multiple ordered search terms. It only works when specifying a single search term. For example, you can search for Tank* , *Tank , Ta*nk but not \"Tank Meter*\" . : Operator You can also qualify which fields are searched by using the following syntax: fieldname:fieldvalue REST API example GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=name:pump name:pressure C# example GetStreamsAsync(query:”name:pump name:pressure”); * Operator You can use the ‘*’ character as a wildcard to specify an incomplete string. Query string Matches field value Does not match field value “log*” log logger analog “*log” analog alog logg “*log*” analog alogger lop “l*g” log logg lop Supported Not Supported “*” “*log” “l*g” “log*” “*log*” “*l*g*” “*l*g” “l*g*” REST API example GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=log* C# example GetStreamsAsync(query:”log*”); \"\" Operator The search engine automatically searches on strings delimited by whitespace and dashes (with the exception of identifier fields like Id or TypeId fields). To search for values that include delimiters, enclose the value in double quotes. \"*\" can not be used in conjunction with this operator. Query string Matches field value Does not match field value “pump pressure” pump pressure pump pressure gauge the pump pressure gauge the pump pressure pressure pump REST API example GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams?query=”pump pressure” C# example GetStreamsAsync(query:”\\\\”pump pressure\\\\””); Other operators examples Query string Matches field value Does not match field value “mud AND log” log mud mud log mud log “mud OR log” log mud mud log “mud AND (NOT log)” mud mud log “mud AND (log OR pump*)” mud log mud pumps mud bath “name:stream\\* AND (description:pressure OR description:pump)” The name starts with “stream” and the description has the either of the terms “pressure” or “pump”"
  },
  "Documentation/SequentialDataStore/table_format.html": {
    "href": "Documentation/SequentialDataStore/table_format.html",
    "title": "Table format",
    "keywords": "Table format A table is a convenient structure for analytics and display. The REST APIs for retrieving multiple events from the data store supports returning results in a table. The form variable can be set to specify a table or a table with headers. Table format can be applied to any read that returns multiple values, including Get Values, Get Range Values, Get Window Values, and Get Intervals. .NET public enum State { Ok, Warning, Alarm } public class Simple { [QiMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } With values as follows: 4/1/2017 7:00:00 AM : Warning 0 4/1/2017 7:01:00 AM : Warning 1 4/1/2017 7:02:00 AM : Warning 2 4/1/2017 7:03:00 AM : Warning 3 4/1/2017 7:04:00 AM : Warning 4 4/1/2017 7:05:00 AM : Warning 5 4/1/2017 7:06:00 AM : Warning 6 4/1/2017 7:07:00 AM : Warning 7 4/1/2017 7:08:00 AM : Warning 8 4/1/2017 7:09:00 AM : Warning 9 The following is a standard Get Window Values request: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/ GetWindowValues?startIndex= 2017-04-01T07:00:00Z&endIndex= 2017-04-01T07:10:00Z The following response would be returned from the above code: Content-Type: application/json [ { \"Time\":\"2017-04-01T07:00:00Z\", \"State\":1 }, { \"Time\":\"2017-04-01T07:01:00Z\", \"State\":1, \"Measurement\":1.0 }, { \"Time\":\"2017-04-01T07:02:00Z\", \"State\":1, \"Measurement\":2.0 }, { \"Time\":\"2017-04-01T07:03:00Z\", \"State\":1, \"Measurement\":3.0 }, { \"Time\":\"2017-04-01T07:04:00Z\", \"State\":1, \"Measurement\":4.0 }, { \"Time\":\"2017-04-01T07:05:00Z\", \"State\":1, \"Measurement\":5.0 }, { \"Time\":\"2017-04-01T07:06:00Z\", \"State\":1, \"Measurement\":6.0 }, { \"Time\":\"2017-04-01T07:07:00Z\", \"State\":1, \"Measurement\":7.0 }, { \"Time\":\"2017-04-01T07:08:00Z\", \"State\":1, \"Measurement\":8.0 }, { \"Time\":\"2017-04-01T07:09:00Z\", \"State\":1, \"Measurement\":9.0 } ] To retrieve the results in table format, add the form variable and specify table. :: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetWindowValues ?startIndex=2017-04-01T07:00:00Z&endIndex=2017-04-01T07:10:00Z &form=table Response Content-Type: application/json { \"Name\":\"Simple\", \"Columns\":[ { \"Name\":\"Time\", \"Type\":\"DateTime\" }, { \"Name\":\"State\", \"Type\":\"State\" }, { \"Name\":\"Measurement\", \"Type\":\"Double\" } ], \"Rows\":[ [ \"2017-04-01T07:00:00Z\", 1, 0.0 ], [ \"2017-04-01T07:01:00Z\", 1, 1.0 ], [ \"2017-04-01T07:02:00Z\", 1, 2.0 ], [ \"2017-04-01T07:03:00Z\", 1, 3.0 ], [ \"2017-04-01T07:04:00Z\", 1, 4.0 ], [ \"2017-04-01T07:05:00Z\", 1, 5.0 ], [ \"2017-04-01T07:06:00Z\", 1, 6.0 ], [ \"2017-04-01T07:07:00Z\", 1, 7.0 ], [ \"2017-04-01T07:08:00Z\", 1, 8.0 ], [ \"2017-04-01T07:09:00Z\", 1, 9.0 ] ] } To retrieve the results in table format with column headers, add the form variable and specify tableh . api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/Simple/Data/GetWindowValues ?startIndex=2017-04-01T07:00:00Z&endIndex=2017-04-01T07:10:00Z &form=tableh Response Content-Type: application/json { \"Name\":\"Simple\", \"Columns\":[ { \"Name\":\"Time\", \"Type\":\"DateTime\" }, { \"Name\":\"State\", \"Type\":\"State\" }, { \"Name\":\"Measurement\", \"Type\":\"Double\" } ], \"Rows\":[ [ \"Time\", \"State\", \"Measurement\" ], [ \"2017-04-01T07:00:00Z\", 1, 0.0 ], [ \"2017-04-01T07:01:00Z\", 1, 1.0 ], [ \"2017-04-01T07:02:00Z\", 1, 2.0 ], [ \"2017-04-01T07:03:00Z\", 1, 3.0 ], [ \"2017-04-01T07:04:00Z\", 1, 4.0 ], [ \"2017-04-01T07:05:00Z\", 1, 5.0 ], [ \"2017-04-01T07:06:00Z\", 1, 6.0 ], [ \"2017-04-01T07:07:00Z\", 1, 7.0 ], [ \"2017-04-01T07:08:00Z\", 1, 8.0 ], [ \"2017-04-01T07:09:00Z\", 1, 9.0 ] ] }"
  },
  "Documentation/SequentialDataStore/Units_of_Measure.html": {
    "href": "Documentation/SequentialDataStore/Units_of_Measure.html",
    "title": "Units of Measure",
    "keywords": "Units of Measure The Sequential Data Store (SDS) provides a collection of built-in units of measure (Uom). These units of measure can be associated with SdsStreams and SdsTypes in order to provide unit information for stream data that model measurable quantities. If data has unit information associated with it, SDS is able to support unit conversions when retrieving data. See Reading data for more information. Since a unit of measurement (i.e. meter) defines the magnitude of a quantity (i.e. Length), SDS represents this via two objects: SdsUom and SdsUomQuantity. SdsUom A SdsUom represents a single unit of measure, such as 'meter'. The following table shows the required and optional SdsUom fields. Property Type Optionality Details Example Id String Required Unique identifier for the unit of measure meters per second Abbreviation String Optional Abbreviation for the unit of measure m/s Name String Optional Full name for the unit of measure Meters per second DisplayName String Optional Friendly display name for the unit of measure meters per second QuantityId String Required The identifier associated with the quantity that this unit is a measure of Velocity ConversionFactor Double Required Used for unit conversions. When a value of this unit is multiplied by the ConversionFactor and then incremented by the ConversionOffset, the value in terms of the base unit of the corresponding quantity is returned. 1.0 ConversionOffset Double Required Used for unit conversions. See details for ConversionFactor 0.0 SdsUomQuantity Represents a single measurable quantity (i.e. Length) The following table shows the required and optional SdsUomQuantity fields. Property Type Optionality Details Example Id String Required Unique identifier for the quantity Velocity Name String Optional Full name for the quantity Velocity BaseUom SdsUom Required The base unit of measure for this quantity. All other Uom's measuring this quantity will have ConversionFactor's and ConversionOffsets relative to the BaseUom SdsUom representing \"meters per second\" Dimensions short[] Optional Reserved for internal use. Represents the seven base SI dimensions: Length, Mass, Time, Electric Current, Thermodynamic Temperature, Amount of Substance, and Luminous Density. [1,0,-1,0,0,0,0] Supported Quantities A list of the supported quantities and their base unit of measures is below. Supported quantities are read-only. Quantity Id Base Uom Id Angular Velocity radian per second Area square meter Computer Storage byte Density kilogram per cubic meter Dynamic Viscosity pascal second Electric Charge coulomb Electric Current ampere Electric Potential volt Electric Resistance ohm Energy joule Entropy and Heat Capacity joule per kelvin Force newton Frequency hertz Length meter Luminous Intensity candela Mass kilogram Mass Flow Rate kilogram per second Molar Flow Rate mole per second Molecular Weight kilogram per mole Amount of Substance mole Plane Angle radian Power watt Pressure pascal Quantity count Ratio percent Specific Energy joule per kilogram Specific Entropy and Specific Heat Capacity joule per kilogram kelvin Specific Volume cubic meter per kilogram Speed meter per second Temperature kelvin Temperature (Delta) delta kelvin Time second Volume cubic meter Volume Flow Rate cubic meter per second Supported Units of Measure A list of the supported units of measure is below. Supported units of measure are read-only. Uom Id Abbreviation Quantity Id Conversion Factor Conversion Offset count count Quantity 1 0 Ampere hour Ah Electric Charge 3600 0 coulomb C Electric Charge 1 0 kilogram per second kg/s Mass Flow Rate 1 0 long ton per day lton/d Mass Flow Rate 0.011759802 0 million pound per day MMlb/d Mass Flow Rate 5.24991169 0 short ton per day ston/d Mass Flow Rate 0.010499823 0 thousand pound per day klb/d Mass Flow Rate 0.005249912 0 gram per second g/s Mass Flow Rate 0.001 0 pound per second lb/s Mass Flow Rate 0.45359237 0 tonne per day t/d Mass Flow Rate 0.011574074 0 long ton lton Mass 1016.046909 0 million pound MM lb Mass 453592.37 0 ounce oz Mass 0.028349523 0 short ton ston Mass 907.18474 0 thousand pound klb Mass 453.59237 0 ton ton Mass 907.18474 0 gram g Mass 0.001 0 milligram mg Mass 1.00E-06 0 pound lb Mass 0.45359237 0 tonne t Mass 1000 0 kilogram kg Mass 1 0 second s Time 1 0 hour h Time 3600 0 day d Time 86400 0 month month Time 2628000 0 week week Time 604800 0 year yr Time 31536000 0 minute min Time 60 0 dyne dyne Force 1.00E-05 0 kilogram-force kgf Force 9.80665 0 pound-force lbf Force 4.448221615 0 newton N Force 1 0 watt W Power 1 0 million British thermal unit per day MM Btu/d Power 12211.29459 0 million British thermal unit per hour MM Btu/h Power 293071.0702 0 gigawatt GW Power 1000000000 0 megawatt MW Power 1000000 0 British thermal unit per hour Btu/h Power 0.29307107 0 calorie per second cal/s Power 4.1868 0 horsepower hp Power 745.6998716 0 joule per second J/s Power 1 0 kilowatt kW Power 1000 0 megajoule per hour MJ/h Power 277.7777778 0 million calorie per hour MMcal/h Power 1163 0 mole per second mol/s Molar Flow Rate 1 0 gram mole per second gmol/s Molar Flow Rate 1 0 kilogram mole per second kmol/s Molar Flow Rate 1000 0 pound mole per second lbmol/s Molar Flow Rate 453.59237 0 meter m Length 1 0 centimeter cm Length 0.01 0 inch in Length 0.0254 0 International nautical mile nmi Length 1852 0 kilometer km Length 1000 0 millimeter mm Length 0.001 0 foot ft Length 0.3048 0 mile mi Length 1609.344 0 sixteenth of an inch sxi Length 0.0015875 0 yard yd Length 0.9144 0 candela cd Luminous Intensity 1 0 meter per second m/s Speed 1 0 centimeter per second cm/s Speed 0.01 0 foot per second ft/s Speed 0.3048 0 International nautical mile per hour nmi/h Speed 0.514444444 0 kilometer per hour km/h Speed 0.277777778 0 mile per hour mi/h Speed 0.44704 0 revolution per minute rpm Angular Velocity 0.104719755 0 radian per second rad/s Angular Velocity 1 0 barrel per day bbl/d Volume Flow Rate 1.84E-06 0 cubic centimeter per second cm3/s Volume Flow Rate 1.00E-06 0 cubic foot per second ft3/s Volume Flow Rate 0.028316847 0 cubic meter per hour m3/h Volume Flow Rate 0.000277778 0 Imperial gallon per minute Imp gal/min Volume Flow Rate 7.58E-05 0 liter per second L/s Volume Flow Rate 0.001 0 US gallon per minute US gal/min Volume Flow Rate 6.31E-05 0 cubic meter per second m3/s Volume Flow Rate 1 0 pascal Pa Pressure 1 0 atmosphere atm Pressure 101325 0 bar bar Pressure 100000 0 inches of mercury inHg Pressure 3386.388158 0 kilogram-force per square centimeter kgf/cm2 Pressure 98066.5 0 kilogram-force per square meter kgf/m2 Pressure 9.80665 0 kilopascal kPa Pressure 1000 0 millimeter of mercury mmHg Pressure 133.3223684 0 newton per square meter N/m2 Pressure 1 0 pound-force per square inch psi Pressure 6894.757293 0 pound-force per square inch (customary) psia Pressure 6894.757293 0 torr torr Pressure 133.3223684 0 square meter m2 Area 1 0 square foot ft2 Area 0.09290304 0 acre acre Area 4046.856422 0 square mile mi2 Area 2589988.11 0 square yard yd2 Area 0.83612736 0 hectare ha Area 10000 0 square centimeter cm2 Area 0.0001 0 square inch in2 Area 0.00064516 0 square kilometer km2 Area 1000000 0 square millimeter mm2 Area 1.00E-06 0 yobibyte YiB Computer Storage 1.21E+24 0 zebibyte ZiB Computer Storage 1.18E+21 0 exbibyte EiB Computer Storage 1.15E+18 0 pebibyte PiB Computer Storage 1.13E+15 0 tebibyte TiB Computer Storage 1.10E+12 0 gibibyte GiB Computer Storage 1073741824 0 mebibyte MiB Computer Storage 1048576 0 kibibyte KiB Computer Storage 1024 0 yottabyte YB Computer Storage 1.00E+24 0 zettabyte ZB Computer Storage 1.00E+21 0 exabyte EB Computer Storage 1.00E+18 0 petabyte PB Computer Storage 1.00E+15 0 terabyte TB Computer Storage 1.00E+12 0 gigabyte GB Computer Storage 1000000000 0 megabyte MB Computer Storage 1000000 0 kilobyte kB Computer Storage 1000 0 byte B Computer Storage 1 0 kelvin K Temperature 1 0 degree Celsius °C Temperature 1 273.15 degree Rankine °R Temperature 0.555555556 -2.56E-13 degree Fahrenheit °F Temperature 0.555555556 255.3722222 milliampere mA Electric Current 0.001 0 ampere A Electric Current 1 0 joule per gram J/g Specific Energy 1000 0 joule per kilogram J/kg Specific Energy 1 0 British thermal unit per pound Btu/lb Specific Energy 2326 0 kilocalorie per kilogram kcal/kg Specific Energy 4186.8 0 kilojoule per kilogram kJ/kg Specific Energy 1000 0 kilojoule per pound kJ/lb Specific Energy 2204.622622 0 British thermal unit per degree Rankine Btu/°R Entropy and Heat Capacity 1899.100535 0 British thermal unit per degree Fahrenheit Btu/°F Entropy and Heat Capacity 1899.100535 0 kilojoule per kelvin kJ/K Entropy and Heat Capacity 1000 0 joule per kelvin J/K Entropy and Heat Capacity 1 0 cubic foot per pound ft3/lb Specific Volume 0.062427961 0 cubic centimeter per gram cm3/g Specific Volume 0.001 0 cubic meter per kilogram m3/kg Specific Volume 1 0 hertz Hz Frequency 1 0 mole mol Amount of Substance 1 0 gram mole gmol Amount of Substance 1 0 kilogram mole kmol Amount of Substance 1000 0 pound mole lbmol Amount of Substance 453.59237 0 percent % Ratio 1 0 parts per billion ppb Ratio 1.00E-07 0 parts per million ppm Ratio 0.0001 0 ohm Ω Electric Resistance 1 0 gram per gram mole g/gmol Molecular Weight 0.001 0 pound per pound mole lb/lbmol Molecular Weight 0.001 0 kilogram per mole kg/mol Molecular Weight 1 0 kilogram per kilogram mole kg/kmol Molecular Weight 0.001 0 British thermal unit per pound degree Rankine Btu/(lb °R) Specific Entropy and Specific Heat Capacity 4186.8 0 British thermal unit per pound degree Fahrenheit Btu/(lb °F) Specific Entropy and Specific Heat Capacity 4186.8 0 joule per gram kelvin J/(g K) Specific Entropy and Specific Heat Capacity 1000 0 kilojoule per kilogram kelvin kJ/(kg K) Specific Entropy and Specific Heat Capacity 1000 0 joule per kilogram kelvin J/(kg K) Specific Entropy and Specific Heat Capacity 1 0 kilovolt kV Electric Potential 1000 0 millivolt mV Electric Potential 0.001 0 megavolt MV Electric Potential 1000000 0 volt V Electric Potential 1 0 joule J Energy 1 0 gigawatt hour GWh Energy 3.60E+12 0 megawatt hour MWh Energy 3600000000 0 watt hour Wh Energy 3600 0 British thermal unit Btu Energy 1055.055853 0 calorie cal Energy 4.1868 0 gigajoule GJ Energy 1000000000 0 kilojoule kJ Energy 1000 0 kilowatt hour kWh Energy 3600000 0 megajoule MJ Energy 1000000 0 watt second Ws Energy 1 0 kilocalorie kcal Energy 4186.8 0 million calorie MMcal Energy 4186800 0 million British thermal unit MM Btu Energy 1055055853 0 acre foot acre ft Volume 1233.481838 0 million imperial gallon Imp Mgal Volume 4546.09 0 thousand imperial gallon Imp kgal Volume 4.54609 0 barrel bbl Volume 0.158987295 0 Imperial gallon Imp gal Volume 0.00454609 0 million US gallon US Mgal Volume 3785.411784 0 thousand US gallon US kgal Volume 3.785411784 0 cubic centimeter cm3 Volume 1.00E-06 0 cubic foot ft3 Volume 0.028316847 0 kiloliter kL Volume 1 0 liter L Volume 0.001 0 megaliter M L Volume 1000 0 milliliter mL Volume 1.00E-06 0 thousand cubic meter k m3 Volume 1000 0 US gallon US gal Volume 0.003785412 0 million barrel MMbbl Volume 158987.2949 0 thousand barrel kbbl Volume 158.9872949 0 cubic meter m3 Volume 1 0 kilogram per cubic meter kg/m3 Density 1 0 gram per liter g/L Density 1 0 kilogram per liter kg/L Density 1000 0 pound per barrel lb/bbl Density 2.853010174 0 pound per cubic foot lb/ft3 Density 16.01846337 0 pound per US gallon lb/US gal Density 119.8264273 0 tonne per cubic meter t/m3 Density 1000 0 radian rad Plane Angle 1 0 degree ° Plane Angle 0.017453293 0 revolution r Plane Angle 6.283185307 0 pascal second Pa*s Dynamic Viscosity 1 0 poise P Dynamic Viscosity 0.1 0 delta degree Fahrenheit delta °F Temperature (Delta) 0.555555556 0 delta degree Rankine delta °R Temperature (Delta) 0.555555556 0 delta kelvin delta K Temperature (Delta) 1 0 delta degree Celsius delta °C Temperature (Delta) 1 0 SdsUomQuantity API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsUomQuantitys. When working in .NET, convenient SDS Client Libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Units of Measure for general SdsUomQuantity information. Get Quantity Returns the quantity corresponding to the specified quantityId within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Quantities/{quantityId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body The requested SdsUomQuantity. Sample response body for quantityId = \"Length\": HTTP/1.1 200 Content-Type: application/json { \"Id\": \"Length\", \"Name\": \"Length\", \"BaseUom\": { \"Id\": \"meter\", \"Abbreviation\": \"m\", \"Name\": \"meter\", \"DisplayName\": \"meter\", \"QuantityId\": \"Length\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 1, 0, 0, 0, 0, 0, 0 ] } .NET Library Task<SdsUomQuantity> GetQuantityAsync(string quantityId); Get Quantities Returns a list of all quantities available within a given namespace. Request api/Tenants/{tenantId}/Namespaces/{namespaceId}/Quantities?skip={skip}&count={count} string tenantId The tenant identifier string namespaceId The namespace identifier int skip An optional parameter representing the zero-based offset of the first SdsUomQuantity to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsUomQuantity to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and a response body. Response body A list of SdsUomQuantity objects. Sample response body: HTTP/1.1 200 Content-Type: application/json [ { \"Id\": \"Angular Velocity\", \"Name\": \"Angular Velocity\", \"BaseUom\": { \"Id\": \"radian per second\", \"Abbreviation\": \"rad/s\", \"Name\": \"radian per second\", \"DisplayName\": \"radian per second\", \"QuantityId\": \"Angular Velocity\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 0, 0, -1, 0, 0, 0, 0 ] }, { \"Id\": \"Area\", \"Name\": \"Area\", \"BaseUom\": { \"Id\": \"square meter\", \"Abbreviation\": \"m2\", \"Name\": \"square meter\", \"DisplayName\": \"square meter\", \"QuantityId\": \"Area\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 2, 0, 0, 0, 0, 0, 0 ] }, ... ] .NET Library Task<IEnumerable<SdsUomQuantity>> GetQuantitiesAsync(int skip = 0, int count = 100); Get Quantity Uom Returns the unit of measure associated with the specified uomId belonging to the quantity with the specified quantityId. Request api/Tenants/{tenantId}/Namespaces/{namespaceId}/Quantities/{quantityId}/Units/{uomId} string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response body The requested SdsUom. Sample response for quantityId = \"Length\" and uomId =\"mile\": HTTP/1.1 200 { \"Id\": \"mile\", \"Abbreviation\": \"mi\", \"Name\": \"mile\", \"DisplayName\": \"mile\", \"QuantityId\": \"Length\", \"ConversionFactor\": 1609.344 } .NET Library Task<SdsUom> GetQuantityUomAsync(string quantityId, string uomId); Get Quantity Uoms Returns the list of units of measure that belongs to the quantity with the specified quantityId. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Quantities/{quantityId}/Units string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body A collection of SdsUom objects for the specified quantity. Sample response for quantityId = \"Electric Current\": HTTP/1.1 200 Content-Type: application/json [ { \"Id\": \"milliampere\", \"Abbreviation\": \"mA\", \"Name\": \"milliampere\", \"DisplayName\": \"milliampere\", \"QuantityId\": \"Electric Current\", \"ConversionFactor\": 0.001 }, { \"Id\": \"ampere\", \"Abbreviation\": \"A\", \"Name\": \"ampere\", \"DisplayName\": \"ampere\", \"QuantityId\": \"Electric Current\", \"ConversionFactor\": 1 } ] .NET Library Task<IEnumerable<SdsUom>> GetQuantityUomsAsync(string quantityId); SdsUom API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsUoms. When working in .NET, convenient SDS Client Libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Units of Measure for general SdsUom information. Get Uom Returns the unit of measure corresponding to the specified uomId within a given namespace. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Units/{uomId} string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body The requested SdsUom. Sample response body for uomId = \"ounce\": HTTP/1.1 200 Content-Type: application/json { \"Id\": \"ounce\", \"Abbreviation\": \"oz\", \"Name\": \"ounce\", \"DisplayName\": \"ounce\", \"QuantityId\": \"Mass\", \"ConversionFactor\": 0.028349523 } .NET Library Task<SdsUom> GetUomAsync(string uomId); Get Uoms Returns a list of all available units of measure in the system. Request GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/Units?skip={skip}&count={count} string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body A list of SdsUom objects. Sample response body: HTTP/1.1 200 Content-Type: application/json [ { \"Id\": \"count\", \"Abbreviation\": \"count\", \"Name\": \"count\", \"DisplayName\": \"count\", \"QuantityId\": \"Quantity\", \"ConversionFactor\": 1 }, { \"Id\": \"Ampere hour\", \"Abbreviation\": \"Ah\", \"Name\": \"Ampere hour\", \"DisplayName\": \"Ampere hour\", \"QuantityId\": \"Electric Charge\", \"ConversionFactor\": 3600 }, { \"Id\": \"coulomb\", \"Abbreviation\": \"C\", \"Name\": \"coulomb\", \"DisplayName\": \"coulomb\", \"QuantityId\": \"Electric Charge\", \"ConversionFactor\": 1 } ... ] .NET Library Task<IEnumerable<SdsUom>> GetUomsAsync(int skip = 0, int count = 100); Associating a unit of measure with a SdsType At SdsType creation, a SdsUom can be associated with a SdsTypeProperty . Associating a unit of measure with a SdsStream At SdsStream creation, you can override any unit of measure associated with a SdsTypeProperty belonging to the SdsType of the stream. This enables the reuse of a SdsType that may have default unit information associated with it already."
  },
  "Documentation/SequentialDataStore/Writing_Data.html": {
    "href": "Documentation/SequentialDataStore/Writing_Data.html",
    "title": "Writing data",
    "keywords": "Writing data The Sds REST APIs provide programmatic access to read and write Sds data. This section describes the APIs used to write SdsStream data. When working in .NET, convenient Sds Client libraries are available. The ISdsDataServiceinterface , accessed using the SdsService.GetDataService( ) helper, defines the available functions. All writes rely on a stream’s key or primary index. Preexisting values and positioning within the stream is determined exclusively by the primary index. Secondary indexes are updated, but they do not contribute to the request. All references to indexes are to the primary index. The following single value write methods are available: Insert Value inserts a value at the specified primary index. Patch Value updates specific fields in an existing value identified by the primary index. Replace Value replaces the value at the specified primary index. Update Value replaces the value with matching primary index. If no value exists the value is added. Remove Value deletes the value at the specified primary index. The following support writing multiple values: Insert Values inserts a collection of values. Patch Values updates specific fields for a collection of values. Replace Values replaces a collection of values. Update Values replaces or adds a collection of values. Remove Values deletes the values at the specified primary indexes. Remove Window Values removes values that fall within the window defined by the start and end primary indexes. The base URI for writing Sds data is: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response Format Supported response formats include JSON, verbose JSON, and Sds. The default response format for reading data is JSON, which is used in all examples in this document. Default JSON responses do not include any values that are equal to the default value for their type. Verbose JSON responses include all values in the returned JSON payload, including defaults. To specify verbose JSON return, add the header Accept-Verbosity with a value of verbose to the request. Verbose has no impact on writes; writes return only error messages. To specify Sds format, set the Accept header in the request to application/Sds . Indexes Sds writes rely on the primary index for positioning within streams and locating existing events. Most writes use the index as specified by the value. Deletes are the exception to this rule. When deleting, indexes are specified as strings in the URI, or, when using the Sds Client libraries, the index may be passed as-is to delete methods that take the index type as a generic argument. More details about working with indexes can be found on the Indexes page. To specify compound indexes in the URI, specify each field that composes the index, in the specified order, separated by the pipe character, ‘|’. Examples Many of the API methods described below contain sample JSON. When specifying a parameter of type enum , the API accepts both the name of the field and the numeric value of the field. Samples vary to highlight enum flexibility. Samples use the following types: Type with a simple index, named Simple : .NET public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Aalrm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } The values produced by the above code is as follows: 11/23/2017 12:00:00 PM: Ok 0 11/23/2017 1:00:00 PM: Ok 10 11/23/2017 2:00:00 PM: Ok 20 11/23/2017 3:00:00 PM: Ok 30 11/23/2017 4:00:00 PM: Ok 40 Type with Compound Index, named DerivedCompoundIndex .NET public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } public class DerivedCompoundIndex : Simple { [SdsMember(IsKey = true, Order = 1)] public DateTime Recorded { get; set; } } Python class Simple(object): # First-order Key property Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement class DerivedCompoundIndex(Simple): # Second-order Key property @property def Recorded(self): return self.__recorded @Recorded.setter def Recorded(self, recorded): self.__recorded = recorded JavaScript var Simple = function () { this.Time = null; this.State = null; this.Value = null; } var DerivedCompoundIndex = function() { Simple.call(this); this.Recorded = null; } Has values as follows: 1/20/2017 1:00:00 AM : 1/20/2017 12:00:00 AM 0 1/20/2017 1:00:00 AM : 1/20/2017 1:00:00 AM 2 1/20/2017 1:00:00 AM : 1/20/2017 2:00:00 PM 5 1/20/2017 2:00:00 AM : 1/20/2017 12:00:00 AM 1 1/20/2017 2:00:00 AM : 1/20/2017 1:00:00 AM 3 1/20/2017 2:00:00 AM : 1/20/2017 2:00:00 AM 4 1/20/2017 2:00:00 AM : 1/20/2017 2:00:00 PM 6 All times are represented at offset 0, GMT. Insert value Inserts an event into the specified stream. If an event already exists at the specified primary index, the insert operation fails, and returns HTTP status code Conflict, 409. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/InsertValue Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. A sample of serialized Simple type content is shown here: { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":0, \"Measurement\":1000.0 } Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task InsertValueAsync<T>(string streamId, T item); Security Allowed for administrator accounts. Patch value Updates fields in an event. Use the select parameter to specify the fields to update. If there is not an event with a matching primary index, the patch operation fails and returns HTTP status code Not Found, 404. Request PATCH api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ PatchValue?select={select} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string select Comma-separated list of fields to update The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. A sample of serialized Simple type content is shown here: { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":”Warning”, \"Measurement\":500.0 } To update the state field to Warning, set the index to state . To update the state to Warning and the measurement to 500, set the index to state,measurement . Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task PatchValueAsync<T>(string streamId, string select, T item); Security Allowed for administrator accounts. Replace value Replaces an existing event with an event with matching primary index. If there is not an event with a matching index, the replace operation fails and returns HTTP status code Not Found, 404. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ReplaceValue Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. A sample of serialized Simple type content is shown here: { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":0, \"Measurement\":1000.0 } Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task ReplaceValueAsync<T>(string streamId, T item); Security Allowed for administrator accounts. Update value Replaces an existing event with an event that has a matching primary index. If there is not an event with a matching index, the event is inserted. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/UpdateValue Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. A sample of serialized Simple type content is shown here: { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":0, \"Measurement\":1000.0 } Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task UpdateValueAsync<T>(string streamId, T item); Security Allowed for administrator accounts. Remove value Removes an event that matches a primary index. If there is not an event with a matching index, the remove operation fails and returns HTTP status code Not Found, 404. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ RemoveValue?index={index} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The primary index identifying the event Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task RemoveValueAsync(string streamId, string index); Task RemoveValueAsync<T1>(string streamId, T1 index); Task RemoveValueAsync<T1, T2>(string streamId, Tuple<T1, T1> index); Security Allowed for administrator accounts. Insert values Inserts a collection of events into the specified stream. If an event exists at the same primary index as any of the values, the insert operation fails and returns HTTP status code Conflict, 409. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/InsertValues Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. A sample of serialized Simple type content is shown here: [ { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":0, \"Measurement\":0.0 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"State\":0, \"Measurement\":10.0 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"State\":0, \"Measurement\":20.0 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"State\":0, \"Measurement\":30.0 }, { \"Time\":\"2017-11-23T16:00:00Z\", \"State\":0, \"Measurement\":40.0 } ] Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task InsertValuesAsyncs<T>(string streamId, IList<T> items); Security Allowed for administrator accounts. Patch values Updates fields for a collection of events in the specified stream. If there is not an event with a matching index, the patch operation fails and returns HTTP status code Not Found, 404. Request POST api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/PatchValues ?select={select} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string select Comma separated list of fields to update The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. To patch the State of the sample stream shown previously, a URI resembles the following: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{simpleStream.Id}/ Data/PatchValues?select=state A sample of serialized Simple type content is shown here: [ { \"Time\":\"2017-11-23T12:00:00Z\", \"State\":1 }, { \"Time\":\"2017-11-23T13:00:00Z\", \"State\":1 }, { \"Time\":\"2017-11-23T14:00:00Z\", \"State\":1 }, { \"Time\":\"2017-11-23T15:00:00Z\", \"State\":1 } ] Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task PatchValuesAsync<T>(string streamId, string select, IList<T> items); Security Allowed for administrator accounts. Replace values Replaces a collection of events with events that match primary indexes. If there is not an event with a matching index, the replace operation fails and returns HTTP status code Not Found, 404. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ReplaceValues Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task ReplaceValuesAsync<T>(string streamId, IList<T> items); Security Allowed for administrator accounts. Update values Replaces a collection of events with events that contain matching primary indexes. If there is not a collectin of events with a matching index, the events are inserted. Request PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/UpdateValues Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized object matching the stream type. If you are not using the Sds client libraries, using JSON is recommended. Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task UpdateValuesAsync<T>(string streamId, T item); Security Allowed for administrator accounts. Remove values Removes events at matching primary indexes. If there is not an event with a matching index, the remove operation fails and returns HTTP status code Not Found, 404. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ RemoveValues?index={index} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The collection of indexes identifying the events Each index is treated like a separate parameter. For example, to delete three events, the URI should resebble the following: api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ RemoveValues?index=2017-01-20T01:00:00Z|2017-01-20T00:00:00Z &index=2017-01-20T01:00:00Z|2017-01-20T01:00:00Z &index=2017-01-20T01:00:00Z|2017-01-20T14:00:00Z Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task RemoveValuesAsync(string streamId, IEnumerable<string>> index); Task RemoveValuesAsync<T1>(string streamId, IEnumerable<T1> index); Task RemoveValuesAsync<T1, T2>(string streamId, IEnumerable<Tuple<T1, T1>> index); Security Allowed for administrator accounts. Remove window values Removes events that fall within a window defined by start and end primary indexes. Events that fall at the start or end index are also deleted. Request DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data/ RemoveWindowValues?startIndex={startIndex}&endIndex={endIndex} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index defining the beginning of the window string endIndex The Index defining the end of the window Response The response includes a status code. On error, the response body contains a serialized description of the error. .NET Library Task RemoveWindowValuesAsync (string streamId, string startIndex, string endIndex); Task RemoveWindowValuesAsync <T1>(string streamId, T1 startIndex, T1 endIndex); Task RemoveWindowValuesAsync <T1, T2>(string streamId, Tuple<T1, T1> startIndex, Tuple<T1, T1>endIndex); Security Allowed for administrator accounts."
  },
  "Documentation/Access_Control.html": {
    "href": "Documentation/Access_Control.html",
    "title": "Role-based access control",
    "keywords": "Role-based access control Within OCS, role-based access control to entities such as Namespaces, Streams, and so on, is managed using an Access Control List (ACL) and an Owner identity assigned to each entity. ACLs control access to entities based on their OCS Roles. Owners are granted access for all operations regardless of the contents of the ACL. Not all entities in the OCS system support role-based access control at this time, but the list will quickly grow and currently includes Namespaces and several unreleased entities. Access Control Lists Access Control Lists (ACLs) contain sets of Access Control Entries (ACEs) each with a trustee (reference to an identity, such as a role, user, or application), AccessType, and AccessRights. A user or application that attempts to read, write, delete, or manage access control of an entity assigned an ACL must be assigned a trustee that has AccessType set to Allowed for the AccessRight corresponding to that operation. AccessRights are the bitwise union of all of the access rights they encompass. For example, AccessRights 3 indicates that Read and Write access is permitted. Note If an operation requires more than one access right then an identity can obtain those rights from multiple ACL entries. Note AccessType.Denied takes precedence over AccessType.Allowed . For example, a role that is assigned AccessType.Denied for AccessRights.All will receive a forbidden for all requests unless they are the owner of the entity. Note Roles are the only TrusteeType supported for AccessControlList ACEs. TrusteeType TypeId User 1 Application 2 Role 3 AccessType TypeId Allowed 0 Denied 1 CommonAccessRightsEnum AccessRights int bitwise None 0 0000 Read 1 0001 Write 2 0010 Delete 4 0100 ManageAccessControl 8 1000 All 15 1111 The following code sample shows the structure and format for an ACL that gives Role 1 Read Access, Role 2 All access but denies Role 3 ManageAccessControl Access: AccessControlListObj Body Sample body: HTTP/1.1 200 Content-Type: application/json \"AccessControlList\": { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ], } Owner Owner objects on OCS entities are used to grant access for all operations on the entity regardless of the entity's AccessControlList's AccessControlEntries. Note Currently, only Users and Applications are valid owners for entities. The following code samples shows the format and structure of an owner object: TrusteeObj User Owner Body \"Owner\": { \"Type\": 1, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ObjectId\": \"44444444-4444-4444-4444-444444444444\" }, Application Owner Body \"Owner\": { \"Type\": 2, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ApplicationId\": \"66666666-6666-6666-6666-666666666666\" },"
  },
  "Documentation/OSIsoft_Cloud_Services.html": {
    "href": "Documentation/OSIsoft_Cloud_Services.html",
    "title": "OSIsoft Cloud Services",
    "keywords": "OSIsoft Cloud Services The information in the sections that follow document the APIs and usage for each of the following: Management - Use the informatin in this section to create, manage, and administer your account by assigning users, roles, and namespaces to your tenant. Sequential data store (SDS) - Use the information in this section to learn about the OSIsoft Cloud Services Sequential Data Store. The data store is an optimized sequential data store based on the Qi technology. Data ingress and OSIsoft Message Format - You use OSIsoft Message Format (OMF) to achieve high-throughput asynchronous data ingress into the OCS Sequential data store."
  },
  "Documentation/samples.html": {
    "href": "Documentation/samples.html",
    "title": "Samples",
    "keywords": "Samples The Qi-Samples illustrate several ways for applications to interact with the Qi REST API. The examples cover the basics of interacting with Qi, such as: Connecting to Qi Creating QiTypes and instances of QiStreams Sending data to, and retrieving data from QiStreams Performing queries against QiStreams Removing QiStreams and QiTypes Currently, the samples are available in these languages: C# Java Python Because the examples are intended for demonstration purposes, they represent some example practices. The patterns may change as the Qi Preview progresses. Be sure to follow the Qi-Samples repository on GitHub for updates."
  },
  "Documentation/Management/Account_Namespace.html": {
    "href": "Documentation/Management/Account_Namespace.html",
    "title": "Namespace",
    "keywords": "Namespace A Namespace is a collection of SDS types, streams, and stream views. Namespace identifiers are unique within an account. Requirements for Namespace Ids are the following: Must contain 260 characters or fewer Must only contain alphanumeric characters, underscores, dashes, spaces, and periods Must not contain two consecutive periods Must not start or end with a period Must not start with two consecutive underscores Properties For HTTP requests and responses, the Namespace object has the following properties and JSON-serialized body: Property Type Description Id string Name of this Namespace. Unique within a Tenant's Namespaces. TenantId string GUID of the Tenant that this Namespace corresponds to Region string The region that the namespace is provisioned in Self string The namespace's URI Description string Description of this Namespace. TierId string Id of the Tier that this Namespace is associated with. ThroughputUnits int32 Number of Throughput units for this Namespace. StorageUnits int32 Number of Storage units for this Namespace. State NamespaceProvisioningState Current state of this Namespace. Owner Trustee Owner Trustee of this Namespace. AccessControl AccessControlList The AccessControl that defines Access Control for this Namespace { \"Id\": \"id\", \"TenantId\": \"tenantid\", \"Region\": \"region\", \"Self\": \"self\", \"Description\": \"description\", \"TierId\": \"tierid\", \"ThroughputUnits\": 0, \"StorageUnits\": 0, \"State\": 0, \"Owner\": { \"Type\": 0 }, \"AccessControl\": { \"RoleTrusteeAccessControlEntries\": [] } } GetAll() Returns all Namespaces owned by the specified Tenant that the caller has access to. Http GET api/Tenants/{tenantId}/Namespaces Parameters [Required] string tenantId The identifier of the account to access. Security A Namespace can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 [Namespace] Returns a list of all Namespace objects for the specified tenantId that the caller has access to. 400 Nothing is returned Could not retrieve Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to access the tenant's Namespaces . GetNamespaceById() Returns a Namespace with the specified Id. Http GET api/Tenants/{tenantId}/Namespaces/{namespaceId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to return. Security A Namespace can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 Namespace Returns a Namespace object with the specified namespaceId. 400 Nothing is returned Could not retrieve the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to access this Namespace . 404 Nothing is returned Namespace not found in the specified account. Create() Creates a new Namespace in the specified Tenant . Http POST api/Tenants/{tenantId}/Namespaces Parameters [Required] string tenantId The account identifier where the Namespace will be created. [Required] [FromBody] Namespace namespaceObj The new Namespace to be created. Security A Namespace can only be created if the current principal has Write access. Returns Status Code Return Type Description 201 Namespace Returns the created Namespace object. 400 Nothing is returned Could not create the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to create a Namespace in this account. Update() Updates Namespace information: Description and TierId. The AccessControl and Owner's Trustee can only be updated through their own routes. Http PUT api/Tenants/{tenantId}/Namespaces/{namespaceId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to update. [Required] [FromBody] Namespace newProperties The new details to store for the Namespace . Security A Namespace can only be updated if the current principal has Write access. Returns Status Code Return Type Description 200 Namespace Returns the updated Namespace . 400 Nothing is returned Could not update the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to update the Namespace . Delete() Deletes a Namespace in the specified Tenant . Http DELETE api/Tenants/{tenantId}/Namespaces/{namespaceId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to delete. Security A Namespace can only be deleted if the current principal has Delete access. Returns Status Code Return Type Description 204 Nothing is returned The Namespace was deleted. 400 Nothing is returned Could not delete the Namespace due to an invalid state. 403 Nothing is returned Unauthorized to delete the Namespace . GetAccessControl() Returns the AccessControl that is used to authorize access to a Namespace . Http GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/accesscontrol Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to access. Security An AccessControl can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 AccessControl Returns the AccessControl for the specified Namespace . 400 Nothing is returned Could not retrieve the AccessControl of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to get the AccessControl for the specified Namespace . SetAccessControl() Updates the AccessControl that is used to authorize access to a Namespace . Http PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/accesscontrol Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to access. [Required] [FromBody] AccessControlList newAccessControlList The updated AccessControl for the Namespace . Security An AccessControl can only be updated if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 AccessControl Returns the updated AccessControl . 400 Nothing is returned Could not update the AccessControl of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to update the AccessControl for the specified Namespace . GetOwner() Returns the Owner's Trustee for a given Namespace . Http GET api/Tenants/{tenantId}/Namespaces/{namespaceId}/owner Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to access. Security An Owner's Trustee can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 Trustee Returns the Owner's Trustee of the specified Namespace . 400 Nothing is returned Could not retrieve the Owner's Trustee of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to get the Owner's Trustee of the specified Namespace . SetOwner() Changes the Owner's Trustee for a given Namespace . Http PUT api/Tenants/{tenantId}/Namespaces/{namespaceId}/owner Parameters [Required] string tenantId The identifier of the account to access. [Required] string namespaceId The identifier of the Namespace to access. [Required] [FromBody] Trustee newOwner The new Owner's Trustee of the Namespace . Security An Owner's Trustee can only be changed if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 Trustee Returns the new Owner's Trustee of the specified Namespace . 400 Nothing is returned Could not change the Owner's Trustee of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to change the Owner's Trustee of the specified Namespace ."
  },
  "Documentation/Management/Account_NamespaceTier.html": {
    "href": "Documentation/Management/Account_NamespaceTier.html",
    "title": "Namespace Tier",
    "keywords": "Namespace Tier An attribute that specifies Namespace performance. Properties For HTTP requests and responses, the NamespaceTier object has the following properties and JSON-serialized body: Property Type Description Id string GUID for this Namespace Tier. Description string Description of this Tier. ThroughputUnits int32 The number of throughput units associated with this Tier. StorageUnits int32 The number of Storage units associated with this Tier. { \"Id\": \"id\", \"Description\": \"description\", \"ThroughputUnits\": 0, \"StorageUnits\": 0 } GetNamespaceTier() Retrieves a Namespace tier associated with a specified id. Http GET api/NamespaceTiers/{namespaceTierId} Parameters [Required] string namespaceTierId The tier identifier for this request. Security A NamespaceTier can be retrieved by an Account Member. Returns Status Code Return Type Description 200 NamespaceTier A NamespaceTier object with the specified namespaceTierId. 400 Nothing is returned Could not retrieve the specified NamespaceTier due to missing or invalid input. GetAllNamespaceTiers() Retrieves a list of all available namespace tiers. Http GET api/NamespaceTiers Parameters This API call does not have any parameters. Security NamespaceTiers can be retrieved by an Account Member. Returns Status Code Return Type Description 200 [NamespaceTier] Returns a list of NamespaceTier objects."
  },
  "Documentation/Management/Account_Role.html": {
    "href": "Documentation/Management/Account_Role.html",
    "title": "Roles",
    "keywords": "Roles A Role is an entity that is used to manage access within an OSIsoft Cloud Services (OCS) account. By default, users have the Account Member role. There are five predefined Roles for OCS accounts. Check the user or client Role APIs for more information. Account Administrator Account Contributor Account Data Steward Account Viewer Account Member Properties For HTTP requests and responses, the Role object has the following properties and JSON-serialized body: Property Type Description Id string GUID for this Role. Generated by the server upon Creation. Name string Name of this Role. Description string Description of this Role. RoleScope RoleScope Scope of this Role. TenantId string GUID of Tenant for this Role, if this is a Account Role, null otherwise. CommunityId string GUID of Community for this Role, if this is a Community Role, null otherwise. RoleTypeId string GUID of Role Type for this Role, if this is a Account Role and is not a customer defined Role. { \"Id\": \"id\", \"Name\": \"name\", \"Description\": \"description\", \"RoleScope\": 0, \"TenantId\": \"tenantid\", \"CommunityId\": \"communityid\", \"RoleTypeId\": \"roletypeid\" } GetAccountRole() Retrieves an account Role based on the specified account Id and role Id. Http GET api/Tenants/{tenantId}/Roles/{roleId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string roleId The identifier of the Role to return. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Role Returns the Role with with specified Id roleId. 400 Nothing is returned Could not retrieve the specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve account Roles from this account. GetAccountRoles() Retrieves all account Roles for the specified Account Id. Http GET api/Tenants/{tenantId}/Roles Parameters [Required] string tenantId The identifier of the account to access. [Required] string skip Number of Roles to ignore. [Required] string count Number of Roles to be returned. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 [Role] Returns a list of Roles . 400 Nothing is returned Could not retrieve account Roles due to missing or invalid input. CreateAccountRole() Creates a new account Role . Http POST api/Tenants/{tenantId}/Roles Parameters [Required] string tenantId The identifier of the account to access. [Required] [FromBody] Role role The new Role to be created. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 201 Role Returns the new Role . 400 Nothing is returned Could not create a new Role due to missing or invalid input. 403 Nothing is returned Unauthorized to create the new Role in the specified account. UpdateAccountRole() Updates a Role by its Role Id. Http PUT api/Tenants/{tenantId}/Roles/{roleId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string roleId The identifier of the Role to update. [Required] [FromBody] Role role The updated Role for this request. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Role Returns the updated Role with Id roleId. 400 Nothing is returned Could not update specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to update the Role in the specified account. DeleteAccountRole() Deletes any Account scoped, non built-in Role by its Role Id. Http DELETE api/Tenants/{tenantId}/Roles/{roleId} Parameters [Required] string tenantId The identifier of the account to access. [Required] string roleId The identifier of the Role to delete. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 204 Nothing is returned The Role was deleted. 400 Nothing is returned Could not delete specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to delete the specified Role ."
  },
  "Documentation/Management/Account_RootAccessControl.html": {
    "href": "Documentation/Management/Account_RootAccessControl.html",
    "title": "Root Access Control",
    "keywords": "Root Access Control APIs to manage default access to entities governed by an AccessControl . GetRootNamespaceAcl() Retrieves the AccessControl that is used to authorize access to a Namespace if none is specified during creation. Http GET api/Tenants/{tenantId}/AccessControl/Namespaces Parameters [Required] string tenantId The identifier of the account to access. Security A root AccessControl can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 AccessControlList Returns the root AccessControl for Namespaces . 400 Nothing is returned Could not retrieve the root AccessControl for Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve the root AccessControl for Namespaces . SetRootNamespaceAcl() Modifies the AccessControl that is used to authorize access to a Namespace if none is specified during creation. Http PUT api/Tenants/{tenantId}/AccessControl/Namespaces Parameters [Required] string tenantId The identifier of the account to modify. [Required] [FromBody] AccessControlList newAccessControlList The new root AccessControl for Namespaces . Security A root AccessControl can only be modified if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 AccessControlList Returns the modified root AccessControl for Namespaces . 400 Nothing is returned Could not modify the root AccessControl for Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to change the root AccessControl for Namespaces ."
  },
  "Documentation/Management/Account_ServiceBlog.html": {
    "href": "Documentation/Management/Account_ServiceBlog.html",
    "title": "Service Blog",
    "keywords": "Service Blog APIs for CRUD operations on the Service Blog. GetByPage() Returns blog entries ordered by time posted. Http GET api/ServiceBlog/Entries Parameters [Required] string skip Number of blogs to skip for paging purposes. [Required] string count Number of blogs to count after skip for paging purposes. Security Any identity, including anonymous, can retrieve service blog entries. Returns Status Code Return Type Description 200 ([QiServiceBlogEntry], int32) Returns an response object including a list of blog entries and an int with the total number of entries."
  },
  "Documentation/Management/Account_Tenant.html": {
    "href": "Documentation/Management/Account_Tenant.html",
    "title": "Tenant",
    "keywords": "Tenant APIs to manage an OCS Customer Tenant Account. Properties For HTTP requests and responses, the Tenant object has the following properties and JSON-serialized body: Property Type Description Id string GUID for this Tenant. Generated by the server upon Creation. Same as AAD Id. CompanyName string Company Name of this Tenant. State TenantProvisioningState Current Tenant Provisioning State for this Tenant. Created DateTime Date and time this Tenant was added to OCS. LastUpdated DateTime Date this Tenant was last updated. Alias string Specifies a unique alias for this Tenant AzureAdTenantId string Specifies if this tenant uses Azure AD and its Tenant Id if so Icon string Gets or sets the base64 encoded PNG icon for this Account. Features [FeatureState] List of Feature States for this Tenant. Returned during get calls. { \"Id\": \"id\", \"CompanyName\": \"companyname\", \"State\": 0, \"Created\": \"0001-01-01T00:00:00\", \"LastUpdated\": \"0001-01-01T00:00:00\", \"Alias\": \"alias\", \"AzureAdTenantId\": \"azureadtenantid\", \"Icon\": \"icon\", \"Features\": [] } GetTenant() Retrieves a specific Tenant by ID. Http GET api/Tenants/{tenantId} Parameters [Required] string tenantId The identifier of the Tenant to retrieve. Security Authorized for Account Members of the specified Tenant . Returns Status Code Return Type Description 200 Tenant Returns the Tenant with the specified tenant ID. 400 Nothing is returned Could not retrieve the specified Tenant due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve this Tenant . TenantExists() Checks if a Tenant with a specific ID exists. Http HEAD api/Tenants/{tenantId} Parameters [Required] string tenantId The identifier of the Tenant for this request. Security Authorized for Account Members of the specified Tenant . Returns Status Code Return Type Description 204 Nothing is returned A Tenant with the specified ID exists. 400 Nothing is returned Could not check if the specified Tenant exists due to missing or invalid input. 404 Nothing is returned A Tenant with the specified ID was not found. UpdateTenant() Updates a specified Tenant object. Http PUT api/Tenants/{tenantId} Parameters [Required] string tenantId The identifier of the Tenant to update. [Required] [FromBody] Tenant tenant The updated details of the Tenant . Security Authorized for Account Administrators of the specified Tenant . Returns Status Code Return Type Description 200 Tenant Returns the updated Tenant . 400 Nothing is returned Could not update the Tenant due to missing or invalid input. 403 Nothing is returned Unauthorized to update the specified Tenant ."
  },
  "Documentation/Management/Account_TenantFeatureState.html": {
    "href": "Documentation/Management/Account_TenantFeatureState.html",
    "title": "Tenant Feature States",
    "keywords": "Tenant Feature States APIs for managing the feature states of an OCS Tenant . Properties For HTTP requests and responses, the TenantFeatureState object has the following properties and JSON-serialized body: Property Type Description TenantId string The identifier of the Tenant that the TenantFeatureState corresponds to. FeatureId string The identifier of the Service that the TenantFeatureState corresponds to. State int32 Current state of this TenantFeatureState. { \"TenantId\": \"tenantid\", \"FeatureId\": \"featureid\", \"State\": 0 } GetAll() Retrieves all FeatureStates for the specified Tenant . Http GET api/Tenants/{tenantId}/Features Parameters [Required] string tenantId The identifier of the account to access. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 [FeatureState] Returns a list of FeatureStates for the specified account. 400 Nothing is returned Unable to retrieve FeatureStates due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve FeatureStates for the specified account. Get() Retrieves a FeatureState with the specified ID from a Tenant . Http GET api/Tenants/{tenantId}/Features/{id} Parameters [Required] string tenantId The identifier of the account to access. [Required] string id The identifier of the FeatureState to retrieve. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 FeatureState Returns the FeatureState of the specified account. 400 Nothing is returned Unable to retrieve the FeatureState due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve the FeatureState of the specified account."
  },
  "Documentation/Management/Account_UserRole.html": {
    "href": "Documentation/Management/Account_UserRole.html",
    "title": "User Roles",
    "keywords": "User Roles User Roles authorize API requests made by users to various OCS features. Users can be assigned more than one Role , but all users have the Account Member role. The following are currently available User Roles : Account Administrator: Can add, edit, and remove users. Can also edit the permissions of existing users. Account Member: Can log in and access the OCS portal. Properties For HTTP requests and responses, the UserRole object has the following properties and JSON-serialized body: Property Type Description UserId string User Id. RoleId string Role Id. { \"UserId\": \"userid\", \"RoleId\": \"roleid\" } GetRolesForUser() Retrieves all Roles for the specified user. Http GET api/Tenants/{tenantId}/Users/{userId}/Roles Parameters [Required] string tenantId The identifier of the account in which the user belongs. [Required] string userId The identifier of the user whose roles will be retrieved. [Required] string skip Number of Roles to ignore. [Required] string count Number of Roles to return. Security Authorized for Account Administrators of the specified account and an Account Member's own Roles within the specified account. Returns Status Code Return Type Description 200 [Role] Returns a list of Role objects belonging to the user with the specified userId. 400 Nothing is returned Could not retrieve Roles due to missing or invalid input. 403 Nothing is returned Unauthorized to get Roles for the specified user. 404 Nothing is returned User not found in the specified Tenant . AddAccountRoleToUser() Adds a Role to the specified user. Http PUT api/Tenants/{tenantId}/Users/{userId}/Roles/{roleId} Parameters [Required] string tenantId The identifier for the account in which the user belongs. [Required] string userId The identifier of the user who will be given the Role . [Required] string roleId The identifier of the Role to be assigned. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Role Returns the added Role with the specified roleId. 400 Nothing is returned Could not add the Role to the specified user due to missing or invalid input. 403 Nothing is returned Unauthorized to add the Role to the specified user. 404 Nothing is returned A user with the specified userId was not found. RemoveRoleFromUser() Removes a Role from a user. Http DELETE api/Tenants/{tenantId}/Users/{userId}/Roles/{roleId} Parameters [Required] string tenantId The identifier for the account in which the user belongs. [Required] string userId The identifier of the user whose Role will be removed. [Required] string roleId The identifier of the Role to be removed. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 204 Nothing is returned The Role was removed from the specified user. 400 Nothing is returned Could not remove the Role due to missing or invalid input. 403 Nothing is returned Unauthorized to remove the Role from the specified user. 404 Nothing is returned A user with the specified userId was not found. ReplaceUserRoles() Replaces the Roles of a user with a new list of roles. Http PUT api/Tenants/{tenantId}/Users/{userId}/Roles Parameters [Required] string tenantId The identifier for the account in which the user belongs. [Required] string userId The identifier of the user whose roles will be replaced. [Required] [FromBody] [Role] roleList A list of Role objects to set as the Roles for the specified user. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Nothing is returned Returns the new list of all Role objects assigned to the specified user. 400 Nothing is returned Could not replace the Roles of the specified user due to missing or invalid input. 403 Nothing is returned Unauthorized to replace the Roles of the specified user. 404 Nothing is returned A user with the specified userId was not found."
  },
  "Documentation/Management/Consent.html": {
    "href": "Documentation/Management/Consent.html",
    "title": "Consent to OSIsoft Applications",
    "keywords": "Consent to OSIsoft Applications You have chosen to use your organization’s existing Azure Active Directory (Azure AD) to log in to OSIsoft Cloud Services (OCS). In order to proceed, you will need to complete the consent workflow. In this step, you will grant permissions for OSIsoft Cloud Services Identity to do the following: Sign in and read user profile (delegated permission) Below are the next steps required to complete your OCS account provisioning: Click on the link provided in the email. Note that you will need to log in as a user with the Global Administrator role on your Azure AD. Upon login, you’ll be prompted to grant consent for one application: OSIsoft Cloud Services Identity. Select the box \"Consent on behalf of the organization\" before clicking the consent button. OCS will notify the initial signup user via email once the account is ready."
  },
  "Documentation/Management/Management_Overview.html": {
    "href": "Documentation/Management/Management_Overview.html",
    "title": "Account Management",
    "keywords": "Account Management The Account Management API allows users to create, manage, and administer OSIsoft Cloud Services (OCS) accounts by assigning users, roles, and namespaces to their tenants. Through the API, users can manage access control used the OCS infrastructure. Generally, only administrators access the Account Management features. Administration functionality is also available from the OCS portal. Below is an index of the Account Management API: ClientRole Namespace NamespaceTier Role RootAccessControl Tenant TenantFeatureState UserRole ServiceBlog"
  },
  "Documentation/SequentialDataStore/Writing_Data_API.html": {
    "href": "Documentation/SequentialDataStore/Writing_Data_API.html",
    "title": "API calls for writing data",
    "keywords": "API calls for writing data Reading and writing data with the Qi Client Libraries is performed through the IQiDataService interface, which is accessed with the QiService.GetDataService( ) helper. InsertValueAsync() Inserts data into the specified stream. Throws an exception if data is already present at the index used in ‘item’. Syntax Task InsertValueAsync<T>(string streamId, T item); Http POST api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/InsertValue Content is serialized event of type T Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. T item The event to insert, where T is the type of the event and the stream Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes InsertValue throws an exception if an event already exists at the specified index. For HTTP requests, the message content (the event) must be serialized in JSON format. JSON objects consist of a series of name-value property pairs enclosed within brackets. .. _Introducing JSON: http://json.org/index.html You can serialize your data using one of many available JSON serializers available at Introducing JSON _. How the data is serialized depends upon the type of event you are inserting. For example, the following code shows a single WaveData event serialized as JSON. See the Qi code samples for the complete WaveData example. :: { \"Order\":2, \"Tau\":0.25722883666666846, \"Radians\":1.6162164471269089, \"Sin\":1.9979373673043652, \"Cos\":-0.090809010174665111, \"Tan\":-44.003064529862513, \"Sinh\":4.8353589272389, \"Cosh\":5.2326566823391856, \"Tanh\":1.8481468289554672 } InsertValuesAsync() Inserts items into the specified stream. Throws an exception if data is already present at an index used in one of the ‘items'. Syntax Task InsertValuesAsync<T>(string streamId, IList<T> items); Http POST api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/InsertValues Content is serialized list of events of type T Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. T items The list of events to insert, where T is the type of the stream and events Returns An IEnumerable of all behavior objects Notes InsertValuesAsync throws an exception if any index in items already has an event. If any individual index encounters a problem, the entire operation is rolled back and no insertions are made. The streamId and index that caused the issue are included in the error response. For HTTP requests, the values to be inserted must be formatted as a serialized JSON array of type T. JSON arrays are comma-delimited lists of type T enclosed within square brackets. The following code shows a list of three WaveData events that are properly formatted for insertion. See the Qi code samples for the complete WaveData example. [ { \"Order\":2, \"Tau\":0.25722883666666846, \"Radians\":1.6162164471269089, \"Sin\":1.9979373673043652, \"Cos\":-0.090809010174665111, \"Tan\":-44.003064529862513, \"Sinh\":4.8353589272389, \"Cosh\":5.2326566823391856, \"Tanh\":1.8481468289554672 }, { \"Order\":4, \"Tau\":0.25724560000002383, \"Radians\":1.6163217742567466, \"Sin\":1.9979277915696148, \"Cos\":-0.091019446679060964, \"Tan\":-43.901119254534827, \"Sinh\":4.8359100947709592, \"Cosh\":5.233166005842703, \"Tanh\":1.8481776000882766 }, { \"Order\":6, \"Tau\":0.25724560000002383, \"Radians\":1.6163217742567466, \"Sin\":1.9979277915696148, \"Cos\":-0.091019446679060964, \"Tan\":-43.901119254534827, \"Sinh\":4.8359100947709592, \"Cosh\":5.233166005842703, \"Tanh\":1.8481776000882766 } ] Security Allowed by administrator accounts PatchValueAsync() Modifies the specified stream event. PatchValue affects only the data item parameters that are included in the call. Syntax Task PatchValueAsync(string streamId, string selectExpression, T item); Http PATCH api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/PatchValue?select={selectExpression} Content is serialized patch property Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. string selectExpression CSV list of strings that indicates the event fields that will be changed in stream events. T item Object with index and new values to patch in the stream. Returns An IEnumerable of all behavior objects Notes PatchValue is used to modify the stream events. Only the values for fields specified in the SelectExpression are taken from the item and replaced (patched) in the stream using the item index. Security Allowed by administrator accounts Example var obj = new { TimeId = DateTime.UtcNow(), Value = 10 }; await _dataService.PatchValueAsync(streamId, “Value”, obj); PatchValuesAsync() Patches values of the selected fields for multiple events in the stream. Syntax Task PatchValuesAsync(string streamId, string selectExpression, IList<T> items); Http PATCH api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/PatchValues?select={selectExpression} Content is serialized list of patch property values Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. string selectExpression CSV list strings that indicates the event fields that will be changed in stream events. T items List which contain indexes and new values to patch in the stream. Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes PatchValues is used to patch the values of the selected fields for multiple events in the stream. Only the fields indicated in selectExpression are modified. The events to be modified are indicated by the index value of each member of the items collection. The individual events in items also hold the new values. PatchValues may be thought of as a series of PatchValue calls. If there is a problem patching any individual event, the entire operation is rolled back and the error will indicate the streamId and index of the problem. RemoveValueAsync() Removes the event at the index from the specified stream. Different overloads are available to make it easier to indicate the index where you want to remove a data event. This method throws an exception if there is no data at the specified index. Syntax Task RemoveValueAsync(string streamId, string index); Task RemoveValueAsync<T1>(string streamId, T1 index); Task RemoveValueAsync<T1, T2>(string streamId, Tuple<T1, T2> index); Http DELETE api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/RemoveValue?index={index} Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. index String representation of the index in the stream to be deleted. Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes Precision is taken into account when finding a value. If the index is a DateTime, use the round-trip format specifier: DateTime.ToString(“o”) . RemoveValuesAsync() Removes the event at each index from the specified stream. Different overloads are available to make it easier to indicate the index where you want to remove a data event. Syntax Task RemoveValuesAsync(string streamId, IEnumerable<string> index); Task RemoveValuesAsync<T1>(string streamId, IEnumerable<T1> index); Task RemoveValuesAsync<T1, T2>(string streamId, IEnumerable<Tuple<T1, T2>> index); Http DELETE api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/RemoveValues?index={index} Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. index List of indices at which to remove events in the stream Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes If any individual event fails to be removed, the entire RemoveValues operation is rolled back and no events are removed. The streamId and index that caused the issue are included in the error response. If you attempt to remove events at indexes that have no events, an exception is thrown. If this occurs, you can use the ‘RemoveWindowValues’ call to remove any events from a specified ‘window’ of indexes, which will not throw exceptions if no data is found. RemoveWindowValuesAsync() Removes a range of values at and between the given indices. Syntax Task RemoveWindowValuesAsync(string streamId, string startIndex, string endIndex); Task RemoveWindowValuesAsync<T1>(string streamId, T1 startIndex, T1 endIndex); Task RemoveWindowValuesAsync<T1, T2>(string streamId, Tuple<T1, T2> startIndex, Tuple<T1, T2> endIndex); Http DELETE api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/RemoveWindowValues?startIndex={startIndex}&endIndex={endIndex} Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. startIndex String representation of the starting index value. endIndex String representation of the ending index value Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes If any individual event fails to be removed, the entire operation is rolled back and no removes are done. ReplaceValueAsync() Writes an item over an existing event in the specified stream. Syntax Task ReplaceValueAsync<T>(string streamId, T item); Http PUT api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/ReplaceValue Content is serialized replacement object Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes Throws an exception if the stream does not have an event to be replaced at the specified index. Overloads are available to help you set the indexes you want removed. ReplaceValuesAsync() Writes items over existing events in the specified stream. Syntax Task ReplaceValuesAsync<T>(string streamId, IList<T> items); Http PUT api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/ReplaceValues Content is serialized list of replacement values Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. T items List of new items to replace existing items in the stream Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes Throws an exception if any index does not have a value to be replaced. If any individual event fails to be replaced, the entire operation is rolled back and no replaces are performed. The index (of the items IEnumerable) that caused the issue and the streamId are included in the error response. UpdateValueAsync() Writes item to the specified stream. Syntax Task UpdateValueAsync<T>(string streamId, T item); Http PUT api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/UpdateValue Content is serialized updated value Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. T item Event to write to the stream Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes UpdateValue performs an insert or a replace depending on whether an event already exists at the index in the stream. UpdateValuesAsync() Writes items to the specified stream. Syntax Task UpdateValuesAsync<T>(string streamId, IList<T> items); Http PUT api/{tenantId}/{namespaceId}/Streams/{streamId}/Data/UpdateValues Content is serialized list of updated values Parameters string tenantId The tenant identifier for the request string namespaceId The namespace identifier for the request. string streamId The stream identifier for the request. T items Events to write to the stream. Returns An IEnumerable of all behavior objects Security Allowed by administrator accounts Notes UpdateValues performs an insert or a replace depending on whether an event already exists at the item's indexes. If any item fails to write, the entire operation is rolled back and no events are written to the stream. The index (of the items IEnumerable) that caused the issue is included in the error response."
  }
}