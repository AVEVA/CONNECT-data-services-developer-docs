{
    "Documentation/Management/Management_Overview.html":  {
                                                              "href":  "Documentation/Management/Management_Overview.html",
                                                              "title":  "Account Management",
                                                              "keywords":  "Account Management The Account Management API allows users to create, manage, and administer OSIsoft Cloud Services (OCS) accounts by assigning users, roles, and namespaces to their tenants. Through the API, users can manage access control that is used in the OCS infrastructure. Generally, only administrators should have access to the Account Management features. Administration functionality is also available from the OCS portal. ClientRole Namespace Role RootAccessControl ServiceBlog Tenant TenantFeatureState UserRole"
                                                          },
    "Documentation/Management/Account_UserRole_1.html":  {
                                                             "href":  "Documentation/Management/Account_UserRole_1.html",
                                                             "title":  "User Roles",
                                                             "keywords":  "User Roles User Roles authorize API requests made by users to various OCS features. Users can be assigned more than one Role , but all users have the Account Member role. The following are currently available User Roles : Account Administrator: Can add, edit, and remove users. Can also edit the permissions of existing users. Account Member: Can log in and access the OCS portal. Properties For HTTP requests and responses, the UserRole object has the following properties and JSON-serialized body: Property Type Description UserId string User Id. RoleId string Role Id. { \"UserId\": \"userid\", \"RoleId\": \"roleid\" } Get Roles for User Retrieves all Roles for the specified user. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier of the account in which the user belongs. [Required] [FromRoute] string userId The identifier of the user whose roles will be retrieved. [Optional] [Default = \"0\"] [FromQuery] int32 skip Number of Roles to ignore. [Optional] [Default = \"100\"] [FromQuery] int32 count Number of Roles to return. [Optional] [Default = \"\"] [FromRoute] string query Unsupported parameter. Security Authorized for Account Administrators of the specified account and an Account Member\u0027s own Roles within the specified account. Returns Status Code Return Type Description 200 [Role] Returns a list of Role objects belonging to the user with the specified userId. 400 Nothing is returned Could not retrieve Roles due to missing or invalid input. 403 Nothing is returned Unauthorized to get Roles for the specified user. 404 Nothing is returned User not found in the specified Tenant . Replace User Roles Replaces the Roles of a user with a new list of roles. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier for the account in which the user belongs. [Required] [FromRoute] string userId The identifier of the user whose roles will be replaced. [Required] [FromBody] [Role] roleList A list of Role objects to set as the Roles for the specified user. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Nothing is returned Returns the new list of all Role objects assigned to the specified user. 400 Nothing is returned Could not replace the Roles of the specified user due to missing or invalid input. 403 Nothing is returned Unauthorized to replace the Roles of the specified user. 404 Nothing is returned A user with the specified userId was not found. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL."
                                                         },
    "Documentation/Management/Account_TenantFeatureState.html":  {
                                                                     "href":  "Documentation/Management/Account_TenantFeatureState.html",
                                                                     "title":  "Tenant Feature States",
                                                                     "keywords":  "Tenant Feature States APIs for managing the feature states of an OCS Tenant . Properties For HTTP requests and responses, the TenantFeatureState object has the following properties and JSON-serialized body: Property Type Description TenantId string The identifier of the Tenant that the TenantFeatureState corresponds to. FeatureId string The identifier of the Service that the TenantFeatureState corresponds to. State int32 Current state of this TenantFeatureState. { \"TenantId\": \"tenantid\", \"FeatureId\": \"featureid\", \"State\": 0 } Get All Tenant Feature States Retrieves all instances of FeatureState for the specified Tenant . Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Features Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 [FeatureState] Returns a list of FeatureState for the specified Tenant . 400 Nothing is returned Unable to retrieve FeatureState instances due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve FeatureState instances for the specified Tenant . Get Tenant Feature State Retrieves a FeatureState with the specified ID from a Tenant . Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Features/ Features  {id} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string id The identifier of the FeatureState to retrieve. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 FeatureState Returns the FeatureState of the specified account. 400 Nothing is returned Unable to retrieve the FeatureState due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve the FeatureState of the specified account."
                                                                 },
    "Documentation/Management/Account_Tenant.html":  {
                                                         "href":  "Documentation/Management/Account_Tenant.html",
                                                         "title":  "Tenants",
                                                         "keywords":  "Tenants APIs to manage an OCS Customer Tenant Account. Unlike Namespaces, Tenants are not scoped to a region. Account level information, such as Users and Clients, is stored in all supported regions for read-only purposes. Write operations for account management and identity management are only supported through the global base URL. Unsupported requests return a status of Method Not Allowed (405). The resolution is to utilize the global base URL ( https://dat-b.osisoft.com/ https:  dat-b.osisoft.com  ) for write operations that are not scoped to a namespace. Properties For HTTP requests and responses, the Tenant object has the following properties and JSON-serialized body: Property Type Description Id string GUID for this Tenant. Generated by the server upon Creation. Same as AAD Id. CompanyName string Company Name of this Tenant. State TenantProvisioningState Current Tenant Provisioning State for this Tenant. Created DateTime Date and time this Tenant was added to OCS. LastUpdated DateTime Date this Tenant was last updated. Alias string Specifies a unique alias for this Tenant Features [FeatureState] List of Feature States for this Tenant. Returned during get calls. { \"Id\": \"id\", \"CompanyName\": \"companyname\", \"State\": 0, \"Created\": \"0001-01-01T00:00:00\", \"LastUpdated\": \"0001-01-01T00:00:00\", \"Alias\": \"alias\", \"Features\": [] } Get Tenant Retrieves a specific Tenant by ID. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId} Parameters [Required] [FromRoute] string tenantId The identifier of the Tenant to retrieve. Security Authorized for Account Members of the specified Tenant . Returns Status Code Return Type Description 200 Tenant Returns the Tenant with the specified tenant ID. 400 Nothing is returned Could not retrieve the specified Tenant due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve this Tenant . Tenant Exists Checks if a Tenant with a specific ID exists. Http HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId} Parameters [Required] [FromRoute] string tenantId The identifier of the Tenant for this request. Security Authorized for Account Members of the specified Tenant . Returns Status Code Return Type Description 204 Nothing is returned A Tenant with the specified ID exists. 400 Nothing is returned Could not check if the specified Tenant exists due to missing or invalid input. 404 Nothing is returned A Tenant with the specified ID was not found. Update Tenant Updates a specified Tenant object. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId} Parameters [Required] [FromRoute] string tenantId The identifier of the Tenant to update. [Required] [FromBody] Tenant tenant The updated details of the Tenant . Security Authorized for Account Administrators of the specified Tenant . Returns Status Code Return Type Description 200 Tenant Returns the updated Tenant . 400 Nothing is returned Could not update the Tenant due to missing or invalid input. 403 Nothing is returned Unauthorized to update the specified Tenant . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Get Tenant Icon Returns an icon specified by its Tenant ID. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Icon Parameters [Required] [FromRoute] string tenantId The identifier of the Tenant for this request. Security Authorized for Account Members of the specified Tenant . Returns Status Code Return Type Description 200 string Returns the Base64 encoded PNG icon string of the specified Tenant . 400 Nothing is returned Could not retrieve the Tenant icon due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve the specified Tenant icon. Create or Update Tenant Icon Creates or updates the icon for a Tenant . Note that the icon size must be less than 65536 bytes. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Icon Parameters [Required] [FromRoute] string tenantId The Tenant identifier for this request. [Required] [FromBody] string icon The Base64 encoded PNG icon for the Tenant . Security Authorized for Account Administrators of the specified Tenant . Returns Status Code Return Type Description 200 string Returns the new/updated new updated Base64 encoded PNG icon string specified in the request. 400 Nothing is returned Could not create/update create update the Tenant icon due to missing or invalid input. 403 Nothing is returned Unauthorized to create/update create update the specified Tenant icon. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Delete Tenant Icon Deletes the icon for a Tenant . Http DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Icon Parameters [Required] [FromRoute] string tenantId The Tenant identifier for this request. Security Authorized for Account Administrators of the specified Tenant . Returns Status Code Return Type Description 204 string The Tenant icon was deleted. 400 Nothing is returned Could not delete the Tenant icon due to missing or invalid input. 403 Nothing is returned Unauthorized to delete the specified Tenant icon. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL."
                                                     },
    "Documentation/Management/Account_ServiceBlog.html":  {
                                                              "href":  "Documentation/Management/Account_ServiceBlog.html",
                                                              "title":  "Service Blog",
                                                              "keywords":  "Service Blog API\u0027s for reading entries posted on the Service Blog. Get Service Blog Entries Returns blog entries ordered by time posted. Http GET api/ api  v1/ v1  ServiceBlog/ ServiceBlog  Entries Parameters [Optional] [Default = \"0\"] [FromQuery] int32 skip Number of blogs to skip for paging purposes. [Optional] [Default = \"100\"] [FromQuery] int32 count Number of blogs to count after skip for paging purposes. Security Any identity, including anonymous, can retrieve service blog entries. Returns Status Code Return Type Description 200 [SdsServiceBlogEntry] Returns a list of blog entries. Get Service Blog Entry Returns a blog entry specified by ID. Http GET api/ api  v1/ v1  ServiceBlog/ ServiceBlog  Entries/ Entries  {id} Parameters [Required] [FromRoute] string id Identifier of the blog entry to retrieve. Security Any identity, including anonymous, can retrieve service blog entries. Returns Status Code Return Type Description 200 SdsServiceBlogEntry Returns the specified blog entry."
                                                          },
    "Documentation/DataViews/Sectioning.html":  {
                                                    "href":  "Documentation/DataViews/Sectioning.html",
                                                    "title":  "Sectioning",
                                                    "keywords":  "Sectioning The data items of a data view may be organized by grouping them. This is called sectioning . It is one way of producing a meaningful, consumable shape of data. Purpose of sectioning Without sectioning, all of the data items returned by a Query will appear side-by-side. If the view includes many data items, its data records will be enormous. The fields are also likely to be ambiguous. \" Distinguishing \" the items within each field set is one way to disambiguate the fields, but only one Field may be a distinguisher. What if multiple metadata Field s are required to fully describe each data item? The example below shows exactly that case: power inverters that are described by a Site, Meter, and number. Sectioning can organize the data items into shapes that are consumable and/or and or represent a physical asset. How it works To section a data view, specify one or more Field objects as the DataView \u0027s .Sectioners . Eligible sectioner fields Fields whose values come from data item FieldSource.Id , FieldSource.Name , FieldSource.Metadata , or FieldSource.Tags are eligible to be used as sectioners. Displaying the sectioner values If a data view has any sectioners specified, then a special type of field set is available: FieldSetSourceType.SectionValue . Its fields serve as robust pass-throughs to whatever the data view\u0027s sectioners currently are. It also avoids repetitive inclusion of sectioner values in the case where a section contains multiple data items. Uses of sectioning Sectioning can be used to separate the data items from each other, and to join different types of data items together. Separating data items from each other Separating the data items from each other makes the data view\u0027s data records smaller and more granular. It is also possible to produce shapes that mimic physical or logical assets. Example scenario For the following examples, assume a subsection of the example scenario \u0027s power inverter streams, produced by a Query value such as \"TypeId:docs-pi-inverter AND (Site:Rosemont OR Site:Winterthur)\" . This is to keep the example succinct. Site Meter Inverter Measurement Stream Id Rosemont Primary 0 Power In ROSE.Meter.Primary.Inverter.0.PwrIn Rosemont Primary 0 Power Out ROSE.Meter.Primary.Inverter.0.PwrOut Rosemont Primary 1 Power In ROSE.Meter.Primary.Inverter.1.PwrIn Rosemont Primary 1 Power Out ROSE.Meter.Primary.Inverter.1.PwrOut Winterthur Primary 0 Power In WINT.Meter.Primary.Inverter.0.PwrIn Winterthur Primary 0 Power Out WINT.Meter.Primary.Inverter.0.PwrOut Winterthur Secondary 0 Power In WINT.Meter.Secondary.Inverter.0.PwrIn Winterthur Secondary 0 Power Out WINT.Meter.Secondary.Inverter.0.PwrOut Example: No sectioning Let us start with a simple data view. It queries for the aforementioned streams, and includes the \"Value\" property of each stream. { \"Id\": \"quickstart\", \"Queries\": [ { Id: \"inverters\", Value: \"TypeId:docs-pi-inverter AND (Site:Rosemont OR Site:Winterthur)\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], } ] } Unfortunately, the initial result is not very usable. The fields are ambiguous (eight fields are simply labelled \"Value\"), and the size of each data record is tied to the number of inverter streams found by the query. Timestamp Value Value Value ... - ROSE.Meter.Primary.Inverter.0.PwrIn/Value ROSE.Meter.Primary.Inverter.0.PwrIn Value ROSE.Meter.Primary.Inverter.0.PwrOut/Value ROSE.Meter.Primary.Inverter.0.PwrOut Value ROSE.Meter.Primary.Inverter.1.PwrIn/Value ROSE.Meter.Primary.Inverter.1.PwrIn Value ... Example: Complete uniqueness, sectioning by data item id A simple way of disambiguating the data items is to section them by data item id. Here, we will do two things: Add data item id as a sectioner Include fields for metadata: Site, Meter, Inverter, Measurement. { \"Id\": \"quickstart\", \"Queries\": [ { Id: \"inverters\", Value: \"TypeId:docs-pi-inverter AND (Site:Rosemont OR Site:Winterthur)\" } ], \"Sectioners\": [ { \"Source\": \"Id\", \"Label\": \"{DistinguisherValue} {FirstKey}\" }, ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Fields\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Meter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Inverter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Measurement\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], } ] } The result is much closer to being usable. The records are no longer ambiguous. However, they do not mirror any physical or logical asset. Timestamp Site Meter Inverter Measurement Value - \"Rosemont\" \"Primary\" \"0\" \"Power In\" ROSE.Meter.Primary.Inverter.0.PwrIn/Value ROSE.Meter.Primary.Inverter.0.PwrIn Value - \"Rosemont\" \"Primary\" \"0\" \"Power Out\" ROSE.Meter.Primary.Inverter.0.PwrOut/Value ROSE.Meter.Primary.Inverter.0.PwrOut Value - \"Rosemont\" \"Primary\" \"1\" \"Power In\" ROSE.Meter.Primary.Inverter.1.PwrIn/Value ROSE.Meter.Primary.Inverter.1.PwrIn Value - \"Rosemont\" \"Primary\" \"1\" \"Power Out\" ROSE.Meter.Primary.Inverter.1.PwrOut/Value ROSE.Meter.Primary.Inverter.1.PwrOut Value - \"Winterthur\" \"Primary\" \"0\" \"Power In\" WINT.Meter.Primary.Inverter.0.PwrIn/Value WINT.Meter.Primary.Inverter.0.PwrIn Value - \"Winterthur\" \"Primary\" \"0\" \"Power Out\" WINT.Meter.Primary.Inverter.0.PwrOut/Value WINT.Meter.Primary.Inverter.0.PwrOut Value - \"Winterthur\" \"Secondary\" \"0\" \"Power In\" WINT.Meter.Secondary.Inverter.0.PwrIn/Value WINT.Meter.Secondary.Inverter.0.PwrIn Value - \"Winterthur\" \"Secondary\" \"0\" \"Power Out\" WINT.Meter.Secondary.Inverter.0.PwrOut/Value WINT.Meter.Secondary.Inverter.0.PwrOut Value Example: Data records that reflect real-world assets Instead of sectioning by data item id, let us section by metadata. We will: Use the Field s for Site, Meter, and Inverter metadata as the data view\u0027s .Sectioners Include a FieldSet of .SourceType FieldSetSourceType.SectionValue , with a Field to show each sectioner\u0027s value Use the Field for Measurement metadata as the data item FieldSet \u0027s .Distinguisher { \"Id\": \"quickstart\", \"Queries\": [ { Id: \"inverters\", Value: \"TypeId:docs-pi-inverter AND (Site:Rosemont OR Site:Winterthur)\" } ], \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Meter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Inverter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" }, { \"Source\": \"None\", \"Keys\": [ \"1\" ], \"Label\": \"{SectionerLabel}\" }, { \"Source\": \"None\", \"Keys\": [ \"2\" ], \"Label\": \"{SectionerLabel}\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Distinguisher\": { \"Source\": \"Metadata\", \"Keys\": [ \"Measurement\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], } ] } The resulting data mappings reflect the data on a per-inverter basis, mirroring the physical asset: Timestamp Site Meter Inverter Power In Value Power Out Value - \"Rosemont\" \"Primary\" \"0\" ROSE.Meter.Primary.Inverter.0.PwrIn/Value ROSE.Meter.Primary.Inverter.0.PwrIn Value ROSE.Meter.Primary.Inverter.0.PwrOut/Value ROSE.Meter.Primary.Inverter.0.PwrOut Value - \"Rosemont\" \"Primary\" \"1\" ROSE.Meter.Primary.Inverter.1.PwrIn/Value ROSE.Meter.Primary.Inverter.1.PwrIn Value ROSE.Meter.Primary.Inverter.1.PwrOut/Value ROSE.Meter.Primary.Inverter.1.PwrOut Value - \"Winterthur\" \"Primary\" \"0\" WINT.Meter.Primary.Inverter.0.PwrIn/Value WINT.Meter.Primary.Inverter.0.PwrIn Value WINT.Meter.Primary.Inverter.0.PwrOut/Value WINT.Meter.Primary.Inverter.0.PwrOut Value - \"Winterthur\" \"Secondary\" \"0\" WINT.Meter.Secondary.Inverter.0.PwrIn/Value WINT.Meter.Secondary.Inverter.0.PwrIn Value WINT.Meter.Secondary.Inverter.0.PwrOut/Value WINT.Meter.Secondary.Inverter.0.PwrOut Value Note that sectioning by Meter and Inverter overcomes the differences across Sites: not every site has a Secondary meter, and not every Meter has the same number of Inverters. This is not a problem. Associating data items with each other Another use of sectioning is to \"join\" the data items returned by different queries, such as adding weather data for each power inverter. Example: Adding weather data to the real-world assets Add a second Query for \"site weather\" Add a new FieldSet for the data items from the \"site weather\" query, with Field s for \"SolarRadiation\" and \"Temperature\" { \"Id\": \"quickstart\", \"Queries\": [ { Id: \"inverters\", Value: \"TypeId:docs-pi-inverter AND (Site:Rosemont OR Site:Winterthur)\" }, { Id: \"site weather\", Value: \"TypeId:docs-omf-weather* AND (Site:Rosemont OR Site:Winterthur)\" } ], \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Meter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Inverter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" }, { \"Keys\": [ \"1\" ], \"Label\": \"{SectionerLabel}\" }, { \"Keys\": [ \"2\" ], \"Label\": \"{SectionerLabel}\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Distinguisher\": { \"Source\": \"Metadata\", \"Keys\": [ \"Measurement\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], }, { \"SourceType\": \"DataItem\", \"QueryId\": \"site weather\", \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\", \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ] } ] } This \"join\" works because inverters and weather stations have common metadata: Site . Timestamp Site Meter Inverter Power In Value Power Out Value SolarRadiation Temperature - \"Rosemont\" \"Primary\" \"0\" ROSE.Meter.Primary.Inverter.0.PwrIn/Value ROSE.Meter.Primary.Inverter.0.PwrIn Value ROSE.Meter.Primary.Inverter.0.PwrOut/Value ROSE.Meter.Primary.Inverter.0.PwrOut Value WS_ROSE/SolarRadiation WS_ROSE SolarRadiation WS_ROSE/Temperature WS_ROSE Temperature - \"Rosemont\" \"Primary\" \"1\" ROSE.Meter.Primary.Inverter.1.PwrIn/Value ROSE.Meter.Primary.Inverter.1.PwrIn Value ROSE.Meter.Primary.Inverter.1.PwrOut/Value ROSE.Meter.Primary.Inverter.1.PwrOut Value WS_ROSE/SolarRadiation WS_ROSE SolarRadiation WS_ROSE/Temperature WS_ROSE Temperature - \"Winterthur\" \"Primary\" \"0\" WINT.Meter.Primary.Inverter.0.PwrIn/Value WINT.Meter.Primary.Inverter.0.PwrIn Value WINT.Meter.Primary.Inverter.0.PwrOut/Value WINT.Meter.Primary.Inverter.0.PwrOut Value WS_WINT/SolarRadiation WS_WINT SolarRadiation WS_WINT/AmbientTemperature WS_WINT AmbientTemperature - \"Winterthur\" \"Secondary\" \"0\" WINT.Meter.Secondary.Inverter.0.PwrIn/Value WINT.Meter.Secondary.Inverter.0.PwrIn Value WINT.Meter.Secondary.Inverter.0.PwrOut/Value WINT.Meter.Secondary.Inverter.0.PwrOut Value WS_WINT/SolarRadiation WS_WINT SolarRadiation WS_WINT/AmbientTemperature WS_WINT AmbientTemperature"
                                                },
    "Documentation/DataViews/Resolved_Data_View_API.html":  {
                                                                "href":  "Documentation/DataViews/Resolved_Data_View_API.html",
                                                                "title":  "Resolved Data View API",
                                                                "keywords":  "Resolved Data View API This portion of the overall data views API is the resources that resolve per-user for each data view. For a description of what this information is, and how to use it, see the documentation for resolved data views. Get Data Items by Query Gets the paged collection of data items that are the results of an individual query, and which are eligible for use in the current data view. A data view has a collection of zero or more queries. Each query has an identifier. Those identifiers are used here as part of the request path. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  DataItems/ DataItems  {queryId}?cache={cache}\u0026skip={skip}\u0026count={count} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier string queryId The Query identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. [optional] int skip An optional parameter representing the zero-based offset of the first data item to retrieve. If not specified, a default value of 0 is used. [optional] int count An optional parameter representing the maximum number of data items to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItems\u003cDataItem\u003e An object with a \"TimeOfResolution\" and a collection of \"Items\", the DataItem s that resolved. 403 Forbidden error You are not authorized for this operation 404 Not Found error The data view or query does not exist 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include one or more header values related to paging. Header Description FirstPage Hyperlink to the first page of results NextPage Hyperlink to the next page of results, if the results span into an additional page. Absence of this header indicates that there are no additional pages to be retrieved. Example response body HTTP 200 OK Content-Type: application/json application json { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"ResourceType\": \"Stream\", \"Id\": \"WS_BILT\", \"Name\": \"WS_BILT\", \"TypeId\": \"quickstart-omf-weather-gen1\", \"Tags\": [ \"Weather\", \"High Resolution\", \"Gen1\" ], \"Metadata\": { \"Site\": \"Biltmore\" }, \"DataItemFields\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"TypeCode\": \"DateTime\", \"IsKey\": true }, { \"Id\": \"SolarRadiation\", \"Name\": \"SolarRadiation\", \"TypeCode\": \"Int32\", \"IsKey\": false }, { \"Id\": \"Temperature\", \"Name\": \"Temperature\", \"TypeCode\": \"Double\", \"IsKey\": false } ] } ] } Get Ineligible Data Items by Query Gets the paged collection of data items that are the results of an individual query, but which are not eligible for use in the current data view. A common reason for ineligibility is that the item\u0027s index property is of a different type than the data view expects. A data view has a collection of zero or more queries. Each query has an identifier. Those identifiers are used here as part of the request path. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  IneligibleDataItems/ IneligibleDataItems  {queryId}?cache={cache}\u0026skip={skip}\u0026count={count} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier string queryId The Query identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. [optional] int skip An optional parameter representing the zero-based offset of the first data item to retrieve. If not specified, a default value of 0 is used. [optional] int count An optional parameter representing the maximum number of data items to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItems\u003cDataItem\u003e An object with a \"TimeOfResolution\" and a collection of \"Items\", the DataItem s that resolved. 403 Forbidden error You are not authorized for this operation 404 Not Found error The data view or query does not exist 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include one or more header values related to paging. Header Description FirstPage Hyperlink to the first page of results NextPage Hyperlink to the next page of results, if the results span into an additional page. Absence of this header indicates that there are no additional pages to be retrieved. Example response body HTTP 200 OK Content-Type: application/json application json { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"ResourceType\": \"Stream\", \"Id\": \"SOME_INELIGIBLE_STREAM\", \"Name\": \"Some Ineligible Stream\", \"TypeId\": \"type-with-different-index\", \"Tags\": [], \"Metadata\": { }, \"DataItemFields\": [ { \"Id\": \"Depth\", \"Name\": \"Depth\", \"TypeCode\": \"Double\", \"IsKey\": true }, { \"Id\": \"Density\", \"Name\": \"Density\", \"TypeCode\": \"Double\", \"IsKey\": false } ] } ] } Get Sections Gets the collection of Section s that resolved for a data view. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  Sections?cache={cache}\u0026skip={skip}\u0026count={count} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. [optional] int skip An optional parameter representing the zero-based offset of the first data item to retrieve. If not specified, a default value of 0 is used. [optional] int count An optional parameter representing the maximum number of data items to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItems\u003cSection\u003e An object with a \"TimeOfResolution\" and a collection of \"Items\", the Section s that resolved. 403 Forbidden error You are not authorized for this operation 404 Not Found error The data view does not exist 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include one or more header values related to paging. Header Description FirstPage Hyperlink to the first page of results NextPage Hyperlink to the next page of results, if the results span into an additional page. Absence of this header indicates that there are no additional pages to be retrieved. Example response body HTTP 200 OK Content-Type: application/json application json { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"Values\": [ \"Biltmore\" ], \"DataItems\": { \"Query1\": [ { \"ResourceType\": \"Stream\", \"Id\": \"WS_BILT\", \"Name\": \"WS_BILT\", \"TypeId\": \"quickstart-omf-weather-gen1\", \"Tags\": [ \"Weather\", \"High Resolution\", \"Gen1\" ], \"Metadata\": { \"Site\": \"Biltmore\" }, \"DataItemFields\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"TypeCode\": \"DateTime\", \"IsKey\": true }, { \"Id\": \"SolarRadiation\", \"Name\": \"SolarRadiation\", \"TypeCode\": \"Int32\", \"IsKey\": false }, { \"Id\": \"Temperature\", \"Name\": \"Temperature\", \"TypeCode\": \"Double\", \"IsKey\": false } ] } ] } } ] } Get Available Field Sets Gets the collection of field sets that are available for use in the data view, and which are not already included in the data view. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  AvailableFieldSets?cache={cache} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItems\u003cFieldSet\u003e An object with a \"TimeOfResolution\" and a collection of \"Items\", the FieldSets s that resolved and which are still available 403 Forbidden error You are not authorized for this operation 404 Not Found error The data view does not exist 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\", ], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Timestamp\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, ] } ] } Get Field Mappings Gets the collection of field mappings resolved for the data view. These show the exact data behind every field, for each data item, for each section. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  FieldMappings?cache={cache} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItems\u003cFieldMapping\u003e An object with a \"TimeOfResolution\" and a collection of \"Items\", the FieldMapping s resolved 403 Forbidden error You are not authorized for this operation 404 Not Found error The data view does not exist 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include one or more header values related to paging. Header Description FirstPage Hyperlink to the first page of results NextPage Hyperlink to the next page of results, if the results span into an additional page. Absence of this header indicates that there are no additional pages to be retrieved. Example response body HTTP 200 OK { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"Id\": \"Timestamp\", \"Label\": \"Timestamp\", \"FieldSetIndex\": 0, \"FieldIndex\": 0, \"DataMappings\": [ { \"TargetId\": \"\", \"TargetFieldKey\": \"\", \"TypeCode\": \"DateTime\" }, { \"TargetId\": \"\", \"TargetFieldKey\": \"\", \"TypeCode\": \"DateTime\" }, { \"TargetId\": \"\", \"TargetFieldKey\": \"\", \"TypeCode\": \"DateTime\" } ] }, { \"Id\": \"Temperature\", \"Label\": \"Temperature\", \"FieldSetIndex\": 1, \"FieldIndex\": 0, \"DataMappings\": [ { \"TargetId\": \"WS_BILT\", \"TargetFieldKey\": \"Temperature\", \"TypeCode\": \"Double\" }, { \"TargetId\": \"WS_ROSE\", \"TargetFieldKey\": \"Temperature\", \"TypeCode\": \"Double\" }, { \"TargetId\": \"WS_WINT\", \"TargetFieldKey\": \"AmbientTemperature\", \"TypeCode\": \"Double\" } ] }, ] } Get Statistics Gets statistics about the size and shape on how the data view resolved. Request GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  Resolved/ Resolved  Statistics?cache={cache} Request path parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request query parameters [optional] string cache \"Refresh\" to force the resource to re-resolve. \"Preserve\" to use cached information, if available. This is the default value. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK ResolvedItem\u003cStatistics\u003e Successfully retrieved data. 403 Forbidden error User is not authorized for this operation. 404 Not Found error The specified data view identifier is not found. 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"DataItemCount\": 24, \"SectionCount\": 2, \"FieldCount\": 12 }"
                                                            },
    "Documentation/DataViews/Resolved_Data_View.html":  {
                                                            "href":  "Documentation/DataViews/Resolved_Data_View.html",
                                                            "title":  "Resolved Data View",
                                                            "keywords":  "Resolved Data View Various information is available about how each data view resolves . This information describes exactly what data will be in the data view, where it comes from, and where it will appear. This is useful when defining a data view and when consuming it. General concepts What does resolving mean? A data view specifies .Queries to find data items, .Sectioners (optionally) to group those data items into sections, and .FieldSets to include fields of data into the data view. Resolving the data view means the data views engine executes those queries and computes how the resulting data items will form a data view. What resolved information is available? Data items, ineligible data items, and the sections they form - currently, SDS streams are the supported type of data item. Available field sets - fields which are present on the data items but not included in the data view Field mappings - details of the data behind each section of each field Statistics about how the view resolved These are available via the Resolved Data View API . The relevant object types are described below. Paged collections Some of this information is exposed as paged collections, which accept parameters controlling skip and count within the collection. Paged responses include a header called FirstPage , linking to the first page of results. If the results extend into an additional page, a NextPage header is included with a hyperlink to the next page. Using these hyperlinks is the recommended method of paging. Alternatively, constructing paging links by manually incrementing the skip is allowable, though in this case it is recommended to specify cache behavior of \"preserve\". How is a data view resolved? Data views resolve on a per user basis. Data views respect the permissions on underlying objects such as SDS Streams. If a user does not have read access to a particular stream in SDS, then that stream is not visible from data views. As a consequence, different users may see different collections of data items resolve for a data view. This is by design. When is a data view resolved? Each data view is resolved as needed for each user: upon request of any resolved information or data view data. In certain cases, a cached version is retrieved if available. This is evident when accessing the resolved information. It is contained in ResolvedItem\u003cT\u003e/ ResolvedItem\u003cT\u003e  ResolvedItems\u003cT\u003e container types which have a .TimeOfResolution property. Controlling the cache behavior By default: accessing resolved information will retrieve a cached version if available: preserve the cache requesting a first page of data will cause the data view to re-resolve: refresh the cache These defaults are overridable on each API call. See the Resolved Data View API and Getting Data for details. The defaults are intended to strike a balance between predictability and freshness. When retrieving the various resolved information that is available, you will not cause regeneration (and possible changes) simply by viewing the resolved information. This is useful when diagnosing a data view that is not returning the data you expect. Invalidation If the data view is modified, any cached information is reset. The data view will be re-resolved the next time that information is requested. No guarantee is made of the durability or lifespan of cached information. It may be reset by the system for maintenance reasons. Paging through data When using the Data API to page through data view data, the cache is automatically preserved on all pages after the first. This ensures consistency while paging through view data: if the view were re-resolved between pages, it might resolve differently (e.g. new streams just added to SDS) and return unpredictable results. The documentation on Getting Data describes how the paging token helps guarantee consistency. Object types ResolvedItems Holds a collection of items that were resolved at a specific time Property Type Details Items IReadOnlyList A collection of resolved objects TimeOfResolution DateTimeOffset The time the collection of items was resolved ResolvedItem Holds an item that was resolved at a specific time. Property Type Details Item T A resolved object TimeOfResolution DateTimeOffset The time the item was resolved DataItem Property Type Details Id string Unique identifier Name string Friendly name Description string Extended text description TypeId string The unique identifier of the data item\u0027s type ResourceType DataItemResourceType The resource type. See DataView documentation . Currently, the supported resource type is .Stream Tags IReadOnlyList Tag strings assigned to the data item Metadata IReadOnlyDictionary\u003cstring, string\u003e Metadata key-value pairs assigned to the data item DataItemFields IReadOnlyList Data fields DataItemResourceType enumeration Describes the resource type of a data item. Name Description Stream A stream from the Sequential Data Store DataItemField A field of a data item where values come from. Within a data item of resource kind .Stream , this corresponds to a stream property. Property Type Details Id string The data item field\u0027s unique identifier Name string The data item field\u0027s friendly name TypeCode SdsTypeCode The name of the field\u0027s data type IsKey bool True if the field is the primary index of the data item. False otherwise. Section A section of the data view. The overall collection of data items is divided into sections as a result of the .Sectioners fields defined on the DataView . Property Type Details Values IReadOnlyList This section\u0027s value of each .Sectioners field defined on the DataView DataItems IReadOnlyDictionary\u003cstring, IReadOnlyList \u003e The data items in this section FieldMapping Details on the provenance on every field of data: Property Type Details Id string Unique identifier Label string Friendly name FieldSetIndex int The position of the corresponding field set within the data view FieldIndex int The position of the corresponding field within its field set DataMappings IReadOnlyList Per-section details of what this field resolved to DataMapping Per-section details of the data that a FieldMapping targets: Property Type Details TargetId string The unique identifier of the target data item TargetFieldKey string The specific targeted part of the data item, if any. TypeCode SdsTypeCode The value type Statistics General statistics about how the data view resolved: Property Type Details DataItemCount int The total count of data items resolved in the data view SectionCount int The total count of sections resolved in the data view FieldCount int The total count of fields resolved in the data view"
                                                        },
    "Documentation/DataViews/Quick_Start_Get_Data_View_Data.html":  {
                                                                        "href":  "Documentation/DataViews/Quick_Start_Get_Data_View_Data.html",
                                                                        "title":  "Quick Start - Get Data View Data",
                                                                        "keywords":  "Quick Start - Get Data View Data This quick start is a hands-on tour of the main concepts behind consuming data view data. It is assumed that you are working with streams as described in the Example Scenario . The data views API uses the same authentication scheme as the Sequential Data Store. Step 1: Get data using defaults Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated Expected result An array of json values similar to: [ { \"Timestamp.0\": \"2019-10-21T18:00:00Z\", \"Id.1\": \"WS_WINT\", \"Name.2\": \"WS_WINT\", \"Tags.3\": \"Weather, High Resolution, Gen2\", \"Site.4\": \"Winterthur\", \"SolarRadiation.5\": 108, \"AmbientTemperature.6\": 1.0805517883941373, \"CloudCover.7\": 2, \"Temperature.8\": null, \"Id.9\": \"WS_ROSE\", \"Name.10\": \"WS_ROSE\", \"Tags.11\": \"Weather, Low Resolution, Gen1\", \"Site.12\": \"Rosecliff\", \"SolarRadiation.13\": 132, \"AmbientTemperature.14\": null, \"CloudCover.15\": null, \"Temperature.16\": 14.537369185607899, \"Id.17\": \"WS_BILT\", \"Name.18\": \"WS_BILT\", \"Tags.19\": \"Weather, High Resolution, Gen1\", \"Site.20\": \"Biltmore\", \"SolarRadiation.21\": 165, \"AmbientTemperature.22\": null, \"CloudCover.23\": null, \"Temperature.24\": 33.589619124193831, }, ... Step 2: Get data for a custom range Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here} Expected result An array of json values similar to: [ { \"Timestamp.0\": \"2019-10-21T18:00:00Z\", \"Id.1\": \"WS_WINT\", \"Name.2\": \"WS_WINT\", \"Tags.3\": \"Weather, High Resolution, Gen2\", \"Site.4\": \"Winterthur\", \"SolarRadiation.5\": 108, \"AmbientTemperature.6\": 1.0805517883941373, \"CloudCover.7\": 2, \"Temperature.8\": null, \"Id.9\": \"WS_ROSE\", \"Name.10\": \"WS_ROSE\", \"Tags.11\": \"Weather, Low Resolution, Gen1\", \"Site.12\": \"Rosecliff\", \"SolarRadiation.13\": 132, \"AmbientTemperature.14\": null, \"CloudCover.15\": null, \"Temperature.16\": 14.537369185607899, \"Id.17\": \"WS_BILT\", \"Name.18\": \"WS_BILT\", \"Tags.19\": \"Weather, High Resolution, Gen1\", \"Site.20\": \"Biltmore\", \"SolarRadiation.21\": 165, \"AmbientTemperature.22\": null, \"CloudCover.23\": null, \"Temperature.24\": 33.589619124193831, }, ... Step 3: Get data in a different format By default, data is returned in object-style json. Other formats are available: csv and table-style json, each with an optional header row. Action Resubmit the data query with an additional query parameter, \u0026form=csvh for csv-formatted data with a header row. GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here}\u0026form=csvh Expected result Rows of CSV values similar to: Timestamp.0,Id.1,Name.2,Tags.3,Site.4,SolarRadiation.5,AmbientTemperature.6,CloudCover.7,Temperature.8,Id.9,Name.10,Tags.11,Site.12,SolarRadiation.13,AmbientTemperature.14,CloudCover.15,Temperature.16,Id.17,Name.18,Tags.19,Site.20,SolarRadiation.21,AmbientTemperature.22,CloudCover.23,Temperature.24 2019-10-21T18:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,108,1.080551788,2,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,132,,,14.53736919,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,165,,,33.58961912 2019-10-21T20:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,109,2.501105722,3,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,139,,,14.76498991,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,157,,,32.41209639 ... Step 4: Get subsequent pages By default, each page includes 1000 records. If the requested data spans into another page, the response includes a hyperlink to the next page of data. Action Use the hyperlink in the NextPage header to request the next page. GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here}\u0026form=csvh\u0026continuationToken=MjAxOC0wMS0wMVQwMDowMDoxMVo_MD90Yk1OblE_QUxXcEZBP1VEdGxIMWJROG9z\u0026cache=preserve Expected result The next page of data: Timestamp.0,Id.1,Name.2,Tags.3,Site.4,SolarRadiation.5,AmbientTemperature.6,CloudCover.7,Temperature.8,Id.9,Name.10,Tags.11,Site.12,SolarRadiation.13,AmbientTemperature.14,CloudCover.15,Temperature.16,Id.17,Name.18,Tags.19,Site.20,SolarRadiation.21,AmbientTemperature.22,CloudCover.23,Temperature.24 2019-10-21T22:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,108,1.080551788,2,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,132,,,14.53736919,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,165,,,33.58961912 2019-10-22T00:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,109,2.501105722,3,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,139,,,14.76498991,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,157,,,32.41209639 ... Step 5: Recover from an invalid paging session It is possible, though unlikely, for the continuation token to become invalid during paging. When this happens, paging must be restarted from the first page. Action Use the hyperlink in the FirstPage header to request the first page. GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here}\u0026form=csvh\u0026cache=preserve Expected result The first page of data: Timestamp.0,Id.1,Name.2,Tags.3,Site.4,SolarRadiation.5,AmbientTemperature.6,CloudCover.7,Temperature.8,Id.9,Name.10,Tags.11,Site.12,SolarRadiation.13,AmbientTemperature.14,CloudCover.15,Temperature.16,Id.17,Name.18,Tags.19,Site.20,SolarRadiation.21,AmbientTemperature.22,CloudCover.23,Temperature.24 2019-10-21T18:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,108,1.080551788,2,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,132,,,14.53736919,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,165,,,33.58961912 2019-10-21T20:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,109,2.501105722,3,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,139,,,14.76498991,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,157,,,32.41209639 ... Step 6: Explore what each data field maps to Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  FieldMappings Expected result An array of field mappings: { \"TimeOfResolution\": \"2019-12-13T01:23:45Z\", \"Items\": [ { \"Id\": \"Timestamp.0\", \"Label\": \"Timestamp\", \"FieldSetIndex\": 0, \"FieldIndex\": 0, \"DataMappings\": [ { \"TargetId\": \"\", \"TargetFieldKey\": \"\", \"TypeCode\": \"DateTime\" }, { \"TargetId\": \"\", \"TargetFieldKey\": \"\", \"TypeCode\": \"DateTime\" } ] }, { \"Id\": \"Id.1\", \"Label\": \"Id\", \"FieldSetIndex\": 1, \"FieldIndex\": 0, \"DataMappings\": [ { \"TargetId\": \"WS_WINT\", \"TargetFieldKey\": \"\", \"TypeCode\": \"String\" }, { \"TargetId\": \"WS_ROSE\", \"TargetFieldKey\": \"\", \"TypeCode\": \"String\" } ] }, ... ] }"
                                                                    },
    "Documentation/DataViews/Quick_Start_Define_a_Data_View.html":  {
                                                                        "href":  "Documentation/DataViews/Quick_Start_Define_a_Data_View.html",
                                                                        "title":  "Quick Start - Define a Data View",
                                                                        "keywords":  "Quick Start - Define a Data View This quick start is a hands-on tour of the main concepts behind creating data views. It is assumed that you are working with streams as described in the Example Scenario . The data views API uses the same authentication scheme as the Sequential Data Store. Create a data view Creating a data view requires only an identifier, .Id . The data view does not accomplish anything yet, but it\u0027s a starting point. Action POST /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\" } Expected result A data view with very few properties populated: .Id , .Name , .IndexTypeCode (default: \"DateTime\" ), Shape (default: DataViewShape.Standard , which as a string is \"Standard\" ). HTTP 201 Created { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } The .Queries property is empty, [ ] . We will address that soon. Retrieve the data view To access the data view again, it is available via the GET verb: Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart Expected result HTTP 200 OK { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Add a query for data items Creating a data view begins with including some data items: today, those are SDS Streams. Action Use the result of the previous step as the starting point. All following steps will involve modifying the data view definition, or seeing the effects of those modifications. Add an item to the array of .Queries : { Id: \"weather\", Value:\"*weather*\" } PUT /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Expected result HTTP 204 No Content View items found by the query Data views resolve on a per user basis, executing the queries you defined. The results are available in several ???resolved??? resources. Action ??? Page through the data items found by the query GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  DataItems/ DataItems  weather Expected result An array of the data items matching the query, whose index type is \"DateTime\" (matching the Data View???s IndexTypeCode) HTTP 200 OK { \"TimeOfResolution\": \"(a timestamp in ISO8601 format)\", \"Items\": [ { \"ResourceType\": \"Stream\", \"Id\": \"WS_WINT\", \"Name\": \"WS_WINT\", \"TypeId\": \"quickstart-omf-weather-gen2\", \"Tags\": [ \"Weather\", \"High Resolution\", \"Gen2\" ], \"Metadata\": { \"Site\": \"Winterthur\" }, \"DataItemFields\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"TypeCode\": \"DateTime\", \"IsKey\": true }, { \"Id\": \"SolarRadiation\", \"Name\": \"SolarRadiation\", \"TypeCode\": \"Int32\", \"IsKey\": false }, { \"Id\": \"AmbientTemperature\", \"Name\": \"AmbientTemperature\", \"TypeCode\": \"Double\", \"IsKey\": false }, { \"Id\": \"CloudCover\", \"Name\": \"CloudCover\", \"TypeCode\": \"Int32\", \"IsKey\": false } ] }, { \"ResourceType\": \"Stream\", \"Id\": \"WS_ROSE\", \"Name\": \"WS_ROSE\", \"TypeId\": \"quickstart-omf-weather-gen1\", \"Tags\": [ \"Weather\", \"Low Resolution\", \"Gen1\" ], \"Metadata\": { \"Site\": \"Rosecliff\" }, \"DataItemFields\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"TypeCode\": \"DateTime\", \"IsKey\": true }, { \"Id\": \"SolarRadiation\", \"Name\": \"SolarRadiation\", \"TypeCode\": \"Int32\", \"IsKey\": false }, { \"Id\": \"Temperature\", \"Name\": \"Temperature\", \"TypeCode\": \"Double\", \"IsKey\": false } ] }, { \"ResourceType\": \"Stream\", \"Id\": \"WS_BILT\", \"Name\": \"WS_BILT\", \"TypeId\": \"quickstart-omf-weather-gen1\", \"Tags\": [ \"Weather\", \"High Resolution\", \"Gen1\" ], \"Metadata\": { \"Site\": \"Biltmore\" }, \"DataItemFields\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"TypeCode\": \"DateTime\", \"IsKey\": true }, { \"Id\": \"SolarRadiation\", \"Name\": \"SolarRadiation\", \"TypeCode\": \"Int32\", \"IsKey\": false }, { \"Id\": \"Temperature\", \"Name\": \"Temperature\", \"TypeCode\": \"Double\", \"IsKey\": false } ] } ] } Action ??? Page through the ineligible data items found by the query GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  IneligibleDataItems/ IneligibleDataItems  weather Expected result An array of the data items matching the query, but whose index type is not \"DateTime,\" and thus not eligible for inclusion in the data view. With the example streams, this collection is empty. HTTP 200 OK { \"TimeOfResolution\": \"(a timestamp in ISO 8601 format)\", \"Items\": [] } View fields available to include in the data view Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  AvailableFieldSets Expected result Two field sets: A field set of type ???Index??? with one field, representing an interpolated index. Data views only support interpolated index values at this time. In the future, if other retrieval modes are supported, a data item could be mapped here as the master index. A field set of type ???DataItem,??? pointing to query ???weather???. Assuming some data items were retrieved, this field set shows that attributes of the streams (id, name, tags) are available, as well as the values of all metadata keys and properties. HTTP 200 OK { \"TimeOfResolution\": \"(a timestamp in ISO 8601 format)\", \"Items\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Name\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Name\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\", ], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Timestamp\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ] } ] } Include some of the available fields At this point, if you query for data, the table is empty ??? because no fields have been included in the data view. Including fields is a deliberate action, albeit one that is intended to be easy. Action For ease, grab all of the field sets that are available. Set the Data View???s FieldSets property as the content of the AvailableFieldSets response. From the FieldSet for weather data items, remove the Field for the ???Timestamp??? property. It would be redundant. PUT /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Name\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Name\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\", ], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], }, ], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Expected Result HTTP 204 No Content Now, if we return to the available field sets, only ???Timestamp??? remains available but unused. Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  AvailableFieldSets Expected result One field set with one field: Timestamp, available but not used in the data view. { \"TimeOfResolution\": \"(a timestamp in ISO 8601 format)\", \"Items\": [ { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Timestamp\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ] } ] } Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here} Expected result An array of json values similar to: [ { \"Timestamp.0\": \"2019-10-21T18:00:00Z\", \"Id.1\": \"WS_WINT\", \"Name.2\": \"WS_WINT\", \"Tags.3\": \"Weather, High Resolution, Gen2\", \"Site.4\": \"Winterthur\", \"SolarRadiation.5\": 108, \"AmbientTemperature.6\": 1.0805517883941373, \"CloudCover.7\": 2, \"Temperature.8\": null, \"Id.9\": \"WS_ROSE\", \"Name.10\": \"WS_ROSE\", \"Tags.11\": \"Weather, Low Resolution, Gen1\", \"Site.12\": \"Rosecliff\", \"SolarRadiation.13\": 132, \"AmbientTemperature.14\": null, \"CloudCover.15\": null, \"Temperature.16\": 14.537369185607899, \"Id.17\": \"WS_BILT\", \"Name.18\": \"WS_BILT\", \"Tags.19\": \"Weather, High Resolution, Gen1\", \"Site.20\": \"Biltmore\", \"SolarRadiation.21\": 165, \"AmbientTemperature.22\": null, \"CloudCover.23\": null, \"Temperature.24\": 33.589619124193831, }, ... There was ambiguity in the field mapping identifiers, so the data views engine suffixed each field mapping id ordinally. The suffixing (to ensure uniqueness) is done for the sake of client behavior, as it is not expected that ambiguity is an acceptable outcome. The remaining steps show two approaches for disambiguating the content of a data view. Action ??? Want csv? Resubmit the data query with an additional query parameter, \u0026form=csvh GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here}\u0026form=csvh Expected result Rows of CSV values similar to: Timestamp.0,Id.1,Name.2,Tags.3,Site.4,SolarRadiation.5,AmbientTemperature.6,CloudCover.7,Temperature.8,Id.9,Name.10,Tags.11,Site.12,SolarRadiation.13,AmbientTemperature.14,CloudCover.15,Temperature.16,Id.17,Name.18,Tags.19,Site.20,SolarRadiation.21,AmbientTemperature.22,CloudCover.23,Temperature.24 2019-10-21T18:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,108,1.080551788,2,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,132,,,14.53736919,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,165,,,33.58961912 2019-10-21T20:00:00.0000000Z,WS_WINT,WS_WINT,\"Weather, High Resolution, Gen2\",Winterthur,109,2.501105722,3,,WS_ROSE,WS_ROSE,\"Weather, Low Resolution, Gen1\",Rosecliff,139,,,14.76498991,WS_BILT,WS_BILT,\"Weather, High Resolution, Gen1\",Biltmore,157,,,32.41209639 Step 7: Section the data view One way to disambiguate the data items is to ???section??? them, which amounts to partitioning them based on a value. For example, metadata:Site as the sectioner might yield sections of Biltmore, Rosecliff, and Winterthur, each containing the data items associated with that Site. You may use multiple sectioners. This is effectively ???section by X then Y then Z??? Sectioners are a property of the data view, and are an array of Field objects. This means the same Field objects contained in the available or included field sets may be reused directly as sectioners. Action Sectioning by metadata is likely to be most satisfying, but here, start with sectioning by data item id. In the DataView object, copy the field with { Source: ???Metadata???, Keys: [ \"Site\" ] } , and add it to the array of .Sectioners . PUT /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Name\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Name\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\", ], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], }, ], \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} Id\" } ], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Expected result HTTP 204 No Content Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here} Expected result Data that looks a bit different now. In table terms, the data table would be ultra-skinny instead of ultra-wide. HTTP 200 OK [ { \"Timestamp\": \"2019-10-21T18:00:00Z\", \"Id\": \"WS_BILT\", \"Name\": \"WS_BILT\", \"Tags\": \"Weather, High Resolution, Gen1\", \"Site\": \"Biltmore\", \"SolarRadiation\": 165, \"AmbientTemperature\": null, \"CloudCover\": null, \"Temperature\": 33.589619124193831 }, ... (rest of the values for Site:Biltmore), then ... { \"Timestamp\": \"2019-10-21T18:00:00Z\", \"Id\": \"WS_ROSE\", \"Name\": \"WS_ROSE\", \"Tags\": \"Weather, Low Resolution, Gen1\", \"Site\": \"Rosecliff\", \"SolarRadiation\": 132, \"AmbientTemperature\": null, \"CloudCover\": null, \"Temperature\": 14.537369185607899 }, ... (rest of the values for Site:Rosecliff), then ... { \"Timestamp\": \"2019-10-21T18:00:00Z\", \"Id\": \"WS_WINT\", \"Name\": \"WS_WINT\", \"Tags\": \"Weather, High Resolution, Gen2\", \"Site\": \"Winterthur\", \"SolarRadiation\": 108, \"AmbientTemperature\": 1.0805517883941373, \"CloudCover\": 2, \"Temperature\": null }, ... (rest of the values for Site:Winterthur) ] Note that in the real world, we???re not necessarily aiming for an ultra-skinny output, and the data views product doesn???t make any assumptions there. Include the sectioner field set In the case where each section contained multiple data items, having the section value repeated for every data item would be redundant. Return to the Available Field Sets, and now there is a solution for that redundancy Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Resolved/ Resolved  AvailableFieldSets Expected result A new field set is available, of SourceType: \"SectionerValue\" . HTTP 200 OK { \"TimeOfResolution\": \"2019-11-14T20:31:20.856826+00:00\", \"Items\": [ { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Timestamp\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ] } ] } This allows the sectioner value to appear as a single field, versus being repeated with every data item ???across the table.??? Notice that the fields there act as pointers, referring to e.g. DataView.Sectioners[0] and using its label. This indirection avoids confusing mismatches if you decide to try other fields as sectioners. Action Whatever field you???re using as the sectioner, remove it from the fields included in the data view, since it???s redundant now. Distinguish data items A different and complementary way of disambiguating the data items is to ???distinguish??? them within the field set. This is also useful for aligning data items across sections. Imagine if each site had an additional stream from a backup weather station: Timestamp Site Primary Temperature Primary SolarRadiation Backup Temperature Backup SolarRadiation Biltmore Rosecliff Winterthur The data views engine must be told how the streams align across sites. Here, it makes sense to align them by which measurement they represent: Primary or Backup . Action Move the field used as Sectioner over to being the ???.Distinguisher??? of the weather data items FieldSet . PUT /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Distinguisher\": { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Name\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Name\" }, { \"Source\": \"Tags\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ], }, ], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Expected result HTTP 204 No Content Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here} Expected result We???re back to a wide table, but the field ids are now distinct. The suggested/default suggested default values of the Available Fields??? .Label property includes {DistinguisherValue}, so if using those defaults, the impact of adding a Distinguisher is immediately clear. HTTP 200 OK [ { \"Timestamp\": \"2019-10-21T18:00:00Z\", \"Winterthur Id\": \"WS_WINT\", \"Winterthur Name\": \"WS_WINT\", \"Winterthur Tags\": \"Weather, High Resolution, Gen2\", \"Winterthur SolarRadiation\": 108, \"Winterthur AmbientTemperature\": 1.0805517883941373, \"Winterthur CloudCover\": 2, \"Winterthur Temperature\": null, \"Rosecliff Id\": \"WS_ROSE\", \"Rosecliff Name\": \"WS_ROSE\", \"Rosecliff Tags\": \"Weather, Low Resolution, Gen1\", \"Rosecliff SolarRadiation\": 132, \"Rosecliff AmbientTemperature\": null, \"Rosecliff CloudCover\": null, \"Rosecliff Temperature\": 14.537369185607899, \"Biltmore Id\": \"WS_BILT\", \"Biltmore Name\": \"WS_BILT\", \"Biltmore Tags\": \"Weather, High Resolution, Gen1\", \"Biltmore SolarRadiation\": 165, \"Biltmore AmbientTemperature\": null, \"Biltmore CloudCover\": null, \"Biltmore Temperature\": 33.589619124193831, }, ... Consolidate data fields There is a problem with this data view: the Gen1 Weather streams have a \"Temperature\" property but the Gen2 Weather streams have renamed it to \"AmbientTemperature\". The data view has fields for both, but for each stream \"Temperature\" or \"AmbientTemperature\" is null. This is undesirable since the fields are semantically identical and should not be separate fields in the data view. Find the Field associated with \"AmbientTemperature\". To the Field \u0027s .Keys array, add \"Temperature\": { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\", \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, Now that field will match to either \"Temperature\" or \"AmbientTemperature\". Remove the Field associated only with \"Temperature\". While we\u0027re at it, we can also remove the Fields associated with data item Id and Name. These are not providing any additional useful information. PUT /api/v1-preview/Tenants/{tenantId}/Namespaces/{namespaceId}/DataViews/quickstart  api v1-preview Tenants {tenantId} Namespaces {namespaceId} DataViews quickstart { \"Id\": \"quickstart\", \"Name\": \"quickstart\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Distinguisher\": { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, \"Fields\": [ { \"Source\": \"Tags\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\", \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, ], }, ], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Expected Result HTTP 204 No Content Action GET /   api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  quickstart/ quickstart  Data/ Data  Interpolated ?startIndex={your_val_here}\u0026endIndex={your_val_here}\u0026interval={your_val_here} Expected Result HTTP 200 OK [ { \"Timestamp\": \"2019-10-21T18:00:00Z\", \"Winterthur Tags\": \"Weather, High Resolution, Gen2\", \"Winterthur SolarRadiation\": 108, \"Winterthur AmbientTemperature\": 1.0805517883941373, \"Winterthur CloudCover\": 2, \"Rosecliff Tags\": \"Weather, Low Resolution, Gen1\", \"Rosecliff SolarRadiation\": 132, \"Rosecliff AmbientTemperature\": 14.537369185607899, \"Rosecliff CloudCover\": null, \"Biltmore Tags\": \"Weather, High Resolution, Gen1\", \"Biltmore SolarRadiation\": 165, \"Biltmore AmbientTemperature\": 33.589619124193831, \"Biltmore CloudCover\": null, } ... Further steps The API is designed to encourage trial-and-error. We encourage you to experiment with other ways to represent this data, and to incorporate information about the solar inverters at each site."
                                                                    },
    "Documentation/DataViews/Queries.html":  {
                                                 "href":  "Documentation/DataViews/Queries.html",
                                                 "title":  "Queries",
                                                 "keywords":  "Queries Queries determine what data items are included in a data view. Query Each Query must be uniquely identified with an .Id . The identifier should be meaningful. The query\u0027s results will be referenced by this identifier when you include fields in the data view. The query text is the same stream query syntax used by the Sequential Data Store. Property Type Optionality Default Details Id string Required Unique identifier. Used by FieldSet to link to the query\u0027s results Value string Optional null A query for streams, in SDS query syntax. A null or empty query will not match any streams. Using queries Querying streams of differing nature To include streams of completely different nature (like power inverters and weather stations), use one query for each. For example: \"Queries\": [ { \"Id\": \"inverter power measurements\", \"Value\": \"inverter:* AND measurement:power*\" }, { \"Id\": \"weather stations\", \"Value\": \"tags:weather\" }, ] Using separate queries means the streams will be available in separate field sets. This is good, because a power inverter has completely different fields versus a weather station. Querying streams of a common nature Streams that originate from an OSIsoft PI System represent only one fundamental measurement (e.g. Power in), unlike the more general case where a stream may represent several measurements (e.g. Temperature, Solar radiation, and Cloud cover). This means that multiple streams refer to the same physical or logical asset. In the example scenario, each power inverter is associated with two streams. It makes sense to structure our query around the physical asset, returning all \"power*\" measurements of all inverters: \"Queries\": [ { \"Id\": \"inverter power measurements\", \"Value\": \"inverter:* AND measurement:power*\" } ] These streams will be available in one single field set. This is good, because our data view can operate in terms of physical assets, and not be bound by how the stream data was recorded."
                                             },
    "Documentation/DataViews/Introduction_Get_Data_View_Data.html":  {
                                                                         "href":  "Documentation/DataViews/Introduction_Get_Data_View_Data.html",
                                                                         "title":  "Introduction - Get Data View Data",
                                                                         "keywords":  "Introduction - Get Data View Data Getting data from a data view is straightforward. If you want to understand more about the source behind each data field, that information is available too. This is an introduction to the recommended workflow for getting data. The Quick Start - Get Data View Data shows these concepts in action. For detailed information, see Getting Data and Data API . Specify first page parameters Complete the following to specify first page parameters: Specify the index range (start index and end index) and granularity of data to be retrieved. Specify the desired response format as csv, table-style json, or object-style json. The default is object-style json. Csv and table-style json are available with or without a header row. Specify the page size. Request any remaining pages Complete the following if data spans into additional page(s). The current page response will include an HTTP header linking to the next page. Follow the hyperlinks to retrieve the full requested dataset page by page, if the current page includes a NextPage hyperlink. Follow the FirstPage hyperlink in the event that it is necessary to restart the paging operation from the first page. [Optional] Investigate the source of the data For precise information about the source of each field\u0027s data, see the data view\u0027s resolved field mappings."
                                                                     },
    "Documentation/DataViews/Introduction_Define_a_Data_View.html":  {
                                                                         "href":  "Documentation/DataViews/Introduction_Define_a_Data_View.html",
                                                                         "title":  "Introduction - Define a data view",
                                                                         "keywords":  "Introduction - Define a data view This is an introduction to the recommended workflow for defining data views. The Quick Start - Define a Data View shows these concepts in action. For details, see Data View and Resolved Data View . Designing and tweaking a data view is expected to be an iterative process. You are not expected to \"get it right the first time,\" nor to be an expert at the streams available in the Sequential Data Store. Data views provide an interactive way to select, identify, and arrange the data you and your applications need. There are three main steps required to define a data view: Including data items (streams) Including specific data fields Arranging them within the data view. This is not a one-way street. You are likely to keep adjusting the data fields included in the view even after you have begun working on how the fields are arranged in the data view. Prerequisite: Create a data view Very little information is required to create a new data view. In fact, if you request that the system generate an identifier for the new data view, no information at all is necessary. However, it is recommended to specify a meaningful .Id , because the identifier cannot be changed late without recreating the data view. All other properties are modifiable. Include data items Complete the following to define data items to include in a data view: Define (or modify) .Queries for SDS streams to be included as data items in the data view. View the collection data items found by each query. Use a distinct query for each general type of data item, such as streams about assets and streams about the weather where each asset is located. You can return at any time to modify or add queries. Include specific data fields Complete the following to define data fields to include in a data view: View the information on which data fields resolve as available to include in the data view. Choose the fields you want, and add them to your data view\u0027s .FieldSets If your streams have slight variations in property naming (e.g. a property called either temperature or ambient_temperature ), combine fields so that they can match alternate values. You can return at any time to adjust which fields are included in the data view. Section and distinguish data items Section items globally You may wish to globally section , or group, the data items by some common factor (e.g. site or asset id). Complete the following to section data items in a data view: Define one or more fields as .Sectioners of the data view. Data items will be grouped by these fields. The available field sets now include field(s) that link to the sectioner values. Include the newly-available sectioner value fields in the data view, so those values are included in the data view data. Distinguishing items locally within a field set If a section contains multiple data items from the same query, you may wish to distinguish those data items so that they are not ambiguous and so they will be aligned across sections. Complete the following to distinguish data items within a field set: On the field set in question, assign a field as the .Distinguisher to tell the data items apart. Ensure that each field\u0027s label includes the {DistinguisherValue} token so the field labels are unique. The default field labels already include it. You can return at any time to change the sectioners and distinguishers."
                                                                     },
    "Documentation/DataViews/Data_View_API.html":  {
                                                       "href":  "Documentation/DataViews/Data_View_API.html",
                                                       "title":  "Data View API",
                                                       "keywords":  "Data View API The DataView API provides mechanisms to create, read, update, and delete data views. This is one portion of the whole data views API . For a description of the DataView object type, see the DataView documentation . Other sections of documentation describe how to secure data views by setting their ownership and permissions, and the corresponding API . Get Data View Returns the specified data view. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Response The response includes a status code and a response body. Status code Body Type Description 200 OK DataView The requested data view 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized to view the requested data view 404 Not Found error The specified data view identifier is not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK Content-Type: application/json application json { \"Id\": \"demo\", \"Name\": \"demo\", \"Description\": null, \"Queries\": [ { \"Id\": \"weather\", \"Value\":\"*weather*\" } ], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Get Data Views Returns a list of data views. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews?skip={skip}\u0026count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier [optional] int skip An optional parameter representing the zero-based offset of the first data view to retrieve. If not specified, a default value of 0 is used. [optional] int count An optional parameter representing the maximum number of data views to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and a body. Status code Body Type Description 200 OK DataView[] A page of data views. A response header, Total-Count , indicates the total size of the collection. 400 Bad Request error The request is not valid. See the response body for details 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include: Header Description Total-Count The total count of data views visible to the current user Example response body HTTP 200 OK Content-Type: application/json application json [ { \"Id\": \"demo view 1\", ... etc. }, { \"Id\": \"demo view 2\", ... etc. } ] Create Data View Create a new data view with a system-generated identifier. Request POST api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body A DataView object whose Id is null or unspecified. Example request body { \"Name\": \"demo\", \"Description\": \"demonstration\", \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Response The response includes a status code and a body. Status code Body Type Description 201 Created DataView The data view as persisted, including values for optional parameters that were omitted in the request. 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized to create a data view 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK Content-Type: application/json application json { \"Id\": \"c79630cc-21dc-483e-8b37-46880e92c456\", \"Name\": \"demo\", \"Description\": \"demonstration\", \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Get or Create Data View This call creates the specified data view. If a data view with the same id already exists, the existing data view is compared with the specified data view. If they are identical, a redirect ( 302 Found ) is returned with the Location response header indicating the URL where the stream may be retrieved using a Get function. If the data views do not match, the request fails with 409 Conflict . Request POST api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request body A DataView object whose Id matches the dataViewId in the URL. Example request body { \"Id\": \"demo2\", \"Name\": \"demo2\", \"Description\": \"demonstration 2\", \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Response The response includes a status code and, in most cases, a body. Status code Body Type Description 201 Created DataView The data view as persisted, including values for optional parameters that were omitted in the request. 302 Found (empty) The specified data view already exists. A response header, Location , indicates the URL where the data view may be retrieved with the GET verb 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized for this operation 409 Conflict error The specified data view conflicts with an existing data view that is not identical. To forcibly update the data view, see Create Or Update Data View 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 201 Created Content-Type: application/json application json { \"Id\": \"demo2\", \"Name\": \"demo2\", \"Description\": \"demonstration 2\", \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Create or Update Data View If a data view with the same id already exists, it is updated to the specified value. Otherwise, a new data view is created. Request PUT api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request body A DataView object whose Id matches the dataViewId in the URL. Example request body { \"Id\": \"demo\", \"Name\": \"demo\", \"Description\": \"demonstration\", \"Queries\": [], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Response The response includes a status code and, in some cases, a body. Status code Body Type Description 204 No Content (empty) Successfully created or updated the data view 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized for this operation 500 Internal Server Error error An error occurred while processing the request. See the response body for details Delete Data View Delete the data view with the specified id. Request DELETE api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Response The response includes a status code and, in some cases, a body. Status code Body Type Description 204 No Content (empty) Successfully deleted the data view 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized for this operation 404 Not Found error The specified data view identifier is not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details"
                                                   },
    "Documentation/DataViews/Data_Views_Overview.html":  {
                                                             "href":  "Documentation/DataViews/Data_Views_Overview.html",
                                                             "title":  "Data Views (Preview)",
                                                             "keywords":  "Data Views (Preview) Data views are a bridge between raw stream data and data-driven applications. A data view is a declarative query and shape for stream data. The ultimate goal is to deliver shaped data that is ready for consumption because it is normalized, aligned, and interpolated. Understanding how the data view resolves into content is important both for the designer and the consumer. Data views provide extensive visibility into what data is included. The concept of \"resolving\" a data view is when the data view\u0027s queries and logic are executed to determine the data view\u0027s exact schema and content. The collection(s) of streams that a data view acts on is the result of one or more queries. Streams (and any future data source types) are collectively known as data items . Values from the data items\u0027 properties can be included in the data view as fields , as can information about the data items (such as Id and Metadata). There are two primary means of controlling how the data items will be organized. One or more fields may be designated to section the data view, effectively grouping or partitioning the data items on some value. Within a set of fields, one field may be designated to distinguish or align the items. Data view data is available in several formats, including JSON and CSV, with a user-specified range and granularity. Data is obtained by querying the REST API. Defining and refining a data view There are several concepts and types used when defining data views. This is accomplished via the RESTful data views API . See the OCS documentation for greater detail on these concepts: Queries Field Sets Sectioning Data views are meant to be designed interactively. Each modification you make to a data view is likely to affect how the data view resolves into concrete information. The resolved API resources close the loop, showing you exactly what information is in the data view, and why. Each data view can be individually access-controlled using the access control API resources . Consuming a data view Data view data is available via queries to the RESTful data views data API resource . To understand the source of each data field, inspect how the data view resolved ."
                                                         },
    "Documentation/DataViews/Data_Views_API_Overview.html":  {
                                                                 "href":  "Documentation/DataViews/Data_Views_API_Overview.html",
                                                                 "title":  "Data Views API Overview",
                                                                 "keywords":  "Data Views API Overview The data views API is a RESTful surface for creating, securing, and consuming data views. The supported content type of request and response bodies is JSON unless otherwise noted. The API is comprised of four main areas: Data View API Resources for creating, reading, updating, and deleting /   DataViews Resolved Data View API For each /   DataViews/ DataViews  {dataViewId} , these resources show how the data view ./ .  Resolved/ Resolved  for your user context Data API For each /   DataViews/ DataViews  {dataViewId} , resources for getting the ./ .  Data/ Data  for a particular time range Access Control API For the /   DataViews collection, resources for reading and updating the default /   AccessControl . For each /   DataViews/ DataViews  {dataViewId} , resources for reading and updating its /   Owner and /   AccessControl"
                                                             },
    "Documentation/DataViews/Data_View.html":  {
                                                   "href":  "Documentation/DataViews/Data_View.html",
                                                   "title":  "Data View",
                                                   "keywords":  "Data View The DataView object is a declarative query and shape for stream data. This section describes the DataView object. For the corresponding API routes, see API documentation . At times, this section makes reference to ways the view resolves into further resources, such as the collection of data items found by each data item query. See the documentation of resolved resources for details. General concepts Identification A DataView must have a unique identifier. It may have a friendly name and description. If a friendly name is not specified, the identifier will be used as the data view\u0027s name. Including data items One or more queries determine the set of data items (such as SDS streams) that the data view will include. Each Query should represent a collection of like streams. To include streams that represent very different items, such as power inverters and weather stations, use separate queries. Including data fields Information from, or about, those data items must be included explicitly in the data view as Field s. By default, a data view includes no fields. The fields that are available for use are exposed as a \"resolved\" resource (AvailableFieldSets). It is recommended to use or adapt those fields instead of defining fields from scratch. Individual fields are organized into FieldSets . Each field set has a .SourceType that defines its role: FieldSetSourceType. Index - Provides the index field for the data view. A data view may have only one Index field set FieldSetSourceType. SectionerValue - Displays values that the view is sectioned by FieldSetSourceType. DataItem - Resolves for each data item from a particular query Organizing the data items Data items may be sectioned , which amounts to grouping or partitioning them by one or more field values. This is one way of producing a meaningful, consumable shape of data. Organizing the data fields Field sets and fields resolve in the order they are defined. They may be re-ordered. Within each section, a field set may be associated with multiple data items. It is often necessary to disambiguate these items. Items can be disambiguated by specifying a .Distinguisher . A distinguisher is a field that tells the data items apart within a section, such as the value of Measurement metadata (i.e., the data items are distinguished by what they measure). Distinguishing data items also allows the data views engine to \"align\" them across sections, since it is clear that streams measuring, e.g., Power Out are alike, and the streams measuring Power In are alike. Defining index type and default range Data views currently operate on timestamped data, which is data indexed by a DateTime property. This is reflected by the DataView\u0027s .IndexTypeCode , whose value must be \"DateTime\". Default values may be defined for the StartIndex, EndIndex, and/or and or Interval used when data view data is queried. DataView properties The following table lists the properties of a DataView: Property Type Optionality Default Details Id string Required Unique indentifier Name string Optional value of Id Friendly name Description string Optional null Longer description of the view Queries Query[] Optional* [ ] Queries for SDS Streams to include in the view. This is the starting point when defining a data view. Each Query should represent a collection of like streams. To include streams that represent very different items (e.g. solar inverters and weather), use separate queries. FieldSets FieldSet[] Optional* [ ] The sets of fields included in the data view. Often copied or adapted from the view\u0027s available field sets, which are exposed in a resolved resource. Sectioners Field[] Optional [ ] Fields by which the data items are partitioned/grouped. partitioned grouped. IndexTypeCode SdsTypeCode Optional DateTime The name of the index data type. DateTime is the currently supported index type. DefaultStartIndex string Optional null The default value of StartIndex used when querying the data view data, if none is specified then. DefaultEndIndex string Optional null The default value of EndIndex used when querying the data view data, if none is specified then. DefaultInterval string Optional null The default value of Interval used when querying the data view data, if none is specified then. Shape DataViewShape Optional Standard Data views may be set to resolve as standard shape or \"narrow\" shape. Narrow shape may be used when an invariant output schema is required. Rules for Id property Is not case sensitive, but case is preserved Can contain spaces Cannot contain forward slash (\"/\") (\" \") Can contain a maximum of 100 characters Related object types The following sections describe the classes and enumerations used when defining data views. Query A query for SDS Streams to include in the view. Property Type Optionality Default Details Id string Required Unique identifier. Used by FieldSet to link to the query\u0027s results Value string Optional null A query for streams, in SDS query syntax. A null or empty query will not match any streams. FieldSet A set of fields included in the data view, sharing a common role or source ( .SourceType ). One DataView is likely to include multiple FieldSet s. Property Type Optionality Default Details SourceType FieldSetSourceType Required The type of role fulfilled by the field set QueryId string Optional/Required Optional Required null Required when SourceType is DataItem. Must correspond to a query defined in this data view. Not applicable to other source types. Fields Field[] Optional [ ] Data fields to include in the data view. Often copied or adapted from the view\u0027s available field sets, which are exposed in a resolved resource. Distinguisher Field Optional null A field by which to tell the data items apart, within each section. FieldSetSourceType enumeration Defines the role or source type of a field set. Name Description Index Contains the field serving as index/key index key value of the data view\u0027s data SectionerValue Links to the fields defined as sectioners of the data view, thus staying in sync as sectioner fields are changed or shuffled. DataItem Each data item returned by a particular query Field Individual piece of information, such as a property of an SDS stream, or metadata of that stream. Property Type Optionality Default Details Source FieldSource Optional NotApplicable For fields of a DataItem-sourced FieldSet, identifies the source of the field\u0027s values. Some sources are used in conjunction with the Keys property (see below). Keys String[] Optional [ ] Used for certain FieldSources, e.g. to map to specific stream properties by id. If more than one key is specified, they are matched as exclusive-or. Label string Optional null Friendly name for the field. Certain tokens have special meaning: one of these, {DistinguisherValue}, is included in the suggested labels of AvailableFieldSets. Tokens that do not resolve are \"\" (empty string). Label is trimmed of whitespace when used to identify field mappings. FieldSource enumeration For fields that derive data from a data item (e.g. an SDS stream), the FieldSource enumeration specifies the part of that data item that a Field resolves to. Some sources require one or more .Keys to be specified on the field, such as PropertyId in which a key is the id of a desired property. Name Keyed Details NotApplicable No FieldSource is only applicable to FieldSets whose source type is DataItem Id No The id of the data item (stream) Name No The name of the data item (stream) PropertyId Yes Data from a stream property, found by id PropertyName Yes Data from a stream property, found by name Tags Yes Data item tags matching the collection provided Metadata Yes Value of the data item metadata, found by key SdsTypeCode enumeration SdsTypeCode enumeration is the name of a data type. It is used when defining a data view, where the only supported .IndexTypeCode is \"DateTime\". See Sds documentation for details. DataViewShape enumeration DataViewShape enumeration describes possible output shapes for a data view. Name Description Standard Fields are resolved into a shape similar to how they were defined. This is the recommended shape unless specific needs dictate. Narrow Fields are \"pivoted\" vertically, resulting in a view whose schema is independent of what data items (streams) are resolved by the data view."
                                               },
    "Documentation/Access_Control.html":  {
                                              "href":  "Documentation/Access_Control.html",
                                              "title":  "Role-based access control",
                                              "keywords":  "Role-based access control Within OCS, role-based access control to entities such as Namespaces and Streams, is managed using an Access Control List (ACL) and an Owner identity assigned to each entity. ACLs control access to entities based on their OCS Roles. Owners are granted access for all operations regardless of the contents of the ACL. Not all entities in the OCS system support role-based access control at this time, but the list will quickly grow and currently includes Namespaces and several unreleased entities. Access Control Lists Access Control Lists (ACLs) contain sets of Access Control Entries (ACEs), each with a trustee (reference to an identity, such as a role, user, or application), AccessType, and AccessRights. A user or application that attempts to read, write, delete, or manage access control of an entity assigned an ACL must be assigned a trustee that has AccessType set to Allowed for the AccessRight corresponding to that operation. AccessRights are the bitwise union of all of the access rights they encompass. For example, AccessRights 3 indicates that Read and Write access is permitted. Notes If an operation requires more than one access right then an identity can obtain those rights from multiple ACL entries. AccessType.Denied takes precedence over AccessType.Allowed . For example, a role that is assigned AccessType.Denied for AccessRights.All will receive a forbidden for all requests unless they are the owner of the entity. Roles are the only TrusteeType supported for AccessControlList ACEs. At least one role must be given Manage Permission access. TrusteeType TypeId User 1 Application 2 Role 3 AccessType TypeId Allowed 0 Denied 1 CommonAccessRightsEnum AccessRights int bitwise None 0 0000 Read 1 0001 Write 2 0010 Delete 4 0100 ManageAccessControl 8 1000 All 15 1111 AccessControlList The following code sample shows the structure and format for an ACL that gives Role 1 Read Access, Role 2 All access but denies Role 3 ManageAccessControl Access: Body Sample body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json \"AccessControlList\": { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ], } Owner Owner objects on OCS entities are used to grant access for all operations on the entity regardless of the entity\u0027s AccessControlList\u0027s AccessControlEntries. Note Currently, only Users and Applications are valid owners for entities. Trustee The following code samples shows the format and structure of an owner object: User Owner Body \"Owner\": { \"Type\": 1, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ObjectId\": \"44444444-4444-4444-4444-444444444444\" }, Application Owner Body \"Owner\": { \"Type\": 2, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ApplicationId\": \"66666666-6666-6666-6666-666666666666\" },"
                                          },
    "Documentation/SequentialDataStore/table_format.html":  {
                                                                "href":  "Documentation/SequentialDataStore/table_format.html",
                                                                "title":  "Table format",
                                                                "keywords":  "Table format A table is a convenient structure for analytics and display. The REST APIs for retrieving multiple events from the data store supports returning results in a table. The form variable can be set to specify a table or a table with headers. Table format can be applied to any read that returns multiple values and summaries. .NET public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } With values as follows: 4/ 4  1/ 1  2017 7:00:00 AM : Warning 0 4/ 4  1/ 1  2017 7:01:00 AM : Warning 1 4/ 4  1/ 1  2017 7:02:00 AM : Warning 2 4/ 4  1/ 1  2017 7:03:00 AM : Warning 3 4/ 4  1/ 1  2017 7:04:00 AM : Warning 4 4/ 4  1/ 1  2017 7:05:00 AM : Warning 5 4/ 4  1/ 1  2017 7:06:00 AM : Warning 6 4/ 4  1/ 1  2017 7:07:00 AM : Warning 7 4/ 4  1/ 1  2017 7:08:00 AM : Warning 8 4/ 4  1/ 1  2017 7:09:00 AM : Warning 9 The following is a request to retrieve values using the window parameters: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-04-01T07:00:00Z\u0026endIndex=2017-04-01T07:10:00Z The following response would be returned from the above code: Content-Type: application/ application  json [ { \"Time\":\"2017-04-01T07:00:00Z\", \"State\":1 }, { \"Time\":\"2017-04-01T07:01:00Z\", \"State\":1, \"Measurement\":1.0 }, { \"Time\":\"2017-04-01T07:02:00Z\", \"State\":1, \"Measurement\":2.0 }, { \"Time\":\"2017-04-01T07:03:00Z\", \"State\":1, \"Measurement\":3.0 }, { \"Time\":\"2017-04-01T07:04:00Z\", \"State\":1, \"Measurement\":4.0 }, { \"Time\":\"2017-04-01T07:05:00Z\", \"State\":1, \"Measurement\":5.0 }, { \"Time\":\"2017-04-01T07:06:00Z\", \"State\":1, \"Measurement\":6.0 }, { \"Time\":\"2017-04-01T07:07:00Z\", \"State\":1, \"Measurement\":7.0 }, { \"Time\":\"2017-04-01T07:08:00Z\", \"State\":1, \"Measurement\":8.0 }, { \"Time\":\"2017-04-01T07:09:00Z\", \"State\":1, \"Measurement\":9.0 } ] To retrieve the results in table format, add the form variable and specify table. GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-04-01T07:00:00Z\u0026endIndex=2017-04-01T07:10:00Z \u0026form=table Response Content-Type: application/ application  json { \"Name\":\"Simple\", \"Columns\":[ { \"Name\":\"Time\", \"Type\":\"DateTime\" }, { \"Name\":\"State\", \"Type\":\"Int32Enum\" }, { \"Name\":\"Measurement\", \"Type\":\"Double\" } ], \"Rows\":[ [ \"2017-04-01T07:00:00Z\", 1, 0.0 ], [ \"2017-04-01T07:01:00Z\", 1, 1.0 ], [ \"2017-04-01T07:02:00Z\", 1, 2.0 ], [ \"2017-04-01T07:03:00Z\", 1, 3.0 ], [ \"2017-04-01T07:04:00Z\", 1, 4.0 ], [ \"2017-04-01T07:05:00Z\", 1, 5.0 ], [ \"2017-04-01T07:06:00Z\", 1, 6.0 ], [ \"2017-04-01T07:07:00Z\", 1, 7.0 ], [ \"2017-04-01T07:08:00Z\", 1, 8.0 ], [ \"2017-04-01T07:09:00Z\", 1, 9.0 ] ] } To retrieve the results in table format with column headers, add the form variable and specify tableh . GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-04-01T07:00:00Z\u0026endIndex=2017-04-01T07:10:00Z \u0026form=tableh Response Content-Type: application/ application  json { \"Name\":\"Simple\", \"Columns\":[ { \"Name\":\"Time\", \"Type\":\"DateTime\" }, { \"Name\":\"State\", \"Type\":\"Int32Enum\" }, { \"Name\":\"Measurement\", \"Type\":\"Double\" } ], \"Rows\":[ [ \"Time\", \"State\", \"Measurement\" ], [ \"2017-04-01T07:00:00Z\", 1, 0.0 ], [ \"2017-04-01T07:01:00Z\", 1, 1.0 ], [ \"2017-04-01T07:02:00Z\", 1, 2.0 ], [ \"2017-04-01T07:03:00Z\", 1, 3.0 ], [ \"2017-04-01T07:04:00Z\", 1, 4.0 ], [ \"2017-04-01T07:05:00Z\", 1, 5.0 ], [ \"2017-04-01T07:06:00Z\", 1, 6.0 ], [ \"2017-04-01T07:07:00Z\", 1, 7.0 ], [ \"2017-04-01T07:08:00Z\", 1, 8.0 ], [ \"2017-04-01T07:09:00Z\", 1, 9.0 ] ] }"
                                                            },
    "Documentation/SequentialDataStore/Searching.html":  {
                                                             "href":  "Documentation/SequentialDataStore/Searching.html",
                                                             "title":  "Search in SDS",
                                                             "keywords":  "Search in SDS You can search for objects using texts, phrases and fields in Sequential Data Store (SDS). The REST APIs (or .NET client libraries methods GetStreamsAsync , GetTypesAsync , and GetStreamViewsAsync ) return items that match the search criteria within a given namespace. By default, the query parameter applies to all searchable object fields. Let\u0027s say a namespace contains the following streams: streamId Name Description stream1 tempA Temperature from DeviceA stream2 pressureA Pressure from DeviceA stream3 calcA Calculation from DeviceA values A GetStreamsAsync call with different queries will return below: Query string Returns temperature stream1 calc* stream3 DeviceA* stream1, stream2, stream3 humidity* nothing Requests GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=name:pump name:pressure\u0026orderby=name GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=name:pump name:pressure\u0026orderby=id asc GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=name:pump name:pressure\u0026orderby=name desc GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=name:pump name:pressure\u0026orderby=name desc\u0026skip=10\u0026count=20 Parameters string query An optional parameter representing the search criteria. If unspecified, returns all values. Can be used with skip , count and orderby . int skip An optional parameter representing the zero-based offset of the first SdsStream to retrieve. The number of matched items to skip over before returning. If unspecified, a default value of 0 is used. Use when more items match the search criteria than can be returned in a single call. int count An optional parameter representing the maximum number of SdsStreams to retrieve. If unspecified, a default value of 100 is used. The maximum value is 1,000. string orderby An optional parameter representing the sorted order in which SdsStreams are returned. Requires a field name ( orderby=name , for example). Default order is ascending ( asc ). Add desc for descending order ( orderby=name desc , for example). If unspecified, there is no sorting of results. .NET client libraries method If there are 175 streams that match the search criteria \"temperature\" in a single call for example, below will return the first 100 matches: _metadataService.GetStreamsAsync(query:\"temperature\", skip:0, count:100) If skip is set to 100, the following call will return the remaining 75 matches while skipping over the first 100: _metadataService.GetStreamsAsync(query:\"temperature\", skip:100, count:100) Search for streams Streams search is exposed through the REST API and the client libraries method GetStreamsAsync . For more information on stream properties, see Streams . Searcheable Properties Property Searchable Id Yes TypeId Yes Name Yes Description Yes Indexes No InterpolationMode No ExtrapolationMode No PropertyOverrides No Searcheable Child Resources Property Searchable Metadata * Yes Tags * Yes ACL No Owner No *Notes on metadata and tags: You can access stream metadata and tags through Metadata and Tags API respectively. Metadata and tags are associated with SdsStream objects and can be used as search criteria. See below for more information. Request Search for streams using the REST API and specifying the optional query parameter: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query={query}\u0026skip={skip}\u0026count={count} Parameters string query An optional parameter representing the search criteria. If unspecified, returns all values. Can be used with skip , count and orderby . int skip An optional parameter representing the zero-based offset of the first SdsStream to retrieve. If unspecified, a default value of 0 is used. Use when more items match the search criteria than can be returned in a single call. int count An optional parameter representing the maximum number of SdsStreams to retrieve. If unspecified, a default value of 100 is used. The maximum value is 1,000. .NET client libraries method GetStreamsAsync is used to search for and return streams. _metadataService.GetStreamsAsync(query:\"QueryString\", skip:0, count:100); The Stream fields valid for search are identified in the fields table located on the Streams page. Note that Stream Metadata has unique syntax rules. See How Searching Works: Stream Metadata . Search for types Types search is exposed through the REST API and the client libraries method GetTypesAsync . For more information on type properties, see Types . Searcheable Properties Property Searchable Id Yes Name Yes Description Yes SdsTypeCode No InterpolationMode No ExtrapolationMode No Properties Yes, with limitations* *Notes on Properties field: Name and Id of a type are included in its Properties field. Similarly, Name and Id of a nested type are included in its Properties. If there are two types with the same Properties, Name or ID, the search will return both types in the result. Request Search for types using the REST API and specifying the optional query parameter: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types?query={query}\u0026skip={skip}\u0026count={count} Parameters string query An optional parameter representing the search criteria. If unspecified, returns all values. Can be used with skip , count and orderby . int skip An optional parameter representing the zero-based offset of the first SdsType to retrieve. If unspecified, a default value of 0 is used. Use when more items match the search criteria than can be returned in a single call. int count An optional parameter representing the maximum number of SdsTypes to retrieve. If unspecified, a default value of 100 is used. The maximum value is 1,000. .NET client libraries method GetTypesAsync is used to search for and return types. _metadataService.GetTypesAsync(query:\"QueryString\", skip:0, count:100); Search for stream views Stream views search is exposed through the REST API and the client libraries method GetStreamViewsAsync . For more information on stream view properties, see Stream Views . Searcheable Properties Property Searchable Id Yes Name Yes Description Yes SourceTypeId Yes TargetTypeId Yes Properties Yes, with limitations* *Notes on Properties field: The Properties collection contains a list of SdsStreamViewProperty objects. The query will attempt to find a match on the SdsStreamViewProperty\u0027s Id, SourceTypeId, and TargetTypeId fields. The Properties collection of nested views will also be searched. See example below. Example You can search for ComplexView using the Id (\"NestedView\"), SourceTypeId , and TargetTypeId of NestedView but not its Description (\"An example of a nested view\"). { \"Id\":\"ComplexView\", \"Name\":\"ComplexView\", \"SourceTypeId\":\"ComplexSourceType\", \"TargetTypeId\":\"ComplexTargetType\", \"Description\":null, \"Properties\":[ { \"SourceId\":\"Value\", \"TargetId\":\"Value\", \"SdsStreamView\":{ \"Id\":\"NestedView\", \"SourceTypeId\":\"NestedType\", \"TargetTypeId\":\"NestedType\", \"Description\":\"An example of a nested view\", \"Properties\":[ { \"SourceId\":\"Value\", \"TargetId\":\"Value\" } ] } } ] } Request Search for stream views using the REST API and specifying the optional query parameter: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews?query={query}\u0026skip={skip}\u0026count={count} Parameters string query An optional parameter representing the search criteria. If unspecified, returns all values. Can be used with skip , count and orderby . int skip An optional parameter representing the zero-based offset of the first SdsStreamView to retrieve.If unspecified, a default value of 0 is used. Use when more items match the search criteria than can be returned in a single call. int count An optional parameter representing the maximum number of SdsStreamViews to retrieve. If unspecified, a default value of 100 is used. The maximum value is 1,000. .NET client libraries method GetStreamViewsAsync is used to search for and return stream views. _metadataService.GetStreamViewsAsync(query:\"QueryString\", skip:0, count:100); Tokenization Tokenization is the process of breaking a string sequence into pieces called tokens using specific characters to delimit tokens. User-specified queries are tokenized into search terms. How the query string is tokenized can affect search results. Delimit the terms with 1) a space, or 2) one or more punctuation characters ( * , ! , ? , . , for example) and a space. Query string followed without space by other punctuation characters does not trigger tokenization and is treated as part of the term. If your query has a wildcard ( * ) operator after a punctuation character, neither the punctuation nor the wildcard operator is tokenized. To specifically search for a term that has trailing punctuation, enclose the query in quotation marks to ensure that the punctuation is part of the query. See examples below: Term Tokenized Term Description Device.1 Device.1 The token includes .1 because there is no space between it and Device . Device!!1 Device!!1 The token includes !!1 because there is no space between it and Device . Device. Device . and the following space demarcates Device as the token term. Device!! Device !! and the following space demarcates Device as the token term. Device!* Device The token does not include !* because neither is tokenized if a wildcard operator follows a punctuation character. \"Device!\"* Device! Device! is the token because the string is enclosed in double quotes. Search operators You can use search operators in the query string to get more refined search results. Use operators AND , OR , and NOT in all caps. Operator Description AND AND operator. cat AND dog searches for both \"cat\" and \"dog\". OR OR operator. cat OR dog searches for either \"cat\" or \"dog\", or both. NOT NOT operator. cat NOT dog searches for \"cat\" or those without \"dog\". * Wildcard operator. Matches 0 or more characters. log* searches for those starting with \"log\" (\"log\", \"logs\" or \"logger\" for example.); ignores case. : Field-scoped query. Specifies a field to search. id:stream* searches for streams whose id field starts with \"stream\", but will not search other fields like name or description . See Field-scoping operator below. \" \" Quote operator. Scopes the search to an exact sequence of characters. While dog food (without quotes) searches for instances with \"dog\" or \"food\" anywhere in any order, \"dog food\" (with quotes) will only match instances that contain the whole string together and in that order. ( ) Precedence operator. motel AND (wifi OR luxury) searches for either \"wifi\" or \"luxury\", or \"wifi\" and \"luxury\" at the intersection of \"motel\". Examples Query string Matches field value Does not match field value mud AND log log mud mud log mud log mud OR log log mud mud log mutt look mud AND (NOT log) mud mud log mud AND (log OR pump*) mud log mud pumps mud bath name:stream* AND (description:pressure OR description:pump) The name starts with \"stream\" and the description has either \"pressure\" or \"pump\", or both. string Field-scoping ( : ) operator You can qualify the search to a specific field using the : operator. fieldname:fieldvalue Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=name:pump name:pressure .NET client libraries method GetStreamsAsync(query:\"name:pump name:pressure\"); Wildcard ( * ) operator You can use the wildcard operator ( * ) to complement an incomplete string. It can only be used once per token, unless there\u0027s one at the beginning and another at the end ( *Tank* but not *Ta*nk , Ta*nk* or *Ta*nk* , for example). Query string Matches field value Does not match field value log* log logger analog *log analog alog logg *log* analog alogger lop l*g log logg lake swimming ( * does not span across two tokens) Supported Not Supported * *log l*g log* *log* \"my log\"* *l*g* *l*g l*g* \"my\"*\"log\" Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=log* .NET client libraries method GetStreamsAsync(query:\"log*\"); Double quotes ( \"\" ) operator Tokenized search terms are delimited by whitespace and punctuation. To include these delimiters in a search, enclose them in double quotes. When using double quotes, the matching string must include the whole value of the field on the object being searched. Partial strings will not be matched unless wildcards are used. For example, if you\u0027re searching for a stream with description Pump three on unit five , a query \"unit five\" will not match the description, but *\"unit five\" will. Note that while wildcard ( * ) can be used either in or outside of quotes, it is treated as a string literal inside quotes. For example, you can search for \"dog food\"* to find a string that starts with \"dog food\", but if you search for \"dog food*\" , it will only match the value of \"dog food*\". Query string Matches field value Does not match field value \"pump pressure\" pump pressure pressure pressure pump pump pressure gauge \"pump pressure\"* pump pressure pump pressure gauge pressure pressure pump the pump pressure gauge *\"pump pressure\" pump pressure the pump pressure pressure pressure pump the pump pressure gauge *\"pump pressure\"* pump pressure pump pressure gauge the pump pressure gauge pressure pressure pump \"pump*pressure\" pump*pressure pump pressure the pump pressure gauge Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=\"pump pressure\" .NET client libraries method GetStreamsAsync(query:\"\\\\\"pump pressure\\\\\"\"); How search works with stream metadata Stream metadata behaves differently with search syntax rules described in the previous sections. Let\u0027s say that there\u0027s a namespace that has streams below with respective metadata key-value pairs: streamId Metadata stream1 { manufacturer, company } { serial, abc } stream2 { serial, a1 } stream3 { status, active } { second key, second value } Field-scoping ( : ) Operator A stream metadata key is only searchable in association with its value. This pairing is defined using the field-scoping ( : ) operator. myStreamMetadataKey:myStreamMetadataValue Metadata key is not searched if the operator ( : ) is missing in the query string: the search is then limited to metadata values along with other searchable fields in the stream. Query string Returns Description manufacturer:company stream1 Searches and returns stream1. company stream1 Searches only the metadata values due to lack of : operator and returns stream1. a* stream1, stream2, stream3 Searches the metadata values and returns all three streams. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=manufacturer:company .NET client libraries method GetStreamsAsync(query:\"manufacturer:company\"); Wildcard ( * ) Operator Wildcard ( * ) character can be used both in metadata keys and values with one caveat: wildcard ( * ) used in the field (left of field-scoped operator ( : )) will only search within stream metadata. Query string Returns Description manufa*turer:compan* stream1 Searches and returns stream1. ser*al:a* stream1, stream2 Searches and returns stream1 and stream2. s*:a* stream1, stream2, stream3 Searches and returns all three streams. Id:stream* stream1, stream2, stream3 Searches all fields and returns three streams. Id*:stream* nothing Wildcard in the field limits the search to metadata. Returns nothing because there is no metadata by that name that meets the criteria. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query=manufa*turer:compan* .NET client libraries method GetStreamsAsync(query:\"manufa*turer:compan*\");"
                                                         },
    "Documentation/SequentialDataStore/SDS_Views.html":  {
                                                             "href":  "Documentation/SequentialDataStore/SDS_Views.html",
                                                             "title":  "Stream Views",
                                                             "keywords":  "Stream Views An SdsStreamView provides a way to map Stream data requests from one data type to another. You can apply a Stream View to any read or GET operation. SdsStreamView is used to specify the mapping between source and target types. SDS attempts to determine how to map Properties from the source to the destination. When the mapping is straightforward, such as when the properties are in the same position and of the same data type, or when the properties have the same name, SDS will map the properties automatically. When SDS is unable to determine how to map a source property, the property is removed. If SDS encounters a target property that it cannot map to, the property is added and configured with a default value. To map a property that is beyond the ability of SDS to map on its own, you should define an SdsStreamViewProperty and add it to the SdsStreamView???s Properties collection. The following table shows the required and optional SdsStreamView fields. Fields that are not included are reserved for internal SDS use. See the Search in SDS topic regarding limitations on search. Property Type Optionality Searchable Details Id String Required Yes Identifier for referencing the stream view Name String Optional Yes Friendly name Description String Optional Yes Description text SourceTypeId String Required Yes Identifier of the SdsType of the SdsStream TargetTypeId String Required Yes Identifier of the SdsType to convert events to Properties IList\u003cSdsStreamViewProperty\u003e Optional Yes, with limitations* Property level mapping *Notes on Properties field : SdsStreamViewProperty objects are not searchable. Only the SdsStreamViewProperty\u0027s SdsStreamView is searchable by its Id, SourceTypeId, and TargetTypeId, which are used to return the top level SdsStreamView object when searching. This includes nested SdsStreamViewProperties. For more information, see search for stream views . Rules for the Stream View Identifier (SdsStreamView.Id) Is not case sensitive Can contain spaces Cannot contain forward slash (\"/\") (\" \") Can contain a maximum of 100 characters Properties/ Properties  SdsStreamViewProperty The SdsStreamView Properties collection provides detailed instructions for specifying the mapping of event properties. Each SdsStreamViewProperty in the Properties collection defines the mapping of an event???s property. SdsStreamView Properties are required only when property mapping is not straightforward. Additionally, if you do not want a type property mapped, it is not necessary to create an SdsStreamView property for it. The following table shows the required and optional SdsStreamViewProperty fields. Property Type Optionality Details SourceId String Required Identifier of the SdsTypeProperty from the source SdsType Properties list TargetId String Required Identifier of the SdsTypeProperty from the target SdsType Properties list SdsStreamView SdsStreamView Optional Additional mapping instructions for derived types The SdsStreamView field supports nested Properties. SdsStreamViewMap When an SdsStreamView is added, SDS defines a plan mapping. Plan details are retrieved as an SdsStreamViewMap. The SdsStreamViewMap provides a detailed Property-by-Property definition of the mapping. The following table shows the SdsStreamViewMap fields. The SdsStreamViewMap cannot be written to SDS, so required and optional have no meaning. Property Type Optionality Details SourceTypeId String Required Identifier of the SdsType of the SdsStream TargetTypeId String Required Identifier of the SdsType to convert events to Properties IList\u003cSdsStreamViewMapProperty\u003e Optional Property level mapping Properties/ Properties  SdsStreamViewMapProperty The SdsStreamViewMapProperty is similar to SdsStreamViewProperty but adds a Mode detailing one or more actions taken on the Property. The following table shows the SdsStreamViewMapProperty fields. The SdsStreamViewMap cannot be written; it can only be retrieved from SDS, so required and optional have no meaning. Property Type Details SourceTypeId String Identifier of the SdsType of the SdsStream TargetTypeId String Identifier of the SdsType to convert events to Mode SdsStreamViewMode Aggregate of actions applied to the properties. SdsStreamViewModes are combined via binary arithmetic SdsStreamViewMap SdsStreamViewMap Mapping for derived types The available SdsStreamViewModes are shown in the table below. Name Value Description None 0x0000 No action FieldAdd 0x0001 Add a property matching the specified SdsTypeProperty FieldRemove 0x0002 Remove the property matching the specified SdsTypeProperty FieldRename 0x0004 Rename the property matching the source SdsTypeProperty to the target SdsTypeProperty FieldMove 0x0008 Move the property from the location in the source to the location in the target FieldConversion 0x0016 Converts the source property to the target type InvalidFieldConversion 0x0032 Cannot perform the specified mapping Changing Stream Type Stream Views can be used to change the Type defining a Stream. You cannot modify the SdsType; types are immutable. But you can map a stream from its current type to a new type. To update a Stream\u0027s Type, define an SdsStreamView and PUT the stream view to the following: PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Type?streamViewId={streamViewId} For details, see Update Stream Type . Working with Stream Views when using .NET Using .NET When working in .NET, use the SDS Client libraries??? ISdsMetadataService. Given the following: public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType\u003cSimple\u003e(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; await config.GetOrCreateTypeAsync(simpleType); SdsStream simpleStream = await config.GetOrCreateStreamAsync(new SdsStream() { Id = \"Simple\", Name = \"Simple\", TypeId = simpleType.Id }); DateTime start = new DateTime(2017, 4, 1).ToUniversalTime(); for (int i = 0; i \u003c 10; i++) { Simple value = new Simple() { Time = start + TimeSpan.FromMinutes(i), State = State.Warning, Measurement = i }; await client.InsertValueAsync(simpleStream.Id, value); } IEnumerable\u003cSimple\u003e simpleValues = await client.GetWindowValuesAsync\u003cSimple\u003e(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\")); foreach (Simple value in simpleValues) Console.WriteLine($\"{value.Time}: {value.State}, {value.Measurement}\"); //    The example displays the following output: //    4 /   1 /   2017 7:00:00 AM: Warning, 0 //    4 /   1 /   2017 7:01:00 AM: Warning, 1 //    4 /   1 /   2017 7:02:00 AM: Warning, 2 //    4 /   1 /   2017 7:03:00 AM: Warning, 3 //    4 /   1 /   2017 7:04:00 AM: Warning, 4 //    4 /   1 /   2017 7:05:00 AM: Warning, 5 //    4 /   1 /   2017 7:06:00 AM: Warning, 6 //    4 /   1 /   2017 7:07:00 AM: Warning, 7 //    4 /   1 /   2017 7:08:00 AM: Warning, 8 //    4 /   1 /   2017 7:09:00 AM: Warning, 9 To map the Measurement property to a property in the same location of the same type, allow SDS to automatically determine mapping. public class Simple1 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public double Value { get; set; } } SdsType simple1Type = SdsTypeBuilder.CreateSdsType\u003cSimple1\u003e(); simple1Type.Id = \"Simple1\"; simple1Type.Name = \"Simple1\"; simple1Type = await config.GetOrCreateTypeAsync(simple1Type); SdsStreamView view = new SdsStreamView() { Id = \"StreamView\", Name = \"StreamView\", SourceTypeId = simpleType.Id, TargetTypeId = simple1Type.Id, }; view = await config.GetOrCreateStreamViewAsync(view); SdsStreamViewMap map = await config.GetStreamViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i \u003c map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable\u003cSimple1\u003e simple1Values = await client.GetWindowValuesAsync\u003cSimple1\u003e(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple1 value in simple1Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); //    The example displays the following output: //    Simple to Simple1 //    0) Time to Time - None //    1) State to State - None //    2) Measurement to Value - FieldRename //    //    4 /   1 /   2017 7:00:00 AM: Warning, 0 //    4 /   1 /   2017 7:01:00 AM: Warning, 1 //    4 /   1 /   2017 7:02:00 AM: Warning, 2 //    4 /   1 /   2017 7:03:00 AM: Warning, 3 //    4 /   1 /   2017 7:04:00 AM: Warning, 4 //    4 /   1 /   2017 7:05:00 AM: Warning, 5 //    4 /   1 /   2017 7:06:00 AM: Warning, 6 //    4 /   1 /   2017 7:07:00 AM: Warning, 7 //    4 /   1 /   2017 7:08:00 AM: Warning, 8 //    4 /   1 /   2017 7:09:00 AM: Warning, 9 A quick look at the SdsStreamViewMap shows that SDS was able to determine that mapping from Measurement to Value involved a rename. SDS can also determine mapping of properties of the same name but different type. Note that the location of the Measurement property is also different yet it is still mapped. public class Simple2 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public int Measurement { get; set; } public State State { get; set; } } SdsType simple2Type = SdsTypeBuilder.CreateSdsType\u003cSimple2\u003e(); simple2Type.Id = \"Simple2\"; simple2Type.Name = \"Simple2\"; simple2Type = await config.GetOrCreateTypeAsync(simple2Type); SdsStreamView view = new SdsStreamView() { Id = \"StreamView1\", Name = \"StreamView1\", SourceTypeId = simpleType.Id, TargetTypeId = simple2Type.Id, }; view = await config.GetOrCreateStreamViewAsync(view); SdsStreamViewMap map = await config.GetStreamViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i \u003c map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable\u003cSimple2\u003e simple2Values = await client.GetWindowValuesAsync\u003cSimple2\u003e(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple2 value in simple2Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Measurement}\"); //The   The example displays the following output: //    Simple to Simple2 //    0) Time to Time - None //    1) State to State - None //    2) Measurement to Measurement - FieldConversion //    //    4 /   1 /   2017 7:00:00 AM: Warning, 0 //    4 /   1 /   2017 7:01:00 AM: Warning, 1 //    4 /   1 /   2017 7:02:00 AM: Warning, 2 //    4 /   1 /   2017 7:03:00 AM: Warning, 3 //    4 /   1 /   2017 7:04:00 AM: Warning, 4 //    4 /   1 /   2017 7:05:00 AM: Warning, 5 //    4 /   1 /   2017 7:06:00 AM: Warning, 6 //    4 /   1 /   2017 7:07:00 AM: Warning, 7 //    4 /   1 /   2017 7:08:00 AM: Warning, 8 //    4 /   1 /   2017 7:09:00 AM: Warning, 9 The SdsStreamViewMap shows that the source, floating point Measurement is converted to the target, integer Measurement. When neither the field name nor field type and location match, SDS does not determine mapping. The source is eliminated and target is added and assigned the default value. public class Simple3 { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public int Value { get; set; } } SdsType simple3Type = SdsTypeBuilder.CreateSdsType\u003cSimple3\u003e(); simple3Type.Id = \"Simple3\"; simple3Type.Name = \"Simple3\"; simple3Type = await config.GetOrCreateTypeAsync(simple3Type); SdsStreamView view = new SdsStreamView() { Id = \"StreamView2\", Name = \"StreamView2\", SourceTypeId = simpleType.Id, TargetTypeId = simple3Type.Id, }; view = await config.GetOrCreateStreamViewAsync(view); SdsStreamViewMap map = await config.GetStreamViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i \u003c map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable\u003cSimple3\u003e simple3Values = await client.GetWindowValuesAsync\u003cSimple3\u003e(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple3 value in simple3Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); //The   The example displays the following output: //    Simple to Simple3 //    0) Time to Time - None //    1) State to State - None //    2) Measurement to -FieldRemove //    3) to Value -FieldAdd //    //    4 /   1 /   2017 7:00:00 AM: Warning, 0 //    4 /   1 /   2017 7:01:00 AM: Warning, 0 //    4 /   1 /   2017 7:02:00 AM: Warning, 0 //    4 /   1 /   2017 7:03:00 AM: Warning, 0 //    4 /   1 /   2017 7:04:00 AM: Warning, 0 //    4 /   1 /   2017 7:05:00 AM: Warning, 0 //    4 /   1 /   2017 7:06:00 AM: Warning, 0 //    4 /   1 /   2017 7:07:00 AM: Warning, 0 //    4 /   1 /   2017 7:08:00 AM: Warning, 0 //    4 /   1 /   2017 7:09:00 AM: Warning, 0 To map when SDS cannot determine mapping, use SdsStreamView Properties. SdsStreamView view = new SdsStreamView() { Id = \"SteamView3\", Name = \"StreamView3\", SourceTypeId = simpleType.Id, TargetTypeId = simple3Type.Id, Properties = new List\u003cSdsStreamViewProperty\u003e() { new SdsStreamViewProperty() { SourceId = \"Time\", TargetId = \"Time\" }, new SdsStreamViewProperty() { SourceId = \"State\", TargetId = \"State\" }, new SdsStreamViewProperty() { SourceId = \"Measurement\", TargetId = \"Value\" } } }; view = await config.GetOrCreateStreamViewAsync(view); SdsStreamViewMap map = await config.GetStreamViewMapAsync(view.Id); Console.WriteLine($\"{map.SourceTypeId} to {map.TargetTypeId}\"); for (int i = 0; i \u003c map.Properties.Count; i++) Console.WriteLine($\"\\t{i}) {map.Properties[i].SourceId} to {map.Properties[i].TargetId} - {map.Properties[i].Mode}\"); Console.WriteLine(); IEnumerable\u003cSimple3\u003e simple3Values = await client.GetWindowValuesAsync\u003cSimple3\u003e(simpleStream.Id, start.ToString(\"o\"), start.Add(TimeSpan.FromMinutes(10)).ToString(\"o\"), view.Id); foreach (Simple3 value in simple3Values) Console.WriteLine($\"{value.Time}: {value.State}, {value.Value}\"); //The   The example displays the following output: //    Simple to Simple3 //    0) Time to Time - None //    1) State to State - None //    2) Measurement to Value - FieldRename, FieldConversion //    //    4 /   1 /   2017 7:00:00 AM: Warning, 0 //    4 /   1 /   2017 7:01:00 AM: Warning, 1 //    4 /   1 /   2017 7:02:00 AM: Warning, 2 //    4 /   1 /   2017 7:03:00 AM: Warning, 3 //    4 /   1 /   2017 7:04:00 AM: Warning, 4 //    4 /   1 /   2017 7:05:00 AM: Warning, 5 //    4 /   1 /   2017 7:06:00 AM: Warning, 6 //    4 /   1 /   2017 7:07:00 AM: Warning, 7 //    4 /   1 /   2017 7:08:00 AM: Warning, 8 //    4 /   1 /   2017 7:09:00 AM: Warning, 9 Working with SdsStreamViews when not using .NET When working with Stream Views and not using .NET, either invoke HTTP directly or use some of the sample code. Both Python and JavaScript samples have SdsStreamView definitions. The JSON for a simple mapping between a source type with identifier Sample and a target type with identifier Sample1 would appear as follows. { \"Id\":\"StreamView\", \"Name\":\"StreamView\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple1\" } The SdsStreamViewMap would appear as follows. { \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple1\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"State\", \"TargetId\":\"State\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\", \"Mode\":4 } ] } SdsStreamView API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsStreamViews. When working in .NET convenient SDS Client libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService() helper, defines the available functions. See Stream Views for general SdsStreamView information. Get Stream View Returns the stream view corresponding to the specified streamViewId within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code and a response body. Response body The requested SdsStreamView. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\":\"StreamView\", \"Name\":\"StreamView\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"State\", \"TargetId\":\"State\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\" } ] } .NET Library Task\u003cSdsStreamView\u003e GetStreamViewAsync(string streamViewId); Get Stream View Map Returns the stream view map corresponding to the specified streamViewId within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  Map Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code and a response body. Response body The requested SdsStreamView. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\", \"Mode\":20 }, { \"SourceId\":\"State\", \"Mode\":2 }, { \"TargetId\":\"State\", \"Mode\":1 } ] } .NET Library Task\u003cSdsStreamViewMap\u003e GetStreamViewMapAsync(string streamViewId); Get Stream Views Returns a list of stream views within a given namespace. If specifying the optional search query parameter, the list of stream views returned will match the search criteria. If the search query parameter is not specified, the list will include all stream views in the Namespace. See Searching for information about specifying those respective parameters. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews?query={query}\u0026skip={skip}\u0026count={count}\u0026orderby={orderby} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string query An optional parameter representing a string search. See Searching for information about specifying the search parameter. int skip An optional parameter representing the zero-based offset of the first SdsStreamView to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsStreamViews to retrieve. If not specified, a default value of 100 is used. string orderby An optional parameter representing sorted order which SdsStreamViews will be returned. A field name is required. The sorting is based on the stored values for the given field (of type string). For example, orderby=name would sort the returned results by the name values (ascending by default). Additionally, a value can be provided along with the field name to identify whether to sort ascending or descending, by using values asc or desc , respectively. For example, orderby=name desc would sort the returned results by the name values, descending. If no value is specified, there is no sorting of results. Response The response includes a status code and a response body. Response body A collection of zero or more SdsStreamViews. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\":\"StreamView\", \"Name\":\"StreamView\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\" }, { \"Id\":\"StreamViewWithProperties\", \"Name\":\"StreamViewWithProperties\", \"SourceTypeId\":\"Simple\", \"TargetTypeId\":\"Simple3\", \"Properties\":[ { \"SourceId\":\"Time\", \"TargetId\":\"Time\" }, { \"SourceId\":\"State\", \"TargetId\":\"State\" }, { \"SourceId\":\"Measurement\", \"TargetId\":\"Value\" } ] } ] .NET Library Task\u003cIEnumerable\u003cSdsStreamView\u003e\u003e GetStreamViewsAsync(int skip = 0, int count = 100); Get or Create Stream View If a stream view with a matching identifier already exists, the stream view passed in is compared with the existing stream view. If the stream views are identical, a Found (302) status is returned and the stream view. If the stream views are different, the Conflict (409) error is returned. If no matching identifier is found, the specified stream view is created. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier. The identifier must match the SdsStreamView.Id field. Request body The request content is the serialized SdsStreamView. If you are not using the SDS client libraries, using JSON is recommended. Response The response includes a status code and a response body. Response body The newly created or matching SdsStreamView. .NET Library Task\u003cSdsStreamView\u003e GetOrCreateStreamViewAsync(SdsStreamView sdsStreamView); Create or Update Stream View Creates or updates the definition of a stream view. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Request body The request content is the serialized SdsStreamView. Response The response includes a status code and a response body. Response body The newly created or updated SdsStreamView. .NET Library Task CreateOrUpdateStreamViewAsync(SdsStreamView SdsStreamView); Delete Stream View Deletes a stream view from the specified tenant and namespace. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code. .NET Library Task DeleteStreamViewAsync(string streamViewId); Get Stream Views Access Control List Get the default ACL for the Stream Views collection. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  StreamViews Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body The default ACL for Stream Views .NET Library Task\u003cAccessControlList\u003e GetStreamViewsAccessControlListAsync(); Update Stream Views Access Control List Update the default ACL for the Stream Views collection. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  StreamViews Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateStreamViewsAccessControlListAsync(AccessControlList viewsAcl); Get Stream View Access Control List Get the ACL of the specified stream view. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code and a response body. Response Body The ACL for the specified stream view .NET Library Task\u003cAccessControlList\u003e GetStreamViewAccessControlListAsync(string streamViewId); Update Stream View Access Control List Update the ACL of the specified stream view. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateStreamViewAccessControlListAsync(string streamViewId, AccessControlList viewAcl); Get Stream View Owner Get the Owner of the specified stream view. For more information on Owners, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code and a response body. Response Body The Owner for the specified stream view .NET Library Task\u003cTrustee\u003e GetStreamViewOwnerAsync(string streamViewId); Update Stream View Owner Update the Owner of the specified stream view. For more information on Owners, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Request body Serialized Owner Response The response includes a status code. .NET Library Task UpdateStreamViewOwnerAsync(string streamViewId, Trustee viewOwner); Get Stream View Access Rights Gets the Access Rights associated with the specified stream view for the requesting identity. For more information on Access Rights, see Access Control . Request GET api/ api  v1/ v1  /   Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  StreamViews/ StreamViews  {streamViewId}/ {streamViewId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamViewId The stream view identifier Response The response includes a status code and a response body. Response Body The Access Rights of the specified stream view for the requesting identity. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [\"Read\", \"Write\"] .NET Library Task\u003cstring[]\u003e GetStreamViewAccessRightsAsync(string streamViewId);"
                                                         },
    "Documentation/SequentialDataStore/Reading_Data.html":  {
                                                                "href":  "Documentation/SequentialDataStore/Reading_Data.html",
                                                                "title":  "Read data",
                                                                "keywords":  "Read data The .NET and REST APIs provide programmatic access to read and write data. This section identifies and describes the APIs used to read Streams data. Results are influenced by Types , Stream Views , Filter expressions , and Table format . If you are working in a .NET environment, convenient SDS Client Libraries are available. The ISdsDataService interface, which is accessed using the SdsService.GetDataService() helper, defines the functions that are available. Single Stream Reads The following methods for reading a single value are available: Get First Value returns the first value in the stream. Get Last Value returns the last value in the stream. Find Distinct Value returns a value based on a starting index and search criteria. In addition, the following methods support reading multiple values: Get Values retrieves a collection of stored values based on the request parameters. Get Interpolated Values retrieves a collection of stored or calculated values based on the request parameters. Get Summaries retrieves a collection of evenly spaced summary intervals based on a count and specified start and end indexes. Get Sampled Values retrieves a collection of sampled data based on the request parameters. All single stream reads are HTTP GET actions. Reading data involves getting events from streams. The base reading URI from a single stream is as follows: api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Bulk Reads SDS supports reading from multiple streams in one request. The following method for reading data from multiple streams is available: Join Values retrieves a collection of events across multiple streams and joins the results based on the request parameters. Multi-stream reads can be HTTP GET or POST actions. The base reading URI for reading from multiple streams is as follows: api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response Format Supported response formats include JSON, verbose JSON, and SDS. The default response format for SDS is JSON, which is used in all examples in this document. Default JSON responses do not include any values that are equal to the default value for their type. Verbose JSON responses include all values, including defaults, in the returned JSON payload. To specify verbose JSON return, add the header Accept-Verbosity with a value of verbose to the request. To specify SDS format, set the Accept header in the request to application/ application  sds . Indexes and reading data Most read operations take at least one index as a parameter. Indexes may be specified as strings, or, when using the SDS Client libraries, the index may be passed as-is to read methods that take the index type as a generic argument. Additional details about working with indexes can be found on the Indexes page. Read Characteristics When data is requested at an index for which no stored event exists, the read characterisitics determine whether the result is an error, no event, interpolated event, or extrapolated event. The combination of the type of the index and the interpolation and extrapolation modes of the SdsType and the SdsStream determine the read characteristics. Interpolation Interpolation determines how a stream behaves when asked to return an event at an index between two existing events. InterpolationMode determines how the returned event is constructed. SDS provides multiple ways to set the interpolation mode to get the desired behavior. The table below lists InterpolationModes: Mode Enumeration value Operation Default 0 The default InterpolationMode is Continuous Continuous 0 Returns interpolated data using previous and next index values StepwiseContinuousLeading 1 Returns the data from the previous index StepwiseContinuousTrailing 2 Returns the data from the next index Discrete 3 No event is returned ContinuousNullableLeading 4 Returns interpolated data or data from the previous index if either of the surrounding indexes has a null value ContinuousNullableTrailing 5 Returns interpolated data or data from the trailing index if either of the surrounding indexes has a null value Note that Continuous cannot return values for type properties that cannot be interpolated, such as when the type property is not numeric. The table below describes how the Continuous InterpolationMode affects properties that occur between data in a stream: InterpolationMode = Continuous or Default Property Type Result for a property for an index between data in a stream Comment Numeric Types Interpolated* Rounding is done as needed for integer types Time related Types Interpolated DateTime, DateTimeOffset, TimeSpan Nullable Types Interpolated** Limited support for nullable numeric types Array and List Types Default value String Type Default value Boolean Type Returns value of nearest index Enumeration Types Returns Enum value at 0 This may have a value for the enumeration GUID Default value Version Default value IDictionary or IEnumerable Default value Dictionary, Array, List, and so on. *When extreme values are involved in an interpolation (for example Decimal.MaxValue) the call might result in a BadRequest exception. **For the Continuous interpolation mode, Nullable types are interpolated in the same manner as their non-nulllable equivalents as long as the values surrounding the desired interpolation index are non-null. If either of the values are null, the interpolated value will be null. If the InterpolationMode is not assigned, the events are interpolated in the default manner, unless the interpolation mode is overridden in the SdsTypeProperty or the SdsStream. For more information on overriding the interpolation mode on a specific type property see SdsTypeProperty . For more information on overriding the interpolation mode for a specific stream see Sds Streams . Extrapolation Extrapolation defines how a stream responds to requests with indexes that precede or follow all data in the steam. ExtrapolationMode acts as a master switch to determine whether extrapolation occurs and at which end of the data. ExtrapolationMode works with the InterpolationMode to determine how a stream responds. The following tables show how ExtrapolationMode affects returned values for each InterpolationMode value: ExtrapolationMode with InterpolationMode = Default (or Continuous), StepwiseContinuousLeading, and StepwiseContinuousTrailing ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns first data value Returns last data value None 1 No event is returned No event is returned Forward 2 No event is returned Returns last data value Backward 3 Returns first data value No event is returned ExtrapolationMode with InterpolationMode = Discrete ExtrapolationMode Enumeration value Index before data Index after data All 0 No event is returned No event is returned None 1 No event is returned No event is returned Forward 2 No event is returned No event is returned Backward 3 No event is returned No event is returned ExtrapolationMode with InterpolationMode = ContinuousNullableLeading and ContinuousNullableTrailing ExtrapolationMode Enumeration value Index before data Index after data All 0 Returns the default value Returns the default value None 1 No event is returned No event is returned Forward 2 No event is returned Returns the default value value Backward 3 Returns the default value No event is returned For additional information about the effect of read characteristics, see the documentation on the read method you are using. Filter Expressions Filter expressions can be applied to any read that returns multiple values, including Get Values, Get Range Values, Get Window Values, and Get Intervals. The filter expression is applied to the collection events conditionally filtering events that do not meet the filter conditions. Filter expressions are covered in detail in the Filter expressions section. Table Format Results of a query can be organized into tables by directing the form parameter to return a table. Two forms of table are available: table and header table. When the form parameter is specified as table, ?form=table , events are returned in row column form. Results include a collection named Columns that lists column name and type and a collection named Rows containing a collection of rows matching the order of the columns. Specifying a form of type table-headers , ?form=tableh , results in a collection where the Rows collection contains a column header list. Table formats are covered in detail in the Table format section. SdsBoundaryType The SdsBoundaryType enum defines how data on the boundary of queries is handled: around the start index for range value queries, and around the start and end index for window values. The following are valid values for SdsBoundaryType : Boundary Enumeration value Operation Exact 0 Results include the event at the specified index boundary if a stored event exists at that index. Inside 1 Results include only events within the index boundaries Outside 2 Results include up to one event that falls immediately outside of the specified index boundary. ExactOrCalculated 3 Results include the event at the specified index boundary. If no stored event exists at that index, one is calculated based on the index type and interpolation and extrapolation settings. SdsSearchMode The SdsSearchMode enum defines search behavior when seeking a stored event near a specified index. The following are valid values for SdsSearchMode : Mode Enumeration value Operation Exact 0 If a stored event exists at the specified index, that event is returned. Otherwise no event is returned. ExactOrNext 1 If a stored event exists at the specified index, that event is returned. Otherwise the next event in the stream is returned. Next 2 Returns the stored event after the specified index. ExactOrPrevious 3 If a stored event exists at the specified index, that event is returned. Otherwise the previous event in the stream is returned. Previous 4 Returns the stored event before the specified index. Transforming Data SDS provides the ability to transform data upon reads. The supported data transformations are: Reading with SdsStreamViews : Changing the shape of the returned data Unit of Measure Conversions : Converting the unit of measure of the data Data transformations are supported for all single stream reads, but transformations have specific endpoints. The following are the base URIs for the tranformation endpoints: api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  First api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  Last api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  Interpolated api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  Summaries api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  Sampled Reading with SdsStreamViews When transforming data with an SdsStreamView, the data read is converted to the target type specified in the SdsStreamView. Working with stream views is covered in detail in the Stream Views section. All stream view transformations are GET HTTP requests. The stream view is specified by appending the stream view identifier to requests to the transformation endpoint. For example the following request: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform/ Transform  First?streamViewId={streamViewId} would return the first event in the stream as the target type in the stream view specified by the streamViewId . All single stream data reads support stream view transformations. When data is requested with an SdsStreamView, the read characteristics defined by the target type of the SdsStreamView determine what is returned. The read characteristics are discussed in the code samples. Unit conversion of data SDS supports assigning Units of Measure (UOM) to stream data. If stream data has UOM information associated, SDS supports reading data with unit conversions applied. On each read data request, unit conversions are specified by a user defined collection of SdsStreamPropertyOverride objects in read requests. The SdsStreamPropertyOverride object has the following structure: Property Type Optionality Details SdsTypePropertyId String Required Identifier for an SdsTypeProperty with a UOM assigned Uom String Required Target unit of measure InterpolationMode SdsInterpolationMode N/A N A Currently not supported in context of data reads This is supported in the .NET API via overloads that accept a collection of SdsStreamPropertyOverride objects, and in the REST API via HTTP POST calls with a request body containing a collection of SdsStreamPropertyOverride objects. All unit conversions are POST HTTP requests. The unit conversion transformation URI is as follows: POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Transform Request body The Request Body contains a collection of SdsStreamPropertyOverride objects. The following code defines a Simple Type with one index, Time , and one additional property, Measurement . Measurement has an assigned unit of measure, meter. public class SimpleType { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } [SdsMember(Uom = \"meter\")] public Double Measurement { get; set; } } This type is assigned to a stream, and the example request body below requests SDS to convert the Measurement property of the returned data from meter to centimeter. [ { \"SdsTypePropertyId\" : \"Measurement\", \"Uom\" : \"centimeter\" } ] All single stream data reads with streams that have specified UOMs support UOM conversions."
                                                            },
    "Documentation/SequentialDataStore/Quick_Start.html":  {
                                                               "href":  "Documentation/SequentialDataStore/Quick_Start.html",
                                                               "title":  "Quick Start: Sequential Data Store",
                                                               "keywords":  "Quick Start: Sequential Data Store Sequential Data Store (SDS) is a sophisticated data store. The steps described here show a very simple interaction with SDS. To follow along with the steps in this section, you will first need an account, tenant and associated security credentials. If you have not already acquired an account, email OCS support at OSIsoft Cloud Services. You will be mainly working on the OSIsoft Cloud Services portal . Sign into the portal using the credentials associated with the tenant. You will also need a namespace and administrative client keys. Step 1: Acquire a Namespace In the portal, open the navigation menu and select Data Management \u003e Namespaces . You can use an existing namespace or create a new one. Step 2: Acquire a Client Identity and Secret The application acts as a confidential client ??? an application that is capable of securely maintaining a secret. In Azure Active Directory, the confidential client authentication flow is accomplished using an Application Identity. OSIsoft Cloud Services supports this authentication with a Client Identity (Client Id) and a Client Secret. To acquire a client identity from the portal, open the navigation menu and select Security \u003e Clients . You can either select an existing client or create a new client. For a new client, select Add Client and follow the prompts for creating a client identity and client secret. Be sure to keep a record of the client secret. For an exisiting client, highlight the desired client and select Client Details to see configuration information. You will need the Tenant Identity, Client Identity, and Client Secret to proceed. The Tenant Identity, Client Identity, and Client Secret are used to acquire a security token from an identity provider, Azure Active Directory in this case. Step 3: Acquire authentication token You use the Tenant Identity, Client Identity, and Client Secret to acquire an access token from Azure Active Directory. Select one of the clients from the list to see configuration information and code samples in various languages which are shown on tabs in the right panel. Step 4: Create data types An SdsType (or type) describes the structure of a single measured event or object. An SdsStream (or stream) has an associated SdsType and stores a stream of events or objects that take the shape of that type. A type consists of one or more data properties, one of which must represent an index. Indexes can be simple (a single integer property, for example) or compound (represented by multiple properties). DateTime is a common index for time-series stores. SDS supports a wide variety of property types, both simple (integers, strings and floats, for example) and complex (lists, arrays and enumerations, for example). Properties can be of any complex SdsType. See Types for a detailed list of supported data types. The SdsType is defined in JSON and is posted on OSIsoft Cloud Services (OCS) endpoint. POST /api/v1/Tenants/{tenantId}/Namespaces/{namespaceId}/Types/{typeId}  api v1 Tenants {tenantId} Namespaces {namespaceId} Types {typeId} HTTP/1.1 HTTP 1.1 Authorization: Bearer \u003cbearer-token\u003e Content-Length: 1562 Content-Type: application/json application json Host: dat-b.osisoft.com { \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": null, \"SdsTypeCode\": 1, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"Description\": null, \"Order\": 0, \"IsKey\": true, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\": \"DateTime\", \"Description\": null, \"SdsTypeCode\": 16, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": null, \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"State\", \"Name\": \"State\", \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\": \"State\", \"Description\": null, \"SdsTypeCode\": 609, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": [ { \"Id\": \"Ok\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 0, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Warning\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 1, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Alarm\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 2, \"Uom\": null, \"InterpolationMode\": null } ], \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\": \"Double\", \"Description\": null, \"SdsTypeCode\": 14, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": null, \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null } ], \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 } To help users develop .NET client applications for SDS, OSIsoft provides OCS client libraries through NuGet packages, OCSClients . OCSClients consists of necessary libraries to connect to OCS and manage data. Note that SDS client libraries are only available in .NET. You can use SdsTypeBuilder in .NET client libraries to create types: public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType\u003cSimple\u003e(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; simpleType.Description = \"Basic sample type\"; await config.CreateTypeAsync(simpleType); Step 5: Create a stream An SdsStream (or stream) has an associated SdsType and stores a stream of events or objects that take the shape of that type. For more information, see Streams . Define and post a JSON representation of SdsStream to OCS endpoint. POST /api/v1/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}  api v1 Tenants {tenantId} Namespaces {namespaceId} Streams {streamId} HTTP/1.1 HTTP 1.1 Authorization: Bearer \u003cbearer-token\u003e Content-Length: 139 Content-Type: application/json application json Host: dat-b.osisoft.com { \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": null, \"TypeId\": \"Simple\", \"Indexes\": null, \"InterpolationMode\": null, \"ExtrapolationMode\": null, \"PropertyOverrides\": null } You can create a stream for simple events also by using .NET client libraries method: SdsStream simpleStream = new SdsStream() { Id = \"Simple\", Name = \"Simple\", TypeId = simpleType.Id }; simpleStream = config.CreateStreamAsync(simpleStream); Step 6: Write data SDS supports a number of methods for adding and updating data. In this section, you will insert data. Inserts fail if events with the same index already exist in the database. Update adds new events and replaces existing events. For more information, see Write data . Add data to SDS by posting a JSON serialized event to OCS endpoint: POST /api/v1/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data  api v1 Tenants {tenantId} Namespaces {namespaceId} Streams {streamId} Data HTTP/1.1 HTTP 1.1 Authorization: Bearer \u003cbearer-token\u003e Content-Length: 57 Content-Type: application/json application json Host: dat-b.osisoft.com [ { \"Time\":\"2017-08-17T17:21:36.3494129Z\", \"State\":0, \"Measurement\":123.45 } ] You can alternatively use .NET client libraries method InsertValueAsync : Simple value = new Simple() { Time = DateTime.UtcNow, State = State.Ok, Measurement = 123.45 }; await client.InsertValueAsync(simpleStream.Id, value); Step 7: Read data SDS includes different read methods for retrieving data from streams. For more information, see Read data . The examples below are of reading value that was recently written. You need an index or indexes in a read data call, a timestamp of that value in this case. Read a value from SDS at a distinct index by making a REST API call to OCS: GET api/v1/Tenants/{tenantId}/Namespaces/{namespaceId}/Streams/{streamId}/Data?index=2017-08-17T17:21:36.3494129Z api v1 Tenants {tenantId} Namespaces {namespaceId} Streams {streamId} Data?index=2017-08-17T17:21:36.3494129Z HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-08-17T17:21:36.3494129Z\", \"State\": 0, \"Measurement\": 20 } ] One or more indexes are needed in most read calls to determine which data to read. The simplest way to supply an index is as a string. A DateTime is used as an index below in .NET: string index = DateTime.Parse(\"2017-08-17T17:21:36.3494129Z\") .ToUniversalTime().ToString(\"o\"); To read a value at a distinct index, you can use the .NET SDS libraries method. Time is the index here, which is a property of a type named Simple : value = await client.GetDistinctValueAsync\u003cSimple\u003e(simpleStream.Id, index); Handling transient service interruptions All applications that communicate with remote systems must manage transient faults. Temporary service interruptions are a fact of life in real-world cloud applications. If you access SDS with .NET client libraries methods, transient fault handling is built in; the SDS client automatically retries error codes identified as transient. If you are directly calling into the OCS through SDS REST APIs (not using .NET), you should consider creating your own retry logic to handle errors identified as transient. In this case, we recommend a logic which returns HTTP status code 503: Service Unavailable : an immediate first retry followed by an exponential backoff. SDS client error If you access SDS using the .NET client libraries, note that any non-success responses returned to the client are packaged in an SdsHttpClientException , which is an exception with the following additional properties: string ReasonPhrase HttpStatusCode StatusCode Dictionary\u003cstring, object\u003e Errors The StatusCode provides the HttpStatusCode from the response. The ReasonPhrase might provide additional information regarding the cause of the exception. You should always evaluate the ReasonPhrase in addition to the StatusCode to determine the cause of the exception. The errors collection may provide additional specific error information based on the response. For example, if an InsertValues call failed because it conflicted with an existing event in the stream, the index of the conflicting event will be included in this dictionary. SDS Timeout Request Header Handling timeout issues can be difficult and confusing in a distributed programming environment. When a client times out, for example, the request is terminated before the client receives a response from the server. Meanwhile, the application is unaware of the state of the server. One solution is to use the Request-Timeout header, which is recognized by many services in OCS. Using the header, you can tell the server how long to spend on a particular request before timing out. If possible, the server terminates the request if the time it takes to process the request exceeds the timeout value set in the header. To specify the request timeout value, include the Request-Timeout header and specify the value in seconds."
                                                           },
    "Documentation/SequentialDataStore/indexes.html":  {
                                                           "href":  "Documentation/SequentialDataStore/indexes.html",
                                                           "title":  "Indexes",
                                                           "keywords":  "Indexes Indexes speed up and order the results of searches. A key uniquely identifies a record within a collection of records. Keys are unique within the collection. In Sds, the key of an SdsType is also an index. The key is often referred to as the primary index, while all other indexes are referred to as secondary indexes or secondaries . An SdsType that is used to define an SdsStream must specify a key. When inserting data into an SdsStream, every key value must be unique. Sds will not store more than a single event for a given key; an event with a particular key may be deleted or updated, but two events with the same key cannot exist. In .NET, the SdsType properties that define the key are identified using an OSIsoft.Sds.SdsMemberAttribute and setting its IsKey field to true. If the key consists of only a single property it is permissible to use the System.ComponentModel.DataAnnotations.KeyAttribute . In the SdsType, the Property or Properties representing the key have their SdsTypeProperty.IsKey field set to true. Secondary indexes are defined on SdsStreams and are applied to a single property. You can define many secondary indexes. Secondary index values need not be unique. The following table contains supported index types: Type SdsTypeCode Boolean 3 Byte 6 Char 4 DateTime 16 DateTimeOffset 20 Decimal 15 Double 14 Guid 19 Int16 7 Int32 9 Int64 11 SByte 5 Single 13 String 18 TimeSpan 21 UInt16 8 UInt32 10 UInt64 12 Compound Indexes Often, a single property (such as a DateTime), is adequate for defining an index; however, for more complex scenarios, Sds allows you to define multiple properties. Indexes defined by multiple properties are known as compound indexes . When defining a compound index in .NET, you should apply the OSIsoft.Sds.SdsMemberAttribute on each of the type???s properties that are combined to define the index. Set the IsKey property to true and give Orderfield a zero-based index value. The Order field defines the precedence of the property when sorting. A property with an order of 0 has highest precedence. When defining compound indexes outside of .NET, specify the IsKey and Order fields on the SdsTypeProperty of Properties. Only the primary index (or key) supports compound indexes. You can specify a maximum of three Properties to define a compound index. The Sds REST API methods that use tuples were created to assist you when using compound indexes. Working with Indexes Using .NET Simple Indexes When working in .NET, use the SdsTypeBuilder together with either the OSIsoft.Sds.SdsMemberAttribute or the System.ComponentModel.DataAnnotations.KeyAttribute to identify the Property that defines the simple Key. The SdsMemberAttribute is preferred. Using SdsTypeBuilder eliminates potential errors that might occur when working with SdsTypes manually. public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType\u003cSimple\u003e(); To read data that is located between two indexes, ordered by the Key, define both a start index and an end index. For DateTime, use ISO 8601 representation of dates and times. For example, to query for a window of simple values between January 1, 2010 and February 1, 2010, you can define indexes and query as follows. IEnumerable\u003cSimple\u003e values = await client.GetWindowValuesAsync\u003cSimple\u003e(simpleStream.Id, \"2010-01-01T08:00:00.000Z\",\"2010-02-01T08:00:00.000Z\"); More information about querying data can be found in Reading data . Secondary Indexes Secondary indexes are defined at the SdsStream. To add indexes to an SdsStream, you add them to the SdsStream???s Indexes field. For example, to add a second index on Measurement, use the following code: SdsStreamIndex measurementIndex = new SdsStreamIndex() { SdsTypePropertyId = simpleType.Properties.First(p =\u003e p.Id.Equals(\"Measurement\")).Id }; SdsStream secondary = new SdsStream() { Id = \"Simple with Secondary\", TypeId = simpleType.Id, Indexes = new List\u003cSdsStreamIndex\u003e() { measurementIndex } }; secondary = await config.GetOrCreateStreamAsync(secondary); To read data indexed by a secondary Index, use a filtered Get, as in the following: await client.UpdateValuesAsync\u003cSimple\u003e(secondary.Id, new List\u003cSimple\u003e() { new Simple() { Time = time, State = State.Ok, Measurement = 5 }, new Simple() { Time = time + TimeSpan.FromSeconds(1), State = State.Ok, Measurement = 4 }, new Simple() { Time = time + TimeSpan.FromSeconds(2), State = State.Ok, Measurement = 3 }, new Simple() { Time = time + TimeSpan.FromSeconds(3), State = State.Ok, Measurement = 2 }, new Simple() { Time = time + TimeSpan.FromSeconds(4), State = State.Ok, Measurement = 1 }, }); IEnumerable\u003cSimple\u003e orderedByKey = await client.GetWindowValuesAsync\u003cSimple\u003e(secondary.Id, time.ToString(\"o\"), time.AddSeconds(4).ToString(\"o\")); foreach (Simple value in orderedByKey) Console.WriteLine(\"{0}: {1}\", value.Time, value.Measurement); Console.WriteLine(); IEnumerable\u003cSimple\u003e orderedBySecondary = await client.GetFilteredValuesAsync\u003cSimple\u003e(secondary.Id, \"Measurement gt 0 and Measurement lt 6\"); foreach (Simple value in orderedBySecondary) Console.WriteLine(\"{0}: {1}\", value.Time, value.Measurement); Console.WriteLine(); /   /   Output: /   /   1/ 1  20/ 20  2017 12:00:00 AM: 5 /   /   1/ 1  20/ 20  2017 12:00:01 AM: 4 /   /   1/ 1  20/ 20  2017 12:00:02 AM: 3 /   /   1/ 1  20/ 20  2017 12:00:03 AM: 2 /   /   1/ 1  20/ 20  2017 12:00:04 AM: 1 /   /   /   /   1/ 1  20/ 20  2017 12:00:04 PM: 1 /   /   1/ 1  20/ 20  2017 12:00:03 PM: 2 /   /   1/ 1  20/ 20  2017 12:00:02 PM: 3 /   /   1/ 1  20/ 20  2017 12:00:01 PM: 4 /   /   1/ 1  20/ 20  2017 12:00:00 PM: 5 Compound Indexes Compound indexes are defined using the SdsMemberAttribute as follows: public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } public class DerivedCompoundIndex : Simple { [SdsMember(IsKey = true, Order = 1)] public DateTime Recorded { get; set; } } Events of type DerivedCompoundIndex are sorted first by the Time parameter and then by the Recorded parameter. A collection of times would be sorted as follows: Time Recorded Measurement 01:00 00:00 0 01:00 01:00 2 01:00 14:00 5 02:00 00:00 1 02:00 01:00 3 02:00 02:00 4 02:00 14:00 6 If the Order parameters were swapped, Recorded set to zero, and Time set to one, the results would sort as follows: Time Recorded Measurement 01:00 00:00 0 02:00 00:00 1 01:00 01:00 2 02:00 01:00 3 02:00 02:00 4 01:00 14:00 5 02:00 14:00 6 /   /   estimates at 1/ 1  20/ 20  2017 00:00 await client.UpdateValuesAsync(compoundStream.Id, new List\u003cDerivedCompoundIndex\u003e() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 01:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 00:00\"), State = State.Ok, Measurement = 0 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 02:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 00:00\"), State = State.Ok, Measurement = 1 }, }); /   /   measure and estimates at 1/ 1  20/ 20  2017 01:00 await client.UpdateValuesAsync(compoundStream.Id, new List\u003cDerivedCompoundIndex\u003e() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 01:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 01:00\"), State = State.Ok, Measurement = 2 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 02:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 01:00\"), State = State.Ok, Measurement = 3 }, }); /   /   measure at 1/ 1  20/ 20  2017 02:00 await client.UpdateValuesAsync(compoundStream.Id, new List\u003cDerivedCompoundIndex\u003e() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 02:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 02:00\"), State = State.Ok, Measurement = 4 }, }); /   /   adjust earlier values at 1/ 1  20/ 20  2017 14:00 await client.UpdateValuesAsync(compoundStream.Id, new List\u003cDerivedCompoundIndex\u003e() { new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 01:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 14:00\"), State = State.Ok, Measurement = 5 }, new DerivedCompoundIndex() { Time = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 02:00\"), Recorded = DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 14:00\"), State = State.Ok, Measurement = 6 }, }); var from = new Tuple\u003cDateTime, DateTime\u003e(DateTime.Parse(\"1/ DateTime\u003e(DateTime.Parse(\"1  20/ 20  2017 01:00\"), DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 00:00\")); var to = new Tuple\u003cDateTime, DateTime\u003e(DateTime.Parse(\"1/ DateTime\u003e(DateTime.Parse(\"1  20/ 20  2017 02:00\"), DateTime.Parse(\"1/ DateTime.Parse(\"1  20/ 20  2017 14:00\")); var compoundValues = await client.GetWindowValuesAsync\u003cDerivedCompoundIndex, DateTime, DateTime\u003e(compoundStream.Id, from, to); foreach (DerivedCompoundIndex value in compoundValues) Console.WriteLine(\"{0}:{1} {2}\", value.Time, value.Recorded, value.Measurement); /   /   Output: /   /   1/ 1  20/ 20  2017 1:00:00 AM:1/ AM:1  20/ 20  2017 12:00:00 AM 0 /   /   1/ 1  20/ 20  2017 1:00:00 AM:1/ AM:1  20/ 20  2017 1:00:00 AM 2 /   /   1/ 1  20/ 20  2017 1:00:00 AM:1/ AM:1  20/ 20  2017 2:00:00 PM 5 /   /   1/ 1  20/ 20  2017 2:00:00 AM:1/ AM:1  20/ 20  2017 12:00:00 AM 1 /   /   1/ 1  20/ 20  2017 2:00:00 AM:1/ AM:1  20/ 20  2017 1:00:00 AM 3 /   /   1/ 1  20/ 20  2017 2:00:00 AM:1/ AM:1  20/ 20  2017 2:00:00 AM 4 /   /   1/ 1  20/ 20  2017 2:00:00 AM:1/ AM:1  20/ 20  2017 2:00:00 PM 6 Note that the GetWindowValuesAsync() call specifies an expected return type and the index types as generic parameters. Not Using .NET Simple Indexes When the .NET SdsTypeBuilder is unavailable, indexes must be built manually. The following discusses the types defined in the Python and Java Script samples. Samples in other languages can be found here . To build a SdsType representation of the following sample class, see Sample : Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2 } var Simple = function () { this.Time = null; this.State = null; this.Value = null; } Sample The following code is used to build an SdsType representation of the sample class above: Python # Create the properties # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime # State is not a pre-defined type. An SdsType must be defined to represent the enum stateTypePropertyOk = SdsTypeProperty() stateTypePropertyOk.Id = \"Ok\" stateTypePropertyOk.Measurement = State.Ok stateTypePropertyWarning = SdsTypeProperty() stateTypePropertyWarning.Id = \"Warning\" stateTypePropertyWarning.Measurement = State.Warning stateTypePropertyAlarm = SdsTypeProperty() stateTypePropertyAlarm.Id = \"Alarm\" stateTypePropertyAlarm.Measurement = State.Alarm stateType = SdsType() stateType.Id = \"State\" stateType.Name = \"State\" stateType.Properties = [ stateTypePropertyOk, stateTypePropertyWarning,\\ stateTypePropertyAlarm ] state = SdsTypeProperty() state.Id = \"State\" state.Name = \"State\" state.SdsType = stateType # Measurement property is a simple non-indexed, pre-defined type measurement = SdsTypeProperty() measurement.Id = \"Measurement\" measurement.Name = \"Measurement\" measurement.SdsType = SdsType() measurement.SdsType.Id = \"Double\" measurement.SdsType.Name = \"Double\" # Create the Simple SdsType simple = SdsType() simple.Id = str(uuid.uuid4()) simple.Name = \"Simple\" simple.Description = \"Basic sample type\" simple.SdsTypeCode = SdsTypeCode.Object simple.Properties = [ time, state, measurement ] JavaScript /   /   Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); /   /   State is not a pre-defined type. A SdsType must be defined to represent the enum var stateTypePropertyOk = new SdsObjects.SdsTypeProperty({ \"Id\": \"Ok\", \"Value\": State.Ok }); var stateTypePropertyWarning = new SdsObjects.SdsTypeProperty({ \"Id\": \"Warning\", \"Value\": State.Warning }); var stateTypePropertyAlarm = new SdsObjects.SdsTypeProperty({ \"Id\": \"Alarm\", \"Value\": State.Alarm }); var stateType = new SdsObjects.SdsType({ \"Id\": \"State\", \"Name\": \"State\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Int32Enum, \"Properties\": [stateTypePropertyOk, stateTypePropertyWarning, stateTypePropertyAlarm, stateTypePropertyRed] }); /   /   Value property is a simple non-indexed, pre-defined type var valueProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Value\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"doubleType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Double }) }); /   /   Create the Simple SdsType var simpleType = new SdsObjects.SdsType({ \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": \"This is a simple Sds type\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [timeProperty, stateProperty, valueProperty] }); The Time property is identified as the Key by define its SdsTypeProperty as follows: Python # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime JavaScript /   /   Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); Note that the time.IsKey field is set to true. To read data using the key, you define a start index and an end index. For DateTime, use ISO 8601 representation of dates and times. To query for a window of values between January 1, 2010 and February 1, 2010, you would define indexes as ???2010-01-01T08:00:00.000Z??? and ???2010-02-01T08:00:00.000Z???, respectively. Additional information can be found in Reading data . Secondary Indexes Secondary Indexes are defined at the SdsStream. To create an SdsStream using the Simple class and add a Secondary index on the Measurement, you use the previously defined SdsType. Then you create a SdsStreamIndex specifying the measurement property and define a SdsStream identifying the Measurement as a Secondary Index as shown in the following example: Python # Create the properties measurementIndex = SdsStreamIndex() measurementIndex.SdsTypePropertyId = measurement.Id stream = SdsStream() stream.Id = str(uuid.uuid4()) stream.Name = \"SimpleWithSecond\" stream.Description = \"Simple with secondary index\" stream.TypeId = simple.Id stream.Indexes = [ measurementIndex ] JavaScript var measurementIndex = new SdsObjects.SdsStreamIndex({ \"SdsTypePropertyId\": valueProperty.Id }); var stream = new SdsObjects.SdsStream({ \"Id\": \"SimpleWithSecond\", \"Name\": \"SimpleWithSecond\", \"Description\": \"Simple with secondary index\", \"TypeId\": simpleTypeId, \"Indexes\": [ measurementIndex ] }); Compound Indexes Consider the following Python and JavaScript types: Python class Simple(object): # First-order Key property Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement class DerivedCompoundIndex(Simple): # Second-order Key property @property def Recorded(self): return self.__recorded @Recorded.setter def Recorded(self, recorded): self.__recorded = recorded JavaScript var Simple = function () { this.Time = null; this.State = null; this.Value = null; } var DerivedCompoundIndex = function() { Simple.call(this); this.Recorded = null; } To turn the simple SdsType shown in the example into a type supporting the DerivedCompoundIndex type with a compound index based on the Simple.Time and DerivedCompoundIndex.Recorded , extend the type as follows: Python # We set the Order for this property. The order of the first property defaulted to 0 recorded = SdsTypeProperty() recorded.Id = \"Recorded\" recorded.Name = \"Recorded\" recorded.IsKey = True recorded.Order = 1 recorded.SdsType = SdsType() recorded.SdsType.Id = \"DateTime\" recorded.SdsType.Name = \"DateTime\" recorded.SdsType.SdsTypeCode = SdsTypeCode.DateTime # Create the Derived SdsType derived = SdsType() derived.Id = str(uuid.uuid4()) derived.Name = \"Compound\" derived.Description = \"Derived compound index sample type\" derived.BaseType = simple derived.SdsTypeCode = SdsTypeCode.Object derived.Properties = [ recorded ] JavaScript /   /   We set the Order for this property. The order of the first property defaulted to 0 var recordedProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Recorded\", \"Name\": \"Recorded\", \"IsKey\": true, \"Order\": 1, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"DateTime\", \"Name\": \"DateTime\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); /   /   Create the Derived SdsType var derivedType = new SdsObjects.SdsTyp({ \"Id\": \"Compound\", \"Name\": \"Compound\", \"Description\": \"Derived compound index sample type\", \"BaseType\": simpleType, \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [recordedProperty] }); Data in the stream will be ordered as follows: Time Recorded Measurement 01:00 00:00 0 01:00 01:00 2 01:00 14:00 5 02:00 00:00 1 02:00 01:00 3 02:00 02:00 4 02:00 14:00 6 If the Order was swapped, and Recorded set as zero, the results would sort as follows: Time Recorded Measurement 01:00 00:00 0 02:00 00:00 1 01:00 01:00 2 02:00 01:00 3 02:00 02:00 4 01:00 14:00 5 02:00 14:00 6"
                                                       },
    "Documentation/SequentialDataStore/Filter_Expressions.html":  {
                                                                      "href":  "Documentation/SequentialDataStore/Filter_Expressions.html",
                                                                      "title":  "Filter Expressions: Values",
                                                                      "keywords":  "Filter Expressions: Values Filter expressions can be applied to certain read operations that return Sequential Data Store values, including: Get Values and Get Summaries . SdsTypeCodes Supported The following types are supported for use within a filter expression: Boolean Byte Char DateTime DateTimeOffset Decimal Double Guid Int16 Int32 Int64 Sbyte Single String Timespan UInt16 UInt32 Uint64 Types that are not supported The following types are not supported for use within a filter expression: Array IEnumerable IDictionary IList SdsType SdsTypeProperty Nullable Types Logical operators Supported The following logical operators are supported for use within a filter expression: Operator Comment eq Equal to ne Not equal ge Greater than or equal to le Less than or equal to lt Less than gt Greater than ( ) Parenthesis can be used to affect the order of the operation or Or logical operator and And logical operator not Not logical operator - Negation Logical Operator Examples For the following examples, assume that the SDS Type event includes a field named Value of type double : Value eq 1.0 Value ne 15.6 Value ge 5.0 Value le 8.0 Value gt 5.0 Value lt 4.0 Value gt 2.0 and Value lt 9.0 Value gt 6.0 or Value lt 2.0 not (Value eq 1.0) Math functions Supported The following math functions are supported for use within a filter expression: Function Comment add Addition sub Subtraction mul Multiplication div Division mod Modulo round Rounds to the nearest numeric component without a decimal, with the midpoint rounded away from 0. For example, 0.5 rounds to 1; -0.5 rounds to -1) floor Rounds down to the nearest numeric component without a decimal ceiling Rounds up to the nearest numeric component without a decimal Math Function Examples For the following examples, assume that the SDS Type event includes a field named Value of type double : Value eq (6.0 add 3.0) Value eq (6.0 sub 3.0) Value eq (6.0 mul 3.0) Value eq (6.0 div 3.0) Value eq (7.0 mod 3.0) round(Value) eq 16 floor(Value) eq 15 ceiling(Value) eq 16 String functions Supported String operations are case sensitive. The character index in a string is 0-based. The following string functions are supported for use within a filter expression: function Comment endswith Compare the character at the end of the input string startswith Compare the character at the start of the input string length Examines the string length indexof Examines the character starting at a given index substring Examine characters within another string at a specific location contains Search for characters anywhere in another string tolower Convert characters to lowercase toupper Convert characters to uppercase trim Remove whitespace from front and end of a string concat Concatenate strings together replace Replace one set of characters with another String function examples The following examples assume that the SDS Type event includes a field named sValue of type string : Example Result endswith(sValue, \u0027XYZ\u0027) True if sValue ends with the characters ???XYZ??? startswith(sValue, \u0027Val\u0027 True if sValue starts with the characters ???Val??? length(sValue) eq 11 True if sValue is 11 characters indexof(sValue, \u0027ab\u0027) eq 4 True if the 5th and 6th characters are ???ab??? contains(sValue, \u0027ab\u0027) True if characters ???ab??? are found anywhere in sValue substring(sValue, 10) eq \u0027a b\u0027 True if ???a b??? is found in sValue at index 10 tolower(sValue) eq \u0027val5\u0027 Change sValue to lowercase and compare to ???val5??? toupper(sValue) eq \u0027ABC\u0027 Change sValue to uppercase and compare to ???ABC??? trim(sValue) eq \u0027vall22\u0027 Trim whitespace from front and end of sValue and compare to ???val22??? concat(sValue,\u0027xyz\u0027) eq \u0027dataValue_7xyz\u0027 Add characters to sValue and compare to ???dataValue_7xyz??? replace(sValue,\u0027L\u0027,\u0027D\u0027) eq \u0027Dog1\u0027 Replace any ???L??? in sValue with ???D??? and compare to ???Dog1??? DateTime functions Supported The following DateTime functions are supported for use within a filter expression: Function Comment year Get year value from DateTime month Get month value from DateTime day Get day value from DateTime hour Get hour value from DateTime minute Get minute value from DateTime second Get second value from DateTime DateTime Function Examples The following examples assume that the SDS Type event includes a field named TimeId of type DateTime : year(TimeId) eq 2015 month(TimeId) eq 11 day(TimeId) eq 3 hour(TimeId) eq 1 minute(TimeId) eq 5 second(TimeId) eq 3 TimeSpan functions Supported The following TimeSpan functions are supported for use within a filter expression: function Comment years Get year value from TimeSpan days Get day value from TimeSpan hours Get hour value from TimeSpan minutes Get minute value from TimeSpan seconds Get second value from TimeSpan TimeSpan Function Examples For the following examples, assume that the SDS Type event includes a field named TimeSpanValue of type TimeSpan : years(TimeSpanValue) eq 1 days(TimeSpanValue) eq 22 hours(TimeSpanValue) eq 1 minutes(TimeSpanValue) eq 1 seconds(TimeSpanValue) eq 2"
                                                                  },
    "Documentation/Identity/Identity_PersistedGrant.html":  {
                                                                "href":  "Documentation/Identity/Identity_PersistedGrant.html",
                                                                "title":  "PersistedGrant",
                                                                "keywords":  "PersistedGrant Persisted Grants such as refresh tokens or authorization codes are used by OSIsoft Cloud Services to maintain some state about User authentication with regards to a Client. For instance, refresh tokens, which are issued to Hybrid clients, make it possible to determine when the Client can be issued a new access token on behalf of the User without the users themselves being present. Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Get Client Ids of Persisted Grants for User Get enumerable of client IDs that have been issued an Authorization Codes (not the same as the client type) on behalf of a User. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  PersistedGrants Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Member Account Administrator Returns 200 Success. Type: List [ \"String\", \"String\" ] 401 Unauthorized. 403 Forbidden. 404 User not found. 500 Internal server error. Get Total Count of Persisted Grants for a User Validate whether there are any Authorization Code Persisted Grants for User. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  PersistedGrants Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Member Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 User not found. 500 Internal server error. Remove Persisted Grants Remove Authorization Code Persisted Grants for the User with the specified User Id in the Tenant. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  PersistedGrants Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Member Account Administrator Returns 204 Removed. 401 Unauthorized. 403 Forbidden. 404 User not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error."
                                                            },
    "Documentation/Identity/Identity_Overview.html":  {
                                                          "href":  "Documentation/Identity/Identity_Overview.html",
                                                          "title":  "OSIsoft Identity Service",
                                                          "keywords":  "OSIsoft Identity Service You use OSIsoft Identity Service APIs to create, read, update and delete tenants, clients, users and other indentity related objects. Most cluster level roles can perform read, but not creates, updates or deletes. Users and clients have access to their own information. You can read more about specific roles under the Management topic."
                                                      },
    "Documentation/Identity/Identity_IdentityProvider.html":  {
                                                                  "href":  "Documentation/Identity/Identity_IdentityProvider.html",
                                                                  "title":  "IdentityProvider",
                                                                  "keywords":  "IdentityProvider APIs for getting a list of all supported Identity Providers. Properties For HTTP requests and responses, the IdentityProvider object has the following properties and JSON-serialized body: Property Type Description Id Guid Gets or sets id of an identity provider. DisplayName string Gets or sets identity provider display name to use. Scheme string Gets or sets the name of the cookie handler that will temporarily store the outcome of the external authentication. UserIdClaimType string Gets or sets type of claim. ClientId string Gets or sets the ClientId of the identity provider. IsConfigured bool Gets or sets a value indicating whether the identity provider has been configured. Serialized Model { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Get Identity Provider Returns an IdentityProvider object. Request GET api/ api  v1/ v1  IdentityProviders/ IdentityProviders  {identityProviderId} Parameters [Required] Guid identityProviderId Id of provider. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: IdentityProvider { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } 401 Unauthorized. 403 Forbidden. 404 Identity Provider not found. 500 Internal server error. Get Identity Provider By Scheme Returns a list of IdentityProvider objects that follow a scheme. Request GET api/ api  v1/ v1  IdentityProviders/ IdentityProviders  schemes/ schemes  {scheme} Parameters [Required] string scheme Scheme name. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: IdentityProvider { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } 401 Unauthorized. 403 Forbidden. 404 Identity Provider not found. 500 Internal server error. Get Identity Providers Returns a list of IdentityProvider objects. Request GET api/ api  v1/ v1  IdentityProviders Parameters [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of providers to skip. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of providers to return. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false }, { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } ] 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 500 Internal server error. Get Identity Provider based on scheme Get header for a scheme to check its validity. Request HEAD api/ api  v1/ v1  IdentityProviders/ IdentityProviders  schemes/ schemes  {scheme} Parameters [Required] string scheme Scheme name. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Identity Provider not found. 500 Internal server error. Get Identity Provider based on Id Get header for an identity provider to check if the identity provider exists. Request HEAD api/ api  v1/ v1  IdentityProviders/ IdentityProviders  {identityProviderId} Parameters [Required] Guid identityProviderId Id of provider. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 IdentityProvider or Tenant not found. 500 Internal server error. Get Header for Identity Providers Get header for Identity Providers to get the total number of Identity Providers. Request HEAD api/ api  v1/ v1  IdentityProviders Parameters This API call does not have any parameters. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Get All Identity Providers from Tenant Get all Identity Providers from a Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of Identity Providers to skip. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of Identity Providers to return. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: List [ { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false }, { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } ] 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Get Identity Provider from Tenant Get an Identity Provider from a Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders/ IdentityProviders  {identityProviderId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid identityProviderId Id of Identity Provider. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: IdentityProvider { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } 401 Unauthorized. 403 Forbidden. 404 IdentityProvider or Tenant not found. 500 Internal server error. Add Identity Provider to Tenant Add an existing Identity Provider to a Tenant. This Identity Provider will be available in the Home Realm Discovery Page for users to sign-in or sign-up. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] IdentityProviderAdd identityProviderAdd IdentityProviderAdd object. Property Type Required Description IdentityProviderId Guid Yes Gets or sets Identity Provider Id to Add. AzureActiveDirectorySendConsent bool No Gets or sets a value indicating whether send consent email for Azure Active Directory. AzureActiveDirectoryConsentEmail string Yes Gets or sets address to email consent. Only Azure Active Directory Admins have permission to consent to being allowed to interact with the tenant. The email does not have to be sent to an Admin. AzureActiveDirectoryConsentGivenName string Yes Gets or sets preferred name to use in the consent email. AzureActiveDirectoryConsentSurname string Yes Gets or sets preferred surname to use in the consent email. AzureActiveDirectoryTenant string Yes Gets or sets Azure Active Directory Domain Name (e.g. mydomain.onmicrosoft.com). { \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"AzureActiveDirectorySendConsent\": false, \"AzureActiveDirectoryConsentEmail\": \"user@company.com\", \"AzureActiveDirectoryConsentGivenName\": \"Name\", \"AzureActiveDirectoryConsentSurname\": \"Surname\", \"AzureActiveDirectoryTenant\": \"AzureActiveDirectoryTenant\" } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: IdentityProvider { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"DisplayName\": \"Name\", \"Scheme\": \"Scheme\", \"UserIdClaimType\": \"UserIdClaimType\", \"ClientId\": \"ClientId\", \"IsConfigured\": false } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Identity Provider already exists in Tenant. 500 Internal server error. Remove Identity Provider From Tenant Remove an Identity Provider from a Tenant. Users provisioned with this Identity Provider will remain in the Tenant, but will not be able to authenticate. An administrator cannot remove the Identity Provider they are signed in with. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders/ IdentityProviders  {identityProviderId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid identityProviderId Id of Identity Provider. Security Allowed for these roles: Account Administrator Returns 204 Removed. 401 Unauthorized. 403 Forbidden. 404 IdentityProvider or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Identity Provider Validate that a Identity Provider exists in the Tenant. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders/ IdentityProviders  {identityProviderId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid identityProviderId Id of Identity Provider. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 IdentityProvider or Tenant not found. 500 Internal server error. Get Total Count of Identity Providers Return total number of Identity Providers in a Tenant. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  IdentityProviders Parameters [Required] string tenantId Id of Tenant. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error."
                                                              },
    "Documentation/Identity/Identity_HybridClient.html":  {
                                                              "href":  "Documentation/Identity/Identity_HybridClient.html",
                                                              "title":  "HybridClient",
                                                              "keywords":  "HybridClient Hybrid clients are used in typical, thick MVC clients with the presence of a User. These clients are issued an Id and Secret upon creation, which are later used for authentication against OSIsoft Cloud Services. More than one Secret can be created for a Client. You can read more about these clients here . Hybrid clients can be issued refresh tokens, if requested, alongside access tokens. Refresh tokens typically have an longer lifetime than access tokens, and are used to request a new access token on behalf of the user without them having to sign-in. It is highly suggested that both the Client Secret and the refresh token be stored in a secure location. Properties For HTTP requests and responses, the HybridClient object has the following properties and JSON-serialized body: Property Type Description AllowOfflineAccess bool Gets or sets whether this client can request refresh tokens, by providing the offline_access scope. AllowAccessTokensViaBrowser bool Gets or sets whether this HybridClient is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type, thus leaking the token to the browser). RedirectUris string[] Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string Gets or sets URI to a page with information about client (used on consent screen). LogoUri string Gets or sets URI to client logo (used on consent screen). Id string Gets or sets client ID for this client. This ID should be a GUID. Name string Gets or sets name of Client. Enabled bool Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] Gets or sets for OSIsoft internal use only. Serialized Model { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Create Hybrid Client Create a Hybrid Client. A Client Id and Client Secret will be generated to perform authentication. Make sure to store the Secret somewhere safe as we do not store the actual value after the creation step. If you do not have access to the Secret value, we suggest deleting the Secret and adding a new one for this Client. Clients have unique ids in a Tenant. Currently there is a limit of 50000 clients (of all types) per Tenant. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] HybridClientCreate hybridClientCreate HybridClientCreate object. Property Type Required Description SecretDescription string No Gets or sets description for the initial secret for the client. SecretExpirationDate DateTime No Gets or sets expiration date for the initial secret for the client. If set to null the secret will never expire. We advise against such practice. AllowOfflineAccess bool No Gets or sets whether this client can request refresh tokens, by providing the offline_access scope. AllowAccessTokensViaBrowser bool No Gets or sets whether this HybridClient is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type, thus leaking the token to the browser). RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"SecretDescription\": \"description\", \"SecretExpirationDate\": \"2019-11-11T14:18:37.9244194-08:00\", \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: ClientResponse { \"Secret\": \"Secret\", \"Id\": 0, \"Description\": \"description\", \"ExpirationDate\": \"2019-11-11T14:18:37.9396268-08:00\", \"Client\": { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } } 400 Missing or invalid inputs, or Client limit exceeded. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Client Id already exists. 500 Internal server error. Update Hybrid Client Update a Hybrid Client. It can take up to one hour for these values to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] HybridClient hybridClient HybridClient object. Properties that are not set or are null will not be changed. Property Type Required Description AllowOfflineAccess bool No Gets or sets whether this client can request refresh tokens, by providing the offline_access scope. AllowAccessTokensViaBrowser bool No Gets or sets whether this HybridClient is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type, thus leaking the token to the browser). RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: HybridClient { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 400 Missing or invalid inputs. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Hybrid Client Get a Hybrid Client from a Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: HybridClient { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get All Hybrid Clients Get a list of Hybrid clients from a Tenant. Optionally, get a list of requested clients. Total number of clients in the Tenant set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of Hybrid Client Ids. Empty, whitespace or null Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only return Clients that have these tags. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. Will be ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Will be ignored if a list of Ids is passed. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] }, { \"AllowOfflineAccess\": false, \"AllowAccessTokensViaBrowser\": false, \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } ] 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Delete Hybrid Client Delete a Hybrid Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued to this Client will be valid until their expiration. Refresh tokens issued to this will be valid up to one hour after deletion. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Hybrid Client Validate that a Hybrid Client exists. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Total Count of Hybrid Clients Return total number of Hybrid clients in a Tenant. Optionally, check based on a list of requested clients. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of Hybrid Client Ids. Empty, whitespace or null Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only count clients that have these tags. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error."
                                                          },
    "Documentation/DataIngress/OMF_Ingress_to_OCS.html":  {
                                                              "href":  "Documentation/DataIngress/OMF_Ingress_to_OCS.html",
                                                              "title":  "Data Ingress to Cloud Services using OMF",
                                                              "keywords":  "Data Ingress to Cloud Services using OMF You can use OSIsoft Message Format ( OMF ) to achieve high-throughput asynchronous data ingress into the Sequential Data Store. The following terms are useful for understanding the information in this and subsequent sections: A producer of OMF messages needs a Client identity to authenticate and send messages. Messages are sent to a queue called a Topic . A Subscription receives messages from a Topic and writes them to the Sequential Data Store."
                                                          },
    "Documentation/DataIngress/OMF_Ingress_Topics.html":  {
                                                              "href":  "Documentation/DataIngress/OMF_Ingress_Topics.html",
                                                              "title":  "Topics",
                                                              "keywords":  "Topics A Topic aggregates OMF messages received from one or more Clients and makes them available for consumption by a Subscription. Topic Information A Topic must contain at least one Client Id. Clients may be added to or removed from an existing Topic. A given Client may belong to multiple Topics in separate Namespaces. When a Topic is created, OMF messages sent from the Topic\u0027s associated Clients are routed to a queue where they can be consumed by a Subscription. This queue makes OMF messages available to Subscriptions for up to seven days. While the OMF messages are in the Topic queue, they are not available for retrieval via an API. They must first be consumed by a Subscription and forwarded to a data store. The Topic queue stores the OMF messages in the Region of its Namespace. The API calls in this section are used to create and manipulate topics. Data Models Topic information is contained in an object called Topic and has the following format: Property Type Details Id string Unique Id generated by the API during creation. Name string A friendly name for the Topic. ClientIds string array An array of Client Ids mapped to the Topic. Description string Description of the Topic. CreatedDate DateTime Date and time this Topic was created. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics Get all Topics for a tenant. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An array of Topic objects. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId} Get a specific Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Returns A Topic object. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  subscriptions Get all Subscriptions across all namespaces mapped to a Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace of the Topic. topicId Unique Id for the Topic. Returns An array of Subscription objects. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accesscontrol/ accesscontrol  topics Get the default Access Control List for new Topics. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An AccessControlList object. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accessrights/ accessrights  topics Get the default Access Rights of the requesting identity for any newly created Topics. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Returns An array of Access Rights strings. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  accesscontrol Get the Access Control List for a particular Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Returns An AccessControlList object. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  accessrights Get the Access Rights of the requesting identity for a particular Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Returns An array of Access Rights strings. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  owner Get the Owner for a particular Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Returns A Trustee object. POST api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics Create a new topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body A Topic object. The Id property should not be specified, since it will be automatically generated during creation. Returns The Topic object that was created. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId} Update an existing Topic. Only the name and description can be updated. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Topic Id for the Topic to be updated. Body A Topic object. The Id property should match the topicId in the route. Returns The Topic object that was updated. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accesscontrol/ accesscontrol  topics Update the default Access Control List for new Topics. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body An AccessControlList object. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  accesscontrol Update the Access Control List for a particular Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Body An AccessControlList object. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId}/ {topicId}  owner Update the Owner for a particular Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic. Body A Trustee object. DELETE api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  topics/ topics  {topicId} Delete a Topic. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. topicId Unique Id for the Topic."
                                                          },
    "Documentation/DataIngress/OMF_Ingress_Subscriptions.html":  {
                                                                     "href":  "Documentation/DataIngress/OMF_Ingress_Subscriptions.html",
                                                                     "title":  "Subscriptions",
                                                                     "keywords":  "Subscriptions A Subscription consumes OMF messages from a Topic and forwards them to a data store. Multiple Subscriptions can retrieve OMF messages from a single Topic. Subscription Information A Subscription can consume OMF messages from a Topic in a different Namespace. However, the Topic\u0027s Namespace must be in the same Region as the Subscription\u0027s Namespace. OMF messages that the Subscription is processing are temporarily stored in the Region of its Namespace. The API calls in this section are used to create and manipulate Subscriptions. Sequential Data Store (Sds) Subscription A Sequential Data Store Subscription retrieves OMF messages from a Topic and writes them directly to a Namespace in the Sequential Data Store. Currently only Sds Subscriptions are supported. The documentation uses Sds Subscription and Subscription interchangeably. Data Models Subscription information is contained in an object called Subscription which has the following format: Property Type Details Id string Unique Id generated by the API during creation. Name string A friendly name for the Subscription. TopicId string Unique Id for the Topic we are subscribing to. TopicTenantId string Identifies the owner of the Topic. TopicNamespaceId string Identifies the namespace for the Topic TenantId string Identifies the owner of the Subscription. NamespaceId string Identifies the namespace for the Subscription. Description string Description of the Subscription. Type integer An enumeration which describes the type of Subscription where Sds=1 CreatedDate DateTime Date and time this Subscription was created. Enabled boolean Whether the Topic exists or not. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions Get all Subscriptions for a tenant. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace Returns An array of Subscription objects. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId} Get a specific Subscription. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace subscriptionId Unique Id for the Subscription. Returns A Subscription object GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accesscontrol/ accesscontrol  subscriptions Get the default Access Control List for new Subscriptions. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace Returns An AccessControlList object. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accessrights/ accessrights  subscriptions Get the default Access Rights of the requesting identity for any newly created Subscriptions. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace. Returns An array of Access Rights strings. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId}/ {subscriptionId}  accesscontrol Get the Access Control List for a particular Subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the Subscription. Returns An AccessControlList object. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId}/ {subscriptionId}  accessrights Get the Access Rights of the requesting identity for a particular Subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the Subscription. Returns An array of Access Rights strings. GET api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId}/ {subscriptionId}  owner Get the Owner for a particular Subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. subscriptionId Unique Id for the Subscription. Returns A Trustee object. POST api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions Create a new Subscription. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body A Subscription object. The Id property should not be specified, since it will be automatically generated during creation. Returns The Subscription object that was created. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId} Update an existing Subscription. Only the name and description may be updated. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace. subscriptionId Subscription Id for the Subscription to be updated. Body A Subscription object. The Id property should match the subscriptionId in the route. Returns The Subscription object that was updated. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  accesscontrol/ accesscontrol  subscriptions Update the default Access Control List for new Subscriptions. Parameters tenantId Unique Id for the tenant. namespaceId Unique Id for the namespace. Body An AccessControlList object. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId}/ {subscriptionId}  accesscontrol Update the Access Control List for a particular Subscription. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace subscriptionId Unique Id for the Subscription Body An AccessControlList object. PUT api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId}/ {subscriptionId}  owner Update the Owner for a particular Subscription. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace subscriptionId Unique Id for the Subscription Body A Trustee object. DELETE api/ api  v1/ v1  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  subscriptions/ subscriptions  {subscriptionId} Delete a Subscription. Parameters tenantId Unique Id for the tenant namespaceId Unique Id for the namespace subscriptionId Unique Id for the Subscription"
                                                                 },
    "Documentation/DataIngress/Data_Ingress.html":  {
                                                        "href":  "Documentation/DataIngress/Data_Ingress.html",
                                                        "title":  "Data Ingress and OSIsoft Message Format",
                                                        "keywords":  "Data Ingress and OSIsoft Message Format ======================================= You use OSIsoft Message Format (OMF) to achieve high-throughput asynchronous data ingress into the Sequential Data Store. The following terms are useful for understanding the information in this and subsequent sections: A producer of OMF messages needs a Client identity to authenticate and send messages. Messages are sent to a queue called a Topic . A Subscription receives messages from a Topic and writes them to the Sequential Data Store."
                                                    },
    "Documentation/OSIsoft_Cloud_Services.html":  {
                                                      "href":  "Documentation/OSIsoft_Cloud_Services.html",
                                                      "title":  "OSIsoft Cloud Services",
                                                      "keywords":  "OSIsoft Cloud Services The information in the sections that follow document the APIs and usage for each of the following: Management - Use the information in this section to create, manage, and administer your account by assigning users, roles, and namespaces to your tenant. Identity - Use the information in this section to create, manage and administer Users and Clients. Sequential Data Store (SDS) - Use the information in this section to learn about the OSIsoft Cloud Services Sequential Data Store. The SDS is optimized for sequential data operations. Data ingress and OSIsoft Message Format - You use OSIsoft Message Format (OMF) to achieve high-throughput asynchronous data ingress into the OCS Sequential Data Store. Data Views - Use the information in this section to create user-selected subsets of data stored in OSIsoft Cloud Services which are mapped into customizable table formats. Access to OCS You must acquire an account before interacting with OCS. If you do not have an account, you can request access to OCS at https://cloud.osisoft.com/?signup https:  cloud.osisoft.com ?signup . Architecture A Tenant represents a client or organization that owns and manages a collection of OSIsoft Cloud Services. Tenants are divided into one or more logical units called Namespaces. Each Namespace is distinct and separate from other Namespaces, with its own instances of the various OSIsoft Cloud Services and data stores. Namespaces provide isolation of resources. Namespaces are provisioned within a region. The Namespace\u0027s services and data stores all exist in the Namespace\u0027s region. Resources allocated to a Namespace are isolated to the Namespace\u0027s region. For more information on regions see the Namespace documentation. Isolation provided by Tenants and Namespaces prevents accidental or malicious data access. OSIsoft Cloud Services provides data residency via namespaces in the following regions: Supported Regions Geographic Area Location WestUS Americas California WestEurope Europe Netherlands Tenant account information is stored in all regions for read-only purposes. Write operations are only supported through the global base URL. See the Tenant documentation for information on how to access this data. OCS API Versioning New versions of the API are released when major changes occur in the OCS API. When a newer version of the API is released, the legacy version of the API will only be supported for a period of time. We encourage all users to switch to the newer version as soon as possible. Versions are inline in the routes, following the host: api/ api  v{version}/ v{version}  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  ... Where: version is an incrementally (singular) increasing integer value v{version}-preview will be used to expose beta functionality The currently supported versions are: v1 v1-preview"
                                                  },
    "Documentation/support.html":  {
                                       "href":  "Documentation/support.html",
                                       "title":  "Getting support",
                                       "keywords":  "Getting support We will provide you with our standard support for this offering at no additional charge. End users can access contact information for OSIsoft Technical Support via the Portal. You will be entitled to contact the OSIsoft Technical Support twenty-four (24) hours a day, seven (7) days a week to ask questions or seek advice regarding the use of OCS. OSIsoft will assist end users in using this offering and in identifying and providing workarounds, if possible, for problems or limitations with the service. Such assistance may include remote computer communications to end users\u0027 facilities. OSIsoft will use its best efforts to respond to all Technical Support queries within four (4) hours. If you have feedback, please visit UserVoice . UserVoice is monitored by our product department."
                                   },
    "index.html":  {
                       "href":  "index.html",
                       "title":  "OCS API",
                       "keywords":  "OCS API OSIsoft Cloud Services (OCS) is a highly flexible cloud-based platform that provides scalable, elastic, centralized environment to aggregate data for reporting, advanced analytics, and third-party applications. OSIsoft Cloud Services Account Management Client Roles Namespace Roles RootAccessControl Tenant Tenant Feature States User Roles ServiceBlog Identity AAD Tenant Authorization Code Client Implicit Client Client Credential Client Hybrid Client Persisted Grant User Invitation IdentityProvider Secret Consent to OSIsoft Applications Sequential Data Store Quick Start Types Streams Stream metadata and tags Stream views Indexes Units of Measure Reading data API calls for reading data Writing data API calls for writing data Compression Searching Filter expressions - data Table format Data Ingress and OSIsoft Message Format Data Ingress to Cloud Services Using OMF Using OMF with Cloud Services Topics Subscriptions Data Views (Preview) Data Views API Overview Introduction - Define a Data View Quick Start - Define a Data View Introduction - Get Data View Data Quick Start - Get Data View Data Example Scenario Data View Queries Field Sets Sectioning Data View API Resolved Data View Data Items and Sections Available Field Sets Field Mappings Resolved Data View API Getting Data Data API Securing Data Views Access Control API Role-based Access Control Samples Getting Support"
                   },
    "Documentation/SequentialDataStore/Units_of_Measure.html":  {
                                                                    "href":  "Documentation/SequentialDataStore/Units_of_Measure.html",
                                                                    "title":  "Units of Measure",
                                                                    "keywords":  "Units of Measure The Sequential Data Store (SDS) provides a collection of built-in units of measure (UOM). These units of measure can be associated with SdsStreams and SdsTypes in order to provide unit information for stream data that model measurable quantities. If data has unit information associated with it, SDS is able to support unit conversions when retrieving data. See Reading data for more information. Since a unit of measure (meter, for example) defines the magnitude of a quantity (for example, length), SDS represents this by way of two objects: SdsUom and SdsUomQuantity. SdsUom A SdsUom represents a single unit of measure, such as \u0027meter\u0027. The following table shows the required and optional SdsUom fields. Property Type Optionality Details Example Id String Required Unique identifier for the unit of measure meters per second Abbreviation String Optional Abbreviation for the unit of measure m/s m s Name String Optional Full name for the unit of measure Meters per second DisplayName String Optional Friendly display name for the unit of measure meters per second QuantityId String Required The identifier associated with the quantity that this unit is a measure of Velocity ConversionFactor Double Required Used for unit conversions. When a value of this unit is multiplied by the ConversionFactor and then incremented by the ConversionOffset, the value in terms of the base unit of the corresponding quantity is returned. 1.0 ConversionOffset Double Required Used for unit conversions. See details for ConversionFactor 0.0 SdsUomQuantity Represents a single measurable quantity (for example, length) The following table shows the required and optional SdsUomQuantity fields. Property Type Optionality Details Example Id String Required Unique identifier for the quantity Velocity Name String Optional Full name for the quantity Velocity BaseUom SdsUom Required The base unit of measure for this quantity. All other Uom\u0027s measuring this quantity will have ConversionFactor\u0027s and ConversionOffsets relative to the BaseUom SdsUom representing \"meters per second\" Dimensions short[] Optional Reserved for internal use. Represents the seven base SI dimensions: Length, Mass, Time, Electric Current, Thermodynamic Temperature, Amount of Substance, and Luminous Density. [1,0,-1,0,0,0,0] Supported Quantities A list of the supported quantities and their base unit of measures is below. Supported quantities are read-only. Quantity Id Base Uom Id Angular Velocity radian per second Area square meter Computer Storage byte Density kilogram per cubic meter Dynamic Viscosity pascal second Electric Charge coulomb Electric Current ampere Electric Potential volt Electric Resistance ohm Energy joule Entropy and Heat Capacity joule per kelvin Force newton Frequency hertz Length meter Luminous Intensity candela Mass kilogram Mass Flow Rate kilogram per second Molar Flow Rate mole per second Molecular Weight kilogram per mole Amount of Substance mole Plane Angle radian Power watt Pressure pascal Quantity count Ratio percent Specific Energy joule per kilogram Specific Entropy and Specific Heat Capacity joule per kilogram kelvin Specific Volume cubic meter per kilogram Speed meter per second Temperature kelvin Temperature (Delta) delta kelvin Time second Volume cubic meter Volume Flow Rate cubic meter per second Supported Units of Measure A list of the supported units of measure is below. Supported units of measure are read-only. Uom Id Abbreviation Quantity Id Conversion Factor Conversion Offset count count Quantity 1 0 Ampere hour Ah Electric Charge 3600 0 coulomb C Electric Charge 1 0 kilogram per second kg/s kg s Mass Flow Rate 1 0 long ton per day lton/d lton d Mass Flow Rate 0.011759802 0 million pound per day MMlb/d MMlb d Mass Flow Rate 5.24991169 0 short ton per day ston/d ston d Mass Flow Rate 0.010499823 0 thousand pound per day klb/d klb d Mass Flow Rate 0.005249912 0 gram per second g/s g s Mass Flow Rate 0.001 0 pound per second lb/s lb s Mass Flow Rate 0.45359237 0 tonne per day t/d t d Mass Flow Rate 0.011574074 0 long ton lton Mass 1016.046909 0 million pound MM lb Mass 453592.37 0 ounce oz Mass 0.028349523 0 short ton ston Mass 907.18474 0 thousand pound klb Mass 453.59237 0 ton ton Mass 907.18474 0 gram g Mass 0.001 0 milligram mg Mass 1.00E-06 0 pound lb Mass 0.45359237 0 tonne t Mass 1000 0 kilogram kg Mass 1 0 second s Time 1 0 hour h Time 3600 0 day d Time 86400 0 month month Time 2628000 0 week week Time 604800 0 year yr Time 31536000 0 minute min Time 60 0 dyne dyne Force 1.00E-05 0 kilogram-force kgf Force 9.80665 0 pound-force lbf Force 4.448221615 0 newton N Force 1 0 watt W Power 1 0 million British thermal unit per day MM Btu/d Btu d Power 12211.29459 0 million British thermal unit per hour MM Btu/h Btu h Power 293071.0702 0 gigawatt GW Power 1000000000 0 megawatt MW Power 1000000 0 British thermal unit per hour Btu/h Btu h Power 0.29307107 0 calorie per second cal/s cal s Power 4.1868 0 horsepower hp Power 745.6998716 0 joule per second J/s J s Power 1 0 kilowatt kW Power 1000 0 megajoule per hour MJ/h MJ h Power 277.7777778 0 million calorie per hour MMcal/h MMcal h Power 1163 0 mole per second mol/s mol s Molar Flow Rate 1 0 gram mole per second gmol/s gmol s Molar Flow Rate 1 0 kilogram mole per second kmol/s kmol s Molar Flow Rate 1000 0 pound mole per second lbmol/s lbmol s Molar Flow Rate 453.59237 0 meter m Length 1 0 centimeter cm Length 0.01 0 inch in Length 0.0254 0 International nautical mile nmi Length 1852 0 kilometer km Length 1000 0 millimeter mm Length 0.001 0 foot ft Length 0.3048 0 mile mi Length 1609.344 0 sixteenth of an inch sxi Length 0.0015875 0 yard yd Length 0.9144 0 candela cd Luminous Intensity 1 0 meter per second m/s m s Speed 1 0 centimeter per second cm/s cm s Speed 0.01 0 foot per second ft/s ft s Speed 0.3048 0 International nautical mile per hour nmi/h nmi h Speed 0.514444444 0 kilometer per hour km/h km h Speed 0.277777778 0 mile per hour mi/h mi h Speed 0.44704 0 revolution per minute rpm Angular Velocity 0.104719755 0 radian per second rad/s rad s Angular Velocity 1 0 barrel per day bbl/d bbl d Volume Flow Rate 1.84E-06 0 cubic centimeter per second cm3/s cm3 s Volume Flow Rate 1.00E-06 0 cubic foot per second ft3/s ft3 s Volume Flow Rate 0.028316847 0 cubic meter per hour m3/h m3 h Volume Flow Rate 0.000277778 0 Imperial gallon per minute Imp gal/min gal min Volume Flow Rate 7.58E-05 0 liter per second L/s L s Volume Flow Rate 0.001 0 US gallon per minute US gal/min gal min Volume Flow Rate 6.31E-05 0 cubic meter per second m3/s m3 s Volume Flow Rate 1 0 pascal Pa Pressure 1 0 atmosphere atm Pressure 101325 0 bar bar Pressure 100000 0 inches of mercury inHg Pressure 3386.388158 0 kilogram-force per square centimeter kgf/cm2 kgf cm2 Pressure 98066.5 0 kilogram-force per square meter kgf/m2 kgf m2 Pressure 9.80665 0 kilopascal kPa Pressure 1000 0 millimeter of mercury mmHg Pressure 133.3223684 0 newton per square meter N/m2 N m2 Pressure 1 0 pound-force per square inch psi Pressure 6894.757293 0 pound-force per square inch (customary) psia Pressure 6894.757293 0 torr torr Pressure 133.3223684 0 square meter m2 Area 1 0 square foot ft2 Area 0.09290304 0 acre acre Area 4046.856422 0 square mile mi2 Area 2589988.11 0 square yard yd2 Area 0.83612736 0 hectare ha Area 10000 0 square centimeter cm2 Area 0.0001 0 square inch in2 Area 0.00064516 0 square kilometer km2 Area 1000000 0 square millimeter mm2 Area 1.00E-06 0 yobibyte YiB Computer Storage 1.21E+24 0 zebibyte ZiB Computer Storage 1.18E+21 0 exbibyte EiB Computer Storage 1.15E+18 0 pebibyte PiB Computer Storage 1.13E+15 0 tebibyte TiB Computer Storage 1.10E+12 0 gibibyte GiB Computer Storage 1073741824 0 mebibyte MiB Computer Storage 1048576 0 kibibyte KiB Computer Storage 1024 0 yottabyte YB Computer Storage 1.00E+24 0 zettabyte ZB Computer Storage 1.00E+21 0 exabyte EB Computer Storage 1.00E+18 0 petabyte PB Computer Storage 1.00E+15 0 terabyte TB Computer Storage 1.00E+12 0 gigabyte GB Computer Storage 1000000000 0 megabyte MB Computer Storage 1000000 0 kilobyte kB Computer Storage 1000 0 byte B Computer Storage 1 0 kelvin K Temperature 1 0 degree Celsius ??C Temperature 1 273.15 degree Rankine ??R Temperature 0.555555556 -2.56E-13 degree Fahrenheit ??F Temperature 0.555555556 255.3722222 milliampere mA Electric Current 0.001 0 ampere A Electric Current 1 0 joule per gram J/g J g Specific Energy 1000 0 joule per kilogram J/kg J kg Specific Energy 1 0 British thermal unit per pound Btu/lb Btu lb Specific Energy 2326 0 kilocalorie per kilogram kcal/kg kcal kg Specific Energy 4186.8 0 kilojoule per kilogram kJ/kg kJ kg Specific Energy 1000 0 kilojoule per pound kJ/lb kJ lb Specific Energy 2204.622622 0 British thermal unit per degree Rankine Btu/??R Btu ??R Entropy and Heat Capacity 1899.100535 0 British thermal unit per degree Fahrenheit Btu/??F Btu ??F Entropy and Heat Capacity 1899.100535 0 kilojoule per kelvin kJ/K kJ K Entropy and Heat Capacity 1000 0 joule per kelvin J/K J K Entropy and Heat Capacity 1 0 cubic foot per pound ft3/lb ft3 lb Specific Volume 0.062427961 0 cubic centimeter per gram cm3/g cm3 g Specific Volume 0.001 0 cubic meter per kilogram m3/kg m3 kg Specific Volume 1 0 hertz Hz Frequency 1 0 mole mol Amount of Substance 1 0 gram mole gmol Amount of Substance 1 0 kilogram mole kmol Amount of Substance 1000 0 pound mole lbmol Amount of Substance 453.59237 0 percent % Ratio 1 0 parts per billion ppb Ratio 1.00E-07 0 parts per million ppm Ratio 0.0001 0 ohm ?? Electric Resistance 1 0 gram per gram mole g/gmol g gmol Molecular Weight 0.001 0 pound per pound mole lb/lbmol lb lbmol Molecular Weight 0.001 0 kilogram per mole kg/mol kg mol Molecular Weight 1 0 kilogram per kilogram mole kg/kmol kg kmol Molecular Weight 0.001 0 British thermal unit per pound degree Rankine Btu/(lb Btu (lb ??R) Specific Entropy and Specific Heat Capacity 4186.8 0 British thermal unit per pound degree Fahrenheit Btu/(lb Btu (lb ??F) Specific Entropy and Specific Heat Capacity 4186.8 0 joule per gram kelvin J/(g J (g K) Specific Entropy and Specific Heat Capacity 1000 0 kilojoule per kilogram kelvin kJ/(kg kJ (kg K) Specific Entropy and Specific Heat Capacity 1000 0 joule per kilogram kelvin J/(kg J (kg K) Specific Entropy and Specific Heat Capacity 1 0 kilovolt kV Electric Potential 1000 0 millivolt mV Electric Potential 0.001 0 megavolt MV Electric Potential 1000000 0 volt V Electric Potential 1 0 joule J Energy 1 0 gigawatt hour GWh Energy 3.60E+12 0 megawatt hour MWh Energy 3600000000 0 watt hour Wh Energy 3600 0 British thermal unit Btu Energy 1055.055853 0 calorie cal Energy 4.1868 0 gigajoule GJ Energy 1000000000 0 kilojoule kJ Energy 1000 0 kilowatt hour kWh Energy 3600000 0 megajoule MJ Energy 1000000 0 watt second Ws Energy 1 0 kilocalorie kcal Energy 4186.8 0 million calorie MMcal Energy 4186800 0 million British thermal unit MM Btu Energy 1055055853 0 acre foot acre ft Volume 1233.481838 0 million imperial gallon Imp Mgal Volume 4546.09 0 thousand imperial gallon Imp kgal Volume 4.54609 0 barrel bbl Volume 0.158987295 0 Imperial gallon Imp gal Volume 0.00454609 0 million US gallon US Mgal Volume 3785.411784 0 thousand US gallon US kgal Volume 3.785411784 0 cubic centimeter cm3 Volume 1.00E-06 0 cubic foot ft3 Volume 0.028316847 0 kiloliter kL Volume 1 0 liter L Volume 0.001 0 megaliter M L Volume 1000 0 milliliter mL Volume 1.00E-06 0 thousand cubic meter k m3 Volume 1000 0 US gallon US gal Volume 0.003785412 0 million barrel MMbbl Volume 158987.2949 0 thousand barrel kbbl Volume 158.9872949 0 cubic meter m3 Volume 1 0 kilogram per cubic meter kg/m3 kg m3 Density 1 0 gram per liter g/L g L Density 1 0 kilogram per liter kg/L kg L Density 1000 0 pound per barrel lb/bbl lb bbl Density 2.853010174 0 pound per cubic foot lb/ft3 lb ft3 Density 16.01846337 0 pound per US gallon lb/US lb US gal Density 119.8264273 0 tonne per cubic meter t/m3 t m3 Density 1000 0 radian rad Plane Angle 1 0 degree ?? Plane Angle 0.017453293 0 revolution r Plane Angle 6.283185307 0 pascal second Pa*s Dynamic Viscosity 1 0 poise P Dynamic Viscosity 0.1 0 delta degree Fahrenheit delta ??F Temperature (Delta) 0.555555556 0 delta degree Rankine delta ??R Temperature (Delta) 0.555555556 0 delta kelvin delta K Temperature (Delta) 1 0 delta degree Celsius delta ??C Temperature (Delta) 1 0 SdsUomQuantity API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsUomQuantitys. When working in .NET, convenient SDS client libraries methods are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Units of Measure for general SdsUomQuantity information. Get Quantity Returns the quantity corresponding to the specified quantityId within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body The requested SdsUomQuantity. Example response body when quantityId = \"Length\" is passed HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\": \"Length\", \"Name\": \"Length\", \"BaseUom\": { \"Id\": \"meter\", \"Abbreviation\": \"m\", \"Name\": \"meter\", \"DisplayName\": \"meter\", \"QuantityId\": \"Length\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 1, 0, 0, 0, 0, 0, 0 ] } .NET client libraries method Task\u003cSdsUomQuantity\u003e GetQuantityAsync(string quantityId); Get Quantities Returns a list of all quantities available within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities?skip={skip}\u0026count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier int skip An optional parameter representing the zero-based offset of the first SdsUomQuantity to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsUomQuantity to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and a response body. Response body A list of SdsUomQuantity objects Example response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\": \"Angular Velocity\", \"Name\": \"Angular Velocity\", \"BaseUom\": { \"Id\": \"radian per second\", \"Abbreviation\": \"rad/s\", \"rad s\", \"Name\": \"radian per second\", \"DisplayName\": \"radian per second\", \"QuantityId\": \"Angular Velocity\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 0, 0, -1, 0, 0, 0, 0 ] }, { \"Id\": \"Area\", \"Name\": \"Area\", \"BaseUom\": { \"Id\": \"square meter\", \"Abbreviation\": \"m2\", \"Name\": \"square meter\", \"DisplayName\": \"square meter\", \"QuantityId\": \"Area\", \"ConversionFactor\": 1 }, \"Dimensions\": [ 2, 0, 0, 0, 0, 0, 0 ] }, ... ] .NET client libraries method Task\u003cIEnumerable\u003cSdsUomQuantity\u003e\u003e GetQuantitiesAsync(int skip = 0, int count = 100); Get Quantity Uom Returns the unit of measure associated with the specified uomId belonging to the quantity with the specified quantityId. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response body The requested SdsUom Example response body when quantityId = \"Length\" and uomId =\"mile\" are passed HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\": \"mile\", \"Abbreviation\": \"mi\", \"Name\": \"mile\", \"DisplayName\": \"mile\", \"QuantityId\": \"Length\", \"ConversionFactor\": 1609.344 } .NET client libraries method Task\u003cSdsUom\u003e GetQuantityUomAsync(string quantityId, string uomId); Get Quantity Uoms Returns the list of units of measure that belongs to the quantity with the specified quantityId. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body A collection of SdsUom objects for the specified quantity Example response body when quantityId = \"Electric Current\" is passed HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\": \"milliampere\", \"Abbreviation\": \"mA\", \"Name\": \"milliampere\", \"DisplayName\": \"milliampere\", \"QuantityId\": \"Electric Current\", \"ConversionFactor\": 0.001 }, { \"Id\": \"ampere\", \"Abbreviation\": \"A\", \"Name\": \"ampere\", \"DisplayName\": \"ampere\", \"QuantityId\": \"Electric Current\", \"ConversionFactor\": 1 } ] .NET client libraries method Task\u003cIEnumerable\u003cSdsUom\u003e\u003e GetQuantityUomsAsync(string quantityId); Get Quantities Access Control List Get the default ACL for the Quantities collection. For more information on ACLs, see Role-based access control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Quantities Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body The default ACL for Quantities .NET client libraries method Task\u003cAccessControlList\u003e GetQuantitiesAccessControlListAsync(); Update Quantities Access Control List Update the default ACL for the Quantities collection. For more information on ACLs, see Role-based access control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Quantities Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body Serialized ACL Response The response includes a status code. .NET client libraries method Task UpdateQuantitiesAccessControlListAsync(AccessControlList quantitiesAcl); Get Quantity Access Control List Get the ACL of the specified quantity. For more information on ACLs, see Role-based access control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body The ACL for the specified quantity .NET client libraries method Task\u003cAccessControlList\u003e GetQuantityAccessControlListAsync(string quantityId); Update Quantity Access Control List Update the ACL of the specified quantity. For more information on ACLs, see Role-based access control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Request body Serialized ACL Response The response includes a status code. .NET client libraries method Task UpdateQuantityAccessControlListAsync(string quantityId, AccessControlList quantityAcl); Get Quantity Owner Get the Owner of the specified quantity. For more information on Owners, see Role-based access control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body The Owner for the specified quantity .NET client libraries method Task\u003cTrustee\u003e GetQuantityOwnerAsync(string quantityId); Update Quantity Owner Update the Owner of the specified quantity. For more information on Owners, see Role-based access control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Request body Serialized Owner Response The response includes a status code. .NET client libraries method Task UpdateQuantityOwnerAsync(string quantityId, Trustee quantityOwner); Get Quantity Access Rights Gets the Access Rights associated with the specified quantity for the requesting identity. For more information on Access Rights, see Role-based access control . Request GET api/ api  v1/ v1  /   Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier Response The response includes a status code and a response body. Response body The Access Rights of the specified quantity for the requesting identity. Example response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [\"Read\", \"Write\"] .NET client libraries method Task\u003cstring[]\u003e GetQuantityAccessRightsAsync(string quantityId); SdsUom API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsUoms. When working in .NET, convenient SDS Client Libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Units of Measure for general SdsUom information. Get Uom Returns the unit of measure corresponding to the specified uomId within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Units/ Units  {uomId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response body The requested SdsUom Example response body when uomId = \"ounce\" is passed HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\": \"ounce\", \"Abbreviation\": \"oz\", \"Name\": \"ounce\", \"DisplayName\": \"ounce\", \"QuantityId\": \"Mass\", \"ConversionFactor\": 0.028349523 } .NET client libraries method Task\u003cSdsUom\u003e GetUomAsync(string uomId); Get Uoms Returns a list of all available units of measure in the system. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Units?skip={skip}\u0026count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier int skip An optional parameter representing the zero-based offset of the first SdsUomQuantity to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsUomQuantity to retrieve. If not specified, a default value of 100 is used. Response The response includes a status code and a response body. Response body A list of SdsUom objects Example response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\": \"count\", \"Abbreviation\": \"count\", \"Name\": \"count\", \"DisplayName\": \"count\", \"QuantityId\": \"Quantity\", \"ConversionFactor\": 1 }, { \"Id\": \"Ampere hour\", \"Abbreviation\": \"Ah\", \"Name\": \"Ampere hour\", \"DisplayName\": \"Ampere hour\", \"QuantityId\": \"Electric Charge\", \"ConversionFactor\": 3600 }, { \"Id\": \"coulomb\", \"Abbreviation\": \"C\", \"Name\": \"coulomb\", \"DisplayName\": \"coulomb\", \"QuantityId\": \"Electric Charge\", \"ConversionFactor\": 1 } ... ] .NET client libraries method Task\u003cIEnumerable\u003cSdsUom\u003e\u003e GetUomsAsync(int skip = 0, int count = 100); Get Uom Access Control List Get the ACL of the specified unit of measure. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId}/ {uomId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response body The ACL for the specified Uom .NET client libraries method Task\u003cAccessControlList\u003e GetQuantityUomAccessControlListAsync(string quantityId, string uomId); Update Uom Access Control List Update the ACL of the specified unit of measure. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId}/ {uomId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Request body Serialized ACL Response The response includes a status code. .NET client libraries method Task UpdateQuantityUomAccessControlListAsync(string quantityId, string uomId, AccessControlList uomAcl); Get Uom Owner Get the Owner of the specified unit of measure. For more information on Owners, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId}/ {uomId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response Body The Owner for the specified Uom .NET client libraries method Task\u003cTrustee\u003e GetQuantityUomOwnerAsync(string quantityId, string uomId); Update Uom Owner Update the Owner of the specified unit of measure. For more information on Owners, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId}/ {uomId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Request body Serialized Owner Response The response includes a status code. .NET client libraries method Task UpdateQuantityUomOwnerAsync(string quantityId, string uomId, Trustee uomOwner); Get Uom Access Rights Gets the Access Rights associated with the specified unit of measure for the requesting identity. For more information on Access Rights, see Access Control . Request GET api/ api  v1/ v1  /   Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Quantities/ Quantities  {quantityId}/ {quantityId}  Units/ Units  {uomId}/ {uomId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string quantityId The quantity identifier string uomId The unit of measure identifier Response The response includes a status code and a response body. Response Body The Access Rights of the specified unit of measure for the requesting identity. Example response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [\"Read\", \"Write\"] .NET client libraries method Task\u003cstring[]\u003e GetQuantityUomAccessRightsAsync(string quantityId, string uomId); Associating a unit of measure with a SdsType At SdsType creation, a SdsUom can be associated with a SdsTypeProperty . Associating a unit of measure with a SdsStream At SdsStream creation, you can override any unit of measure associated with a SdsTypeProperty belonging to the SdsType of the stream. This enables the reuse of a SdsType that may have default unit information associated with it already."
                                                                },
    "Documentation/SequentialDataStore/Data_Store_and_SDS.html":  {
                                                                      "href":  "Documentation/SequentialDataStore/Data_Store_and_SDS.html",
                                                                      "title":  "Sequential Data Store",
                                                                      "keywords":  "Sequential Data Store The Sequential Data Store (SDS) is a cloud-based streaming data storage that is optimized for storing sequential data, usually time-series, but anything that is indexed by an ordered sequence. You use SDS to store, retrieve, and analyze data. An SdsType (used interchangeably with type throughout documentation) defines the shape of a single measured event or object. A type gives structure to your data. For example, if you\u0027re measuring three things (longitute, latitude, speed) from a device at the same time, then you want those three properties to be included in your type. An SdsStream (used interchangeably with stream throughout documentation) is a collection of ordered events, or a series of events, where each event is an instance of the type you have defined. You create and write data to streams using a simple REST ( REpresentational State Transfer ) API ( Application Programming Interface ). The streams you create can be used to store simple or complex data types to suit your application needs. You can define simple or complex indexes to arrange and relate your data. An assortment of methods with customizable behaviors are available to read data and easily obtain needed information. Samples The best way to get started with SDS is to run one or more of the code samples. Code samples are provided in a number of different programming languages to illustrate how to easily and effectively interact with SDS. The code samples can be found in the OSI-Samples repository on GitHub. Obtain SDS REST API access keys from https://cloud.osisoft.com https:  cloud.osisoft.com before running the sample code. Each sample includes a readme file which describes the steps required to run the sample and a brief description that highlights some of the sample\u0027s functionality. Be sure to read the readme file to understand how the sample works. After you have finished this introduction and worked with one of the samples, refer to the Quick start section, which describes the interaction of various SDS objects and helps you get started with your own application."
                                                                  },
    "Documentation/SequentialDataStore/Compression.html":  {
                                                               "href":  "Documentation/SequentialDataStore/Compression.html",
                                                               "title":  "Compression",
                                                               "keywords":  "Compression To more efficiently utilize network bandwidth, the OCS Sequential Data Store supports compression for reading data and writing data through the REST API. Supported compression schemes gzip deflate Request compression (writing data) The body content of an HTTP request can be compressed using the supported compression schemes allowing you to send stream values to the REST API more efficiently. The Content-Encoding HTTP header must be used to specify the compression scheme of compressed-content requests. This header provides context to the API to properly decode the request content. Response compression (reading data) Compressed responses can be requested from the REST API by specifying one of the supported compression schemes using the Accept-Encoding HTTP header. Compressed responses from the REST API will include a Content-Encoding HTTP header indicating the compression scheme used to compress the response content. Note that specifying a compression scheme through the use of the Accept-Encoding HTTP header does not guarantee a compressed response. Always refer to presence and value of the Content-Encoding HTTP header of the response to properly decode the response content."
                                                           },
    "Documentation/SequentialDataStore/Writing_Data_API.html":  {
                                                                    "href":  "Documentation/SequentialDataStore/Writing_Data_API.html",
                                                                    "title":  "API calls for writing data",
                                                                    "keywords":  "API calls for writing data Example Type, Stream, and Data Many of the API methods described below contain example requests and responses in JSON to highlight usage and specific behaviors. The following type, stream, and data are used in the examples. Example Type SimpleType is an SdsType with a single index and two additional properties. This type is defined below in .NET, Python, and Javascript: .NET public enum State { Ok, Warning, Alarm } public class SimpleType { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } [SdsMember(Uom = \"meter\")] public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class SimpleType(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var SimpleType = function () { this.Time = null; this.State = null; this.Value = null; } Example Stream Simple is an SdsStream of type SimpleType . Example Data Simple has stored values as follows: 11/ 11  23/ 23  2017 12:00:00 PM: Ok 0 11/ 11  23/ 23  2017 1:00:00 PM: Ok 10 11/ 11  23/ 23  2017 2:00:00 PM: Ok 20 11/ 11  23/ 23  2017 3:00:00 PM: Ok 30 11/ 11  23/ 23  2017 4:00:00 PM: Ok 40 All times are represented at offset 0, GMT. Insert Values Inserts data into the specified stream. Returns an error if data is already present at the index of any event. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request Body A serialized list of one or more events of the stream type Response The response includes a status code Notes This request will return an error if an event already exists for any index in the request. If any individual index encounters a problem, the entire operation is rolled back and no insertions are made. The streamId and index that caused the issue are included in the error response. Example The following request is used to insert events into stream Simple of SimpleType , POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data where the request body specifies the values to insert: [ { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 50 }, { \"Time\": \"2017-11-23T18:00:00Z\", \"State\": 0, \"Measurement\": 60 } ] .NET Library Task InsertValueAsync\u003cT\u003e(string streamId, T item); Task InsertValuesAsync\u003cT\u003e(string streamId, IList\u003cT\u003e items); Patch Values Modifies the specified stream event(s). Patching affects only the data item parameters that are included in the call. Request PATCH api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?select={selectExpression} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string selectExpression Comma separated list of strings that indicates the event fields that will be changed in stream events Request Body A serialized collection of one or more patch property events Response The response includes a status code Consider you have a stream Simple of SimpleType , to change one property, Measurement , for one event specify the following request PATCH api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?select=measurement With the following request body, [ { \"Time\":\"2017-11-23T12:00:00Z\", \"Measurement\":500.0 } ] This request will only change the Measurement value at the specified event index. Notes Patching is used to patch the events of the selected fields for one or more events in the stream. Only the fields indicated in selectExpression are modified. The events to be modified are indicated by the index value of each entry in the collection. If there is a problem patching any individual event, the entire operation is rolled back and the error will indicate the streamId and index of the problem. .NET Library Task PatchValueAsync(string streamId, string selectExpression, T item); Task PatchValuesAsync(string streamId, string selectExpression, IList\u003cT\u003e items); Remove Values There are two options for specifying which events to remove from a stream: Index Collection : One or more indexes can be specified in the request. Window : A window can be specified with a start index and end index. Index Collection Removes the event at each index from the specified stream. Different overloads are available to make it easier to indicate the index where you want to remove a data event. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?index={index}[\u0026index={index}???] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index One or more indexes of events to remove Response The response includes a status code Notes If any individual event fails to be removed, the entire operation is rolled back and no events are removed. The streamId and index that caused the issue are included in the error response. If you attempt to remove events at indexes that have no events, an error is returned. If this occurs, you can use Window request format to remove any events from a specified ???window??? of indexes, which will not return an error if no data is found. .NET Library Task RemoveValueAsync(string streamId, string index); Task RemoveValueAsync\u003cT1\u003e(string streamId, T1 index); Task RemoveValueAsync\u003cT1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e index); Task RemoveValuesAsync(string streamId, IEnumerable\u003cstring\u003e index); Task RemoveValuesAsync\u003cT1\u003e(string streamId, IEnumerable\u003cT1\u003e index); Task RemoveValuesAsync\u003cT1, T2\u003e(string streamId, IEnumerable\u003cTuple\u003cT1, T2\u003e\u003e Window Removes events at and between the start index and end index. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026endIndex={endIndex} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The index defining the beginning of the window string endIndex The index defining the end of the window Response The response includes a status code Notes If any individual event fails to be removed, the entire operation is rolled back and no removes are done. .NET Library Task RemoveWindowValuesAsync(string streamId, string startIndex, string endIndex); Task RemoveWindowValuesAsync\u003cT1\u003e(string streamId, T1 startIndex, T1 endIndex); Task RemoveWindowValuesAsync\u003cT1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex); Replace Values Writes one or more events over existing events in the specified stream. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?allowCreate=false Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request Body A serialized list of one or more events of the stream type Response The response includes a status code Notes This request returns an error if the stream does not have an event to be replaced at the specified index. If any individual event fails to be replaced, the entire operation is rolled back and no replaces are performed. The index that caused the issue and the streamId are included in the error response. .NET Library Task ReplaceValueAsync\u003cT\u003e(string streamId, T item); Task ReplaceValuesAsync\u003cT\u003e(string streamId, IList\u003cT\u003e items); Update Values Writes one or more events to the specified stream. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request Body A serialized list of one or more events of the stream type Response The response includes a status code Notes This request performs an insert or a replace depending on whether an event already exists at the event indexes. If any item fails to write, the entire operation is rolled back and no events are written to the stream. The index that caused the issue is included in the error response. .NET Library Task UpdateValueAsync\u003cT\u003e(string streamId, T item); Task UpdateValuesAsync\u003cT\u003e(string streamId, IList\u003cT\u003e items);"
                                                                },
    "Documentation/SequentialDataStore/Writing_Data.html":  {
                                                                "href":  "Documentation/SequentialDataStore/Writing_Data.html",
                                                                "title":  "Write data",
                                                                "keywords":  "Write data The SDS REST APIs provide programmatic access to read and write SDS data. This section describes the APIs used to write SdsStream data. When working in .NET, convenient SDS Client libraries are available. The ISdsDataService interface, accessed using the SdsService.GetDataService() helper, defines the available functions. All writes rely on a stream???s key or primary index. The primary index determines the order of events in the stream. Secondary indexes are updated, but they do not contribute to the request. All references to indexes are to the primary index. Single Stream Writes The following support writing multiple values: Insert Values inserts a collection of events. Patch Values updates specific fields for a collection of events. Replace Values replaces a collection of events. Remove Values deletes the events based on the request parameters. Update Values add or replaces a collection of events. The base URI for writing SDS data to a single stream is: api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request Body Format With the exception of Remove Values, all single stream write calls require a request body containing the events to insert or modify. The events must be formatted as a serialized JSON array of the stream\u0027s type. JSON arrays are comma-delimited lists of a type enclosed within square brackets. The following code shows a list of three WaveData events that are properly formatted for insertion. See the OCS-Samples for the complete example. [ { \"Order\":2, \"Tau\":0.25722883666666846, \"Radians\":1.6162164471269089, \"Sin\":1.9979373673043652, \"Cos\":-0.090809010174665111, \"Tan\":-44.003064529862513, \"Sinh\":4.8353589272389, \"Cosh\":5.2326566823391856, \"Tanh\":1.8481468289554672 }, { \"Order\":4, \"Tau\":0.25724560000002383, \"Radians\":1.6163217742567466, \"Sin\":1.9979277915696148, \"Cos\":-0.091019446679060964, \"Tan\":-43.901119254534827, \"Sinh\":4.8359100947709592, \"Cosh\":5.233166005842703, \"Tanh\":1.8481776000882766 }, { \"Order\":6, \"Tau\":0.25724560000002383, \"Radians\":1.6163217742567466, \"Sin\":1.9979277915696148, \"Cos\":-0.091019446679060964, \"Tan\":-43.901119254534827, \"Sinh\":4.8359100947709592, \"Cosh\":5.233166005842703, \"Tanh\":1.8481776000882766 } ] You can serialize your data using one of many available JSON serializers available at Introducing JSON . Response Format Supported response formats include JSON, verbose JSON, and SDS. The default response format for SDS is JSON, which is used in all examples in this document. Default JSON responses do not include any values that are equal to the default value for their type. Verbose JSON responses include all values in the returned JSON payload, including defaults. To specify verbose JSON return, add the header Accept-Verbosity with a value of verbose to the request. Verbose has no impact on writes; writes return only error messages. To specify SDS format, set the Accept header in the request to application/ application  sds . Indexes SDS writes rely on the primary index for positioning within streams and locating existing events. Most writes use the index as specified by the value. Deletes are the exception to this rule. When deleting, indexes are specified as strings in the URI, or, when using the SDS Client Libraries, the index may be passed as-is to delete methods that take the index type as a generic argument. More details about working with indexes can be found on the Indexes page. To specify compound indexes in the URI, specify each field that composes the index, in the specified order, separated by the pipe character, ???|???."
                                                            },
    "Documentation/Management/Account_RootAccessControl_1.html":  {
                                                                      "href":  "Documentation/Management/Account_RootAccessControl_1.html",
                                                                      "title":  "Root AccessControl",
                                                                      "keywords":  "Root AccessControl APIs to manage default access to entities governed by an AccessControlList . Get Root Namespace AccessControlList Retrieves the AccessControlList that is used to authorize access to a Namespace if none is specified during creation. HTTP GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AccessControl/ AccessControl  Namespaces Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. Security A root AccessControlList can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 AccessControlList Returns the root AccessControlList for Namespaces . 400 Nothing is returned Could not retrieve the root AccessControlList for Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve the root AccessControlList for Namespaces . Set Root AccessControlList Modifies the AccessControlList that is used to authorize access to a Namespace if none is specified during creation. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AccessControl/ AccessControl  Namespaces Parameters [Required] [FromRoute] string tenantId The identifier of the account to modify. [Required] [FromBody] AccessControlList newAccessControlList The new root AccessControlList for Namespaces . Security A root AccessControlList can only be modified if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 AccessControlList Returns the modified root AccessControlList for Namespaces . 400 Nothing is returned Could not modify the root AccessControlList for Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to change the root AccessControlList for Namespaces . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL."
                                                                  },
    "Documentation/Management/Account_Role_1.html":  {
                                                         "href":  "Documentation/Management/Account_Role_1.html",
                                                         "title":  "Roles",
                                                         "keywords":  "Roles A Role is used to manage access within an OSIsoft Cloud Services (OCS) account. All users are assigned the Account Member role by default. There are two predefined Roles for OCS accounts. Check the user or client role APIs for more information. Account Administrator Account Member Properties For HTTP requests and responses, the Role object has the following properties and JSON-serialized body: Property Type Description Id string Gets or sets unique identifier for this Role. Generated by the server upon Creation. Name string Gets or sets name of this Role. Description string Gets or sets description of this Role. RoleScope RoleScope Gets or sets scope of this Role. CommunityId string Gets or sets unique identifier of Community for this Role, if this is a Community Role, null otherwise. RoleTypeId string Gets or sets unique identifier of Role Type for this Role, if this is a Account Role and is not a customer defined Role. { \"Id\": \"id\", \"Name\": \"name\", \"Description\": \"description\", \"RoleScope\": 0, \"CommunityId\": \"communityid\", \"RoleTypeId\": \"roletypeid\" } Create Account Role Creates a new account Role . Http POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromBody] Role role The new Role to be created. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 201 Role Returns the new Role . 302 Nothing is returned Returns the location of the existing Role object. 400 Nothing is returned Could not create a new Role due to missing or invalid input. 403 Nothing is returned Unauthorized to create the new Role in the specified account. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. 409 Nothing is returned A Role already exists with different values. Delete Account Role Deletes any Account scoped, non built-in Role by its Role Id. Http DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Roles/ Roles  {roleId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string roleId The identifier of the Role to delete. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 204 Nothing is returned The Role was deleted. 400 Nothing is returned Could not delete specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to delete the specified Role . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Get Account Role Retrieves an account Role based on the specified account Id and role Id. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Roles/ Roles  {roleId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string roleId The identifier of the Role to return. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Role Returns the Role with with specified Id roleId. 400 Nothing is returned Could not retrieve the specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve account Roles from this account. Get Account Roles Retrieves all account Roles for the specified Account Id. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Optional] [Default = \"0\"] [FromQuery] int32 skip Number of Roles to ignore. [Optional] [Default = \"100\"] [FromQuery] int32 count Number of Roles to be returned. [Optional] [Default = \"\"] [FromRoute] string query Unsupported parameter. Security Authorized for Account Members of the specified account. Returns Status Code Return Type Description 200 [Role] Returns a list of Roles . 400 Nothing is returned Could not retrieve account Roles due to missing or invalid input. Update Account Role Updates a Role by its Role Id. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Roles/ Roles  {roleId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string roleId The identifier of the Role to update. [Required] [FromBody] Role role The updated Role for this request. Security Authorized for Account Administrators of the specified account. Returns Status Code Return Type Description 200 Role Returns the updated Role with Id roleId. 400 Nothing is returned Could not update specified Role due to missing or invalid input. 403 Nothing is returned Unauthorized to update the Role in the specified account. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL."
                                                     },
    "Documentation/Management/Account_Namespace_1.html":  {
                                                              "href":  "Documentation/Management/Account_Namespace_1.html",
                                                              "title":  "Namespaces",
                                                              "keywords":  "Namespaces A Namespace is a collection of SDS types, streams, and stream views. Namespace identifiers are unique within an account. Requirements for Namespace IDs are the following: Must contain 100 characters or fewer Must only contain alphanumeric characters, underscores, dashes, spaces, and periods Must not contain two consecutive periods Must not start or end with a period Must not start with two consecutive underscores Properties For HTTP requests and responses, the Namespace object has the following properties and JSON-serialized body: Property Type Description Id string Gets or sets name of this Namespace; unique within a Tenant\u0027s Namespaces. Region string Gets or sets the region that the namespace is provisioned in. Self string Gets or sets the namespace\u0027s URI. Description string Gets or sets description of this Namespace. State NamespaceProvisioningState Gets or sets current state of this Namespace. { \"Id\": \"id\", \"Region\": \"region\", \"Self\": \"self\", \"Description\": \"description\", \"State\": 0, } Region When a namespace is created, all resources are created in the namespace\u0027s region. Resources created in this namespace (e.g. SDS types, streams, and stream views) will be created in the region of the namespace, and any data stored in the namespace will be stored in that region. Read and write operations at the namespace level and within a namespace utilize the base URL of the region in which the namespace resides. The Self property on each namespace provides the complete URL for all operations within that namespace. Get All Namespaces Returns all Namespaces owned by the specified Tenant that the caller has access to. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. Security A Namespace can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 [Namespace] Returns a list of all Namespace objects for the specified tenantId that the caller has access to. 400 Nothing is returned Could not retrieve Namespaces due to missing or invalid input. 403 Nothing is returned Unauthorized to access the tenant\u0027s Namespaces . Get Namespace By Id Returns a Namespace with the specified Id. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to return. Security A Namespace can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 Namespace Returns a Namespace object with the specified namespaceId. 400 Nothing is returned Could not retrieve the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to access this Namespace . 404 Nothing is returned Namespace not found in the specified account. Create New Namespace Creates a new Namespace in the specified Tenant . Http POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId?} Parameters [Required] [FromRoute] string tenantId The account identifier where the Namespace will be created. [Required] [FromBody] Namespace namespaceToCreate The new Namespace to be created. [Optional] [Default = \"\"] [FromRoute] string namespaceId The Id of the new Namespace . The Id can also be specified in the namespaceToCreate. If it is omitted in both, the Id will be generated. Security A Namespace can only be created if the current principal has Write access. Returns Status Code Return Type Description 201 Namespace Returns the created Namespace object. 302 Nothing is returned Returns the location of the existing Namespace object. 400 Nothing is returned Could not create the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to create a Namespace in this account. 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. 409 Nothing is returned A Namespace already exists with different values. Update Namespace Updates Namespace information: Description and TierId. The AccessControlList and Owner\u0027s Trustee can only be updated through their own routes. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to update. [Required] [FromBody] Namespace newProperties The new details to store for the Namespace . Security A Namespace can only be updated if the current principal has Write access. Returns Status Code Return Type Description 200 Namespace Returns the updated Namespace . 400 Nothing is returned Could not update the Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to update the Namespace . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Delete Namespace Deletes a Namespace in the specified Tenant . Http DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId} Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to delete. Security A Namespace can only be deleted if the current principal has Delete access. Returns Status Code Return Type Description 204 Nothing is returned The Namespace was deleted. 400 Nothing is returned Could not delete the Namespace due to an invalid state. 403 Nothing is returned Unauthorized to delete the Namespace . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Get Namespace AccessControlList Returns the AccessControlList that is used to authorize access to a Namespace . Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  accesscontrol Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to access. Security An AccessControlList can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 AccessControlList Returns the AccessControlList for the specified Namespace . 400 Nothing is returned Could not retrieve the AccessControlList of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to get the AccessControlList for the specified Namespace . Set Namespace AccessControlList Updates the AccessControlList that is used to authorize access to a Namespace . Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  accesscontrol Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to access. [Required] [FromBody] AccessControlList newAccessControlList The updated AccessControlList for the Namespace . Security An AccessControlList can only be updated if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 AccessControlList Returns the updated AccessControlList . 400 Nothing is returned Could not update the AccessControlList of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to update the AccessControlList for the specified Namespace . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Get Namespace Owner Returns the Owner\u0027s Trustee for a given Namespace . Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  owner Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to access. Security An Owner\u0027s Trustee can only be retrieved if the current principal has Read access. Returns Status Code Return Type Description 200 Trustee Returns the Owner\u0027s Trustee of the specified Namespace . 400 Nothing is returned Could not retrieve the Owner\u0027s Trustee of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to get the Owner\u0027s Trustee of the specified Namespace . Set Namespace Owner Changes the Owner\u0027s Trustee for a given Namespace . Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  owner Parameters [Required] [FromRoute] string tenantId The identifier of the account to access. [Required] [FromRoute] string namespaceId The identifier of the Namespace to access. [Required] [FromBody] Trustee newOwner The new Owner\u0027s Trustee of the Namespace . Security An Owner\u0027s Trustee can only be changed if the current principal has ManageAccessControl access. Returns Status Code Return Type Description 200 Trustee Returns the new Owner\u0027s Trustee of the specified Namespace . 400 Nothing is returned Could not change the Owner\u0027s Trustee of the specified Namespace due to missing or invalid input. 403 Nothing is returned Unauthorized to change the Owner\u0027s Trustee of the specified Namespace . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL."
                                                          },
    "Documentation/Management/Account_ClientRole_1.html":  {
                                                               "href":  "Documentation/Management/Account_ClientRole_1.html",
                                                               "title":  "Client Roles",
                                                               "keywords":  "Client Roles Client Roles authorize API requests made by clients to various OCS features. Clients can be assigned more than one Role , but all clients have the Account Member role. The following are currently available Client Roles : Account Administrator: Can add, edit, and remove data using APIs. Account Member: Can read data using most APIs. Properties For HTTP requests and responses, the ClientRole object has the following properties and JSON-serialized body: Property Type Description ClientId string Client Id. RoleId string Role Id. { \"ClientId\": \"clientid\", \"RoleId\": \"roleid\" } Replace Client Roles Replaces the Roles of a client with a new list of roles. Http PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Clients/ Clients  {clientId}/ {clientId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier of the account to which the client belongs. [Required] [FromRoute] string clientId The identifier of the client whose Roles will be replaced. [Required] [FromBody] [Role] roleList List of Role objects to set as the Roles for the specified client. Security Roles of a client can only be replaced by an Account Administrator. Returns Status Code Return Type Description 200 [Role] Returns a list of all Role objects assigned to the user specified by clientId after the replacement operation is complete. 400 Nothing is returned Could not replace Roles due to missing or invalid input. 403 Nothing is returned Unauthorized to replace Roles of this client. 404 Nothing is returned The client was not found in the specified Tenant . 405 Nothing is returned Method not allowed at this base URL. Try the request again at the Global base URL. Find Client Roles Retrieves all Roles from a client. Http GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Clients/ Clients  {clientId}/ {clientId}  Roles Parameters [Required] [FromRoute] string tenantId The identifier of the account to which the client belongs. [Required] [FromRoute] string clientId The identifier of the client whose Roles will be retrieved. [Optional] [Default = \"0\"] [FromQuery] int32 skip Number of Roles to ignore. [Optional] [Default = \"100\"] [FromQuery] int32 count Number of Roles to return. [Optional] [Default = \"\"] [FromRoute] string query Unsupported parameter. Security Roles can be retrieved by an Account Administrator. Returns Status Code Return Type Description 200 [Role] Returns a list of Role objects belonging to the client with the specified clientId. 400 Nothing is returned Could not retrieve Roles from the client due to missing or invalid input. 403 Nothing is returned Unauthorized to retrieve Roles from this client. 404 Nothing is returned The client was not found in the specified Tenant ."
                                                           },
    "Documentation/Identity/Identity_AzureActiveDirectoryTenant.html":  {
                                                                            "href":  "Documentation/Identity/Identity_AzureActiveDirectoryTenant.html",
                                                                            "title":  "AzureActiveDirectoryTenant",
                                                                            "keywords":  "AzureActiveDirectoryTenant An Azure Active Directory Tenant is used to map an existing Azure Active Directory Tenant from Azure to OSIsoft Cloud Services. We only allow one Azure Active Directory Tenant per OSIsoft Cloud Services Tenant. Properties For HTTP requests and responses, the AzureActiveDirectoryTenant object has the following properties and JSON-serialized body: Property Type Description Id string Gets or sets id of an Azure Active Directory Tenant. ConsentState ConsentState Gets or sets Consent State of Azure Active Directory Tenant. Can be: NotConsented (0), Consented (1). Serialized Model { \"Id\": \"Id\", \"ConsentState\": 0 } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Add Azure Active Directory Tenant to OCS Tenant Add an Azure Active Directory Tenant to the OSIsoft Cloud Services Tenant. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants/ AzureActiveDirectoryTenants  {azureActiveDirectoryTenantId} Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [Required] string azureActiveDirectoryTenantId Id or Domain Name of Azure Active Directory Tenant. Security Allowed for these roles: Account Administrator Returns 201 Created. Type: AzureActiveDirectoryTenant { \"Id\": \"Id\", \"ConsentState\": 0 } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Id of Azure Active Directory Tenant. is already in use on the specified Tenant. 500 Internal server error. Get All Azure Active Directory Tenants from OCS Tenant Get all Azure Active Directory Tenants from an OSIsoft Cloud Services Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of Azure Active Directory tenants to skip. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of Azure Active Directory tenants to return. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"Id\": \"Id\", \"ConsentState\": 0 }, { \"Id\": \"Id\", \"ConsentState\": 0 } ] 401 Unauthorized. 403 Forbidden. 403 Forbidden. 500 Internal server error. Get AAD Tenant from OCS Tenant Get Azure Active Directory Tenant from an OSIsoft Cloud Services Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants/ AzureActiveDirectoryTenants  {azureActiveDirectoryTenantId} Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [Required] string azureActiveDirectoryTenantId Id of Azure Active Directory Tenant. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: AzureActiveDirectoryTenant { \"Id\": \"Id\", \"ConsentState\": 0 } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 500 Internal server error. Remove AAD Tenant from OCS Tenant Remove Azure Active Directory Tenant from an OSIsoft Cloud Services Tenant. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants/ AzureActiveDirectoryTenants  {azureActiveDirectoryTenantId} Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [Required] string azureActiveDirectoryTenantId Id of Azure Active Directory Tenant to remove. Security Allowed for these roles: Account Administrator Returns 204 Removed. 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Send Consent Email for AAD Tenant Send consent for an Azure Active Directory Tenant. OSIsoft Cloud Services needs to be granted permission to interact with the Azure Active Directory tenant. Otherwise, users from this Azure Active Directory Tenant cannot accept invitations from OSIsoft Cloud Services and log in. You can read more about this here . Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants/ AzureActiveDirectoryTenants  {azureActiveDirectoryTenantId}/ {azureActiveDirectoryTenantId}  SendConsent Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [Required] string azureActiveDirectoryTenantId Id of Azure Active Directory Tenant. [FromBody] [Required] ConsentInformation consentInformation ConsentInformation object. Property Type Required Description AzureActiveDirectoryConsentEmail string Yes Gets or sets address to email consent. Only Azure Active Directory Admins have permission to consent to being allowed to interact with the tenant. The email does not have to be sent to an Admin. AzureActiveDirectoryConsentGivenName string Yes Gets or sets preferred name to use in the consent email. AzureActiveDirectoryConsentSurname string Yes Gets or sets preferred surname to use in the consent email. AzureActiveDirectoryTenant string Yes Gets or sets Azure Active Directory Domain Name (e.g. mydomain.onmicrosoft.com). { \"AzureActiveDirectoryConsentEmail\": \"user@company.com\", \"AzureActiveDirectoryConsentGivenName\": \"Name\", \"AzureActiveDirectoryConsentSurname\": \"Surname\", \"AzureActiveDirectoryTenant\": \"AzureActiveDirectoryTenant\" } Security Allowed for these roles: Account Administrator Returns 204 Removed. 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Azure Active Directory Tenant in Tenant Validate that Azure Active Directory Tenant exists in this OSIsoft Cloud Services Tenant. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants/ AzureActiveDirectoryTenants  {azureActiveDirectoryTenantId} Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. [Required] string azureActiveDirectoryTenantId Id of Azure Active Directory Tenant. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 500 Internal server error. Get Total Count of Azure Active Directory Tenant in Tenant Return total number of Azure Active Directory tenants in a OSIsoft Cloud Services Tenant. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AzureActiveDirectoryTenants Parameters [Required] string tenantId Id of OSIsoft Cloud Services Tenant. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 OSIsoft Cloud Services Tenant not found. 500 Internal server error."
                                                                        },
    "Documentation/Identity/Identity_AuthorizationCodeClient.html":  {
                                                                         "href":  "Documentation/Identity/Identity_AuthorizationCodeClient.html",
                                                                         "title":  "AuthorizationCodeClient",
                                                                         "keywords":  "AuthorizationCodeClient Authorization Code clients are used in Javascript/Browser Javascript Browser (SPA) based applications or native mobile applications with the presence of a User. These clients are issued an ID. You can read more about these clients here . Authorization Code clients are not issued secrets or refresh tokens. Properties For HTTP requests and responses, the AuthorizationCodeClient object has the following properties and JSON-serialized body: Property Type Description AllowedCorsOrigins string[] Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. RedirectUris string[] Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string Gets or sets URI to a page with information about client (used on consent screen). LogoUri string Gets or sets URI to client logo (used on consent screen). Id string Gets or sets client ID for this client. This ID should be a GUID. Name string Gets or sets name of Client. Enabled bool Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] Gets or sets for OSIsoft internal use only. Serialized Model { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Create an Authorization Code Client Create an Authorization Code flow Client. No Secret will be generated for this Client. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] AuthorizationCodeClient authorizationCodeClient New AuthorizationCodeClient object. Property Type Required Description AllowedCorsOrigins string[] No Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: AuthorizationCodeClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 400 Missing or invalid inputs, or Client limit exceeded. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Client Id already exists. 500 Internal server error. Update an Authorization Code Client Update an Authorization Code Client. It can take up to one hour for update to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients/ AuthorizationCodeClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] AuthorizationCodeClient authorizationCodeClient Updated Authorization Code Client values. Properties that are not set or are null will not be changed. Property Type Required Description AllowedCorsOrigins string[] No Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: AuthorizationCodeClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 400 Missing or invalid inputs. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get an Authorization Code Client from Tenant Get an Authorization Code Client from Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients/ AuthorizationCodeClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: AuthorizationCodeClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get All Authorization Code Clients from Tenant Get all Authorization Code clients from a Tenant. Optionally, get a list of requested clients. Total number of clients in the Tenant set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of ids for all clients to get. Empty or whitespace Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only return Clients that have these tags. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. From query. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] }, { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } ] 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Get Total Count Authorization Code Clients from Tenant Return total number of Authorization Code clients in a Tenant. Optionally, check based on a list of requested clients. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of ids for all clients to get. Empty or whitespace Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only count Clients that have these tags. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Delete an Authorization Code Client Delete an Authorization Code Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued to this client will be valid until their expiration. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients/ AuthorizationCodeClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Authorization Code Client Validate that an Authorization Code Client exists in Tenant. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  AuthorizationCodeClients/ AuthorizationCodeClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientCredentialClient 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error."
                                                                     },
    "Documentation/Identity/Consent.html":  {
                                                "href":  "Documentation/Identity/Consent.html",
                                                "title":  "AAD Consent to OSIsoft Applications",
                                                "keywords":  "AAD Consent to OSIsoft Applications You have chosen to use your organization???s existing Azure Active Directory (AAD) to sign in to your OSIsoft Cloud Services (OCS) account. In order to proceed, you first need to complete a consent workflow. In this step, your AAD administrator will grant permissions for OCS Identity to do the following: Sign in and read user profile basic information (delegated permission). Below are the next steps required to complete your OCS account provisioning: An email will be sent to your AAD administrator who has the privileges to grant OCS access to your AAD. Your administrator will click on the link provided in the email. Note that your administrator will need to log in as a user with the Global Administrator role on your AAD. Upon login, your administrator will be prompted to grant consent for a single application: OCS Identity. Your administrator should select the box \"Consent on behalf of the organization\" before clicking the consent button. OSIsoft will get a confirmation that the consent process has been completed. Then, a second email will be sent to the initial user who signed up for the account. At that point, this initial user will be able to use the link provided to activate his profile and sign in your OCS account."
                                            },
    "Documentation/DataViews/Securing_Data_Views.html":  {
                                                             "href":  "Documentation/DataViews/Securing_Data_Views.html",
                                                             "title":  "Securing Data Views",
                                                             "keywords":  "Securing Data Views Access rights to data views and their data are configurable in several ways. Permissions to the overall data views collection govern which users may create data views, and are also used as the default permissions for each data view that is created. Access to each data view is independently configurable. Finally, the permissions set on each Stream apply globally within OSIsoft Cloud Services, including within the data views feature. This section covers information specific to access control within the data views feature. For background information about access control throughout OSIsoft Cloud Services and how to configure the access control objects, see Role-based access control . Data Views Collection Access Control The data views collection access control list is used to control which users and clients are authorized to create data views. Only users and clients with \"Write\" access rights can create data views. See CommonAccessRightsEnum for a complete list of available access rights. The data views collection access control list also determines the default access control list for individual data views. Note that changing the collection level access control list does not affect existing data views as the collection level access control list is only used when the data view is first created. Once the data view exists, data view level access control is managed independently of collection level access control. See Data Views Access Control for more information on securing individual data views. When a namespace is first created, the data views collection access control list will default to the access control list for the entire namespace. Use the API routes in Access Control API to view and update the data views collection access control list. Only users and clients with ManageAccessControl rights on the data views collection are authorized to view and update the collection-level access control list. Data View Access Control Data views are secured individually. This allows granular control over who can see which data view, in order to restrict access to sensitive or compartmentalized information. Each data view has two child resources that control authorization: the data view access control list and the data view owner. See Role-based access control for more information about the access control list and owner objects. Owner authorization supersedes access control list authorization. The owner (typically the user or client that created the data view) has full access to the data view regardless of the access control list. The data view owner and access control list control basic authorization to a given data view. See the table below for the required access rights for each operation that can be performed against a data view. For the full list of available access rights, see CommonAccessRightsEnum . Operation Required access rights Create Write on the data views collection (see Collection Access Control ) Read Read Update Write Delete Delete Read access control ManageAccessControl Update access control ManageAccessControl Data Access Control The access control rights of each stream (see Streams ) apply globally within OSIsoft Cloud Services, including within data views. When a data view resolves per-user, each stream Query is executed with the user\u0027s own permissions, honoring the access control configured for each stream. Read access to a data view does not affect the user\u0027s read access to (or even the visibility of!) any streams. When you inspect the data items that resolve for a data view, you see only the streams that you have Read access to. Configuring access control for streams is similar to data views. See the Role-based access control and Streams sections for more information."
                                                         },
    "Documentation/DataViews/Getting_Data.html":  {
                                                      "href":  "Documentation/DataViews/Getting_Data.html",
                                                      "title":  "Getting Data",
                                                      "keywords":  "Getting Data Data view data is retrieved by using the Data API . The supported mode of retrieval is interpolated values within a user-specified range. Several formats are available, such as JSON and CSV. Index All data in a data view is associated with an index value, i.e. a timestamp. If there are multiple sections in the data view, the index and sectioner values together form a unique identifier for each data record. Index type The supported index type is DateTime , as noted in the documentation on creating Data Views . Index range Three parameters control the range and granularity of data returned: Name Query-time parameter Default property Description Start index startIndex defaultStartIndex The inclusive start boundary of the data view data End index endIndex defaultEndIndex The inclusive end boundary of the data view data Interval interval defaultInterval The interval between index values Default values may, optionally, be defined on the data view itself. It is not necessary to define defaults for all three properties. Index parameters may be specified at query time. These take precedence over any defaults that are set. Retrieval mode The supported mode of retrieval is interpolated . Interpolated retrieval Required index parameters when requesting interpolated data are: Start index End index Interval If one or more of these parameters is not specified at query time or as a default, the data query is not valid. Streams in SDS may be configured to have non-default interpolation and extrapolation behavior. These behaviors are observed when stream data is included in data views. Data view data is always treated as dense, even if SDS returns sparse data. See the section on empty or missing values for details. Empty or missing values SDS stream properties may be of nullable (e.g. NullableInt32 ) or non-nullable (e.g. Int32 ) types. Data views treats all fields as nullable, as is necessary for its fundamental goal of aligning large datasets. SDS property type Corresponding data view field type Double NullableDouble NullableDouble NullableDouble If there is no value in an SDS stream for a requested index, the value of the corresponding data view fields(s) will be null . Ordering Data records are ordered first by section, in the order that the sections resolved then by index, ascending, within each section Format The view data is available in several formats. Name Id Description JSON default JSON object representation. An array of objects, each describing one data record. (default) Table table JSON row-column representation. Includes an array describing the .Columns (corresponding to field mappings of the data view) and an array of data .Rows . Each row describes one data record. Table with header tableh Similar to table . The first of the .Rows is an array of the field mapping identifiers, information that is also available in the .Columns of both table formats. CSV csv Comma-separated values. Each row describes one data record. CSV with header csvh Similar to csv . The first row contains the identifier of its corresponding field mapping. Paging Data retrieval operations are paged. Data for a requested index range may span multiple pages. Page size By default, each page includes 1000 records. The maximum page size is 250,000. Optimal page size is dependent both on the client and on the shape of the data view. The size of each individual record is proportional to the \"width\" of the data view, i.e. how many field mappings are resolved. Clients retrieving data views that resolve into few field mappings may wish to use a page size close to the maximum. Hyperlinks When paging through data view data via the REST API, hyperlinks to the FirstPage and NextPage are provided. Proper use of the hyperlinks is recommended. NextPage If the requested data spans into another page, the response includes a hyperlink to the next page of data. Absence of a NextPage link indicates that the data does not span past the current page. The hyperlink preserves all request parameters, while adding or updating a continuationToken . For example: NextPage: \".../ \"...  dataViews/ dataViews  {dataViewId}/ {dataViewId}  data/ data  interpolated?continuationToken=MjAxOC0wMS0wMVQwMDowMDoxMVo_MD90Yk1OblE_QUxXcEZBP1VEdGxIMWJROG9z\u0026count=1000\" To retrieve the entire requested range of data, clients should continue to follow NextPage hyperlinks until the response does not include a NextPage link. This indicates that the last page has been reached. It is possible for the continuation token to become invalid during paging. This is unlikely in ordinary circumstances. However, if an independent operation triggers the data view to re-resolve differently, existing continuation tokens are no longer valid. Data requests with an invalid token are considered bad requests. Paging must be restarted from the first page. FirstPage If the continuation token becomes invalid and paging must be restarted, clients may follow the FirstPage hyperlink. The hyperlink preserves all request parameters, adding or updating the cache behavior to Preserve . This ensures that multiple parallel workers cannot endlessly \"trip\" each other. For example: FirstPage: \".../ \"...  dataViews/ dataViews  {dataViewId}/ {dataViewId}  data/ data  interpolated?cache=Preserve\u0026count=1000\" Index parameters Index parameters, such as Start Index, must remain constant while paging through a range of data. If a different range of data is desired, restart the paging operation. Parallelization To parallelize one large data retrieval operation across multiple workers, assign each worker a portion of the desired index range. Each worker should follow standard recommended paging behavior within its assigned range. The client application must then concatenate the portions in correct order. It is recommended to suppress re-resolution of the data view by specifying a cache behavior of \"preserve\" on each first-page request. Resolution behavior By default, requests for a first page of data will cause the data view to re-resolve. See the documentation on resolved data views . This ensures that the data view accounts for any streams that have been added to or removed from SDS. Re-resolution may be suppressed by explicitly specifying a cache behavior of \"preserve\". Requests for subsequent pages include a continuationToken . This implictly suppresses re-resolution, akin to cache \"preserve\" behavior."
                                                  },
    "Documentation/DataViews/Field_Sets.html":  {
                                                    "href":  "Documentation/DataViews/Field_Sets.html",
                                                    "title":  "Field Sets",
                                                    "keywords":  "Field Sets A data view is likely to include multiple fields of information. One field serves as the index (e.g. Timestamp), and others contain information from or about the data items in the data view. Individual fields are organized into FieldSet s. Field sets are collections of fields that share a common role or source type. Each field set performs a specific type of role: FieldSetSourceType. Index - Provides the index field for the data view. A data view must have exactly one Index field set. FieldSetSourceType. SectionerValue - Displays values that the view is sectioned by. FieldSetSourceType. DataItem - Resolves for each data item from a particular query. Using field sets Available field sets The typical workflow for adding field sets, and the fields in them, is to use or adapt the available field sets that resolve for the data view. This workflow is demonstrated in the Quick Start - Define a Data View . Index field set A data view must have exactly one field set serving as its index: a field set whose .SourceType is FieldSetSourceType.Index . Currently, because the supported index type is a non-compound \"DateTime\", the index field set may contain only one Field . That Field must be of .Source FieldSource.None , because the data views engine provides interpolated index values. Data item field sets Field sets whose source is the DataItem s from a Query will \"resolve\" into fields for each data item. If the data items have been sectioned , then this happens within the context of each section. Example: Defining field sets Let us take a subset of the example scenario \u0027s power inverter streams, returned by the Query value \"TypeId:docs-pi-inverter AND Site:Winterthur\" . Site Meter Measurement Stream Id Tags Winterthur Primary Power In WINT.Meter.Primary.Inverter.0.PwrIn Low Resolution Winterthur Primary Power Out WINT.Meter.Primary.Inverter.0.PwrOut Low Resolution Winterthur Secondary Power In ROSE.Meter.Secondary.Inverter.0.PwrIn Low Resolution Winterthur Secondary Power Out ROSE.Meter.Secondary.Inverter.0.PwrOut Low Resolution The following represents a data view sectioned by \"Meter\", including fields for the sectioner value, and each data item\u0027s \"Tags\" and property \"Value\": { \"Id\": \"quickstart\", \"Queries\": [ { \"Id\": \"inverters\", \"Value\": \"TypeId:docs-pi-inverter AND Site:Winterthur\" } ], \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Meter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" } ], }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Low Resolution\", \"High Resolution\" ], \"Label\": \"{DistinguisherValue} Tags\" }, ], } ] } The view resolves into two sections of field mappings: Timestamp.0 Meter.1 Value.2 Tags.3 Value.4 Tags.5 Value.6 Tags.7 Value.8 Tags.9 - Primary ..Primary..PwrIn/PropertyId:Value ..Primary..PwrIn PropertyId:Value ..Primary..PwrIn/Tags ..Primary..PwrIn Tags ..Primary..PwrOut/PropertyId:Value ..Primary..PwrOut PropertyId:Value ..Primary..PwrOut/Tags ..Primary..PwrOut Tags - Secondary ..Secondary..PwrIn/PropertyId:Value ..Secondary..PwrIn PropertyId:Value ..Secondary..PwrIn/Tags ..Secondary..PwrIn Tags ..Secondary..PwrOut/PropertyId:Value ..Secondary..PwrOut PropertyId:Value ..Secondary..PwrOut/Tags ..Secondary..PwrOut Tags Two things are clearly undesirable here: The field identifiers are ambiguous The result is sparse: the data views engine has not been told how to align the data items across sections, so it has no idea that all \"Power In\" streams are similar. To fix this, we will add a .Distinguisher to the field set. Distinguisher If the field set resolves to multiple data items in any section (or if sectioning is not used), then a field should be designated as the field set\u0027s .Distinguisher . If one lone criterion is not a sufficient or useful way of disambiguating the fields, then sectioning by additional criteria may be necessary. Example: Adding a distinguisher To the data view from the previous example, we will add a Field as the .Distinguisher of its field set. In this example, it makes sense to distinguish each data item by its Measurement . { \"Id\": \"quickstart\", \"Queries\": [ { \"Id\": \"inverters\", \"Value\": \"TypeId:docs-pi-inverter AND Site:Winterthur\" } ], \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Meter\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, ], \"FieldSets\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" } ], }, { \"SourceType\": \"DataItem\", \"QueryId\": \"inverters\", \"Distinguisher\": { { \"Source\": \"Metadata\", \"Keys\": [ \"Measurement\" ], }, }, \"Fields\": [ { \"Source\": \"PropertyId\", \"Keys\": [ \"Value\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Low Resolution\", \"High Resolution\" ], \"Label\": \"{DistinguisherValue} Tags\" }, ], } ] } The result is much more consumable. The field identifiers are no longer ambiguous, and like data items are aligned across sections: Timestamp Meter Power In Value Power In Tags Power Out Value Power Out Tags - Primary ..Primary..PwrIn/PropertyId:Value ..Primary..PwrIn PropertyId:Value ..Primary..PwrIn/Tags ..Primary..PwrIn Tags ..Primary..PwrOut/PropertyId:Value ..Primary..PwrOut PropertyId:Value ..Primary..PwrOut/Tags ..Primary..PwrOut Tags - Secondary ..Secondary..PwrIn/PropertyId:Value ..Secondary..PwrIn PropertyId:Value ..Secondary..PwrIn/Tags ..Secondary..PwrIn Tags ..Secondary..PwrOut/PropertyId:Value ..Secondary..PwrOut PropertyId:Value ..Secondary..PwrOut/Tags ..Secondary..PwrOut Tags Field Each field represents a particular source of information, such as a data item\u0027s .Id or the values from one of its properties. Label A field\u0027s label is a friendly name. When the data view is resolved and fields produce field mappings, labels are trimmed of whitespace and used as the field mappings\u0027 identifier. For example: Timestamp Power In Value Power Out Value In cases where the identifiers are unique, the identifier is suffixed with an ordinal number, its position. For example: Timestamp.0 Value.1 Value.2 There are three special parameters available for use in field labels: {SectionValue} - the value of the sectioner {DistinguisherValue} - the value of the distinguisher {FirstKey} - the value of the first of the \"Keys\" specified on the field If a special parameter fails to resolve, it becomes an empty string, \"\" . Source A field\u0027s .Source indicates where the field\u0027s values will come from, if applicable. Keys In certain cases, a field may need to address data within its data source, such as a particular Metadata value of a data item. This applies to the sources Metadata , PropertyId , and PropertyName . Multiple keys may be specified in the field\u0027s .Keys . This is a way to overcome differences in properties or metadata across data items. Keys are evaluated in order specified until a match is found, i.e. first-match-wins. For field sources that do not use keys ( FieldSource.None , FieldSource.Id and FieldSource.Name ), any keys specified are ignored. Special case: Tags The field source FieldSource.Tags is a special case due to the nature of tags. On a field of source FieldSource.Tags , its collection of .Keys represents a whitelist. Example Given a stream with tags [ \"Weather\", \"Low Resolution\", \"Gen2\" ] A field of source FieldSource.Tags and .Keys [ \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\" ] The field\u0027s value when resolved will be [ \"Low Resolution\", \"Gen2\" ]"
                                                },
    "Documentation/DataViews/Field_Mappings.html":  {
                                                        "href":  "Documentation/DataViews/Field_Mappings.html",
                                                        "title":  "Field Mappings",
                                                        "keywords":  "Field Mappings A FieldMapping contains information on the source on every field of data in the data view. For each field in the data view, there is a corresponding FieldMapping . Within each field mapping, the list of DataMapping s shows the source of data for each section. There is one DataMapping per section, since the number of distinct data source for each field equals to the number of sections in the resolved data view. Inspecting the field mapping resource after defining the data view is a good way to confirm that the output data view does contain the data-of-interest prior to data generation. Interpreting Field Mapping The number and order of field mappings is identical to the number and order of the resulting data view fields. Id and label The field mapping id represents the json property name (or column name in table or csv format) in the output data view data. The field mapping label represents the data view field label with tokens resolved. If all field mapping labels in a data view are unique, the field mapping id is identical to the label; if not, the id is generated from the label by adding an index number postfix. Field set index and field index The field set index and field index represents the zero-based positioning of the corresponding field set and field within the field set, respectively. Data Mapping Data mappings represent the data source for each section. Index TargetId and TargetFieldKey are not used for index fields. TypeCode is equivalent to the IndexTypeCode of the data view. Sectioner Value TargetId is the zero-based index of the corresponding sectioner. TypeCode is always string . Data Item TargetId represents the data item id. Id, name and tags: TargetFieldKey is empty Metadata: TargetFieldKey shows the metadata key Properties: TargetFieldKey shows the property id or property name path"
                                                    },
    "Documentation/DataViews/Example_Scenario.html":  {
                                                          "href":  "Documentation/DataViews/Example_Scenario.html",
                                                          "title":  "Example Scenarios",
                                                          "keywords":  "Example Scenarios This section uses example streams to illustrate data view concepts. The streams are of three types: docs-pi-inverter | simulates solar power inverter data collected via PI to OCS docs-omf-weather-gen1 | simulates weather data collected from an OMF source docs-omf-weather-gen2 | simulates weather data collected from an OMF source, but with some additional/renamed additional renamed properties Each solar inverter is associated with some physical location. There is a weather stream for each location. Data views are made to bring order to a tangle of data streams. Despite appearing complex and verbose, this scenario is likely much simpler than your real-world data. This scenario illustrates how data views can render real-world data consumable for data science. Solar Inverter streams These streams represent values collected via PI to OCS, originally collected by a PI System. Each stream value contains a timestamp (Timestamp) and a measurement (Value) . Type { \"Id\": \"docs-pi-inverter\", \"Name\": \"Inverter\", \"SdsTypeCode\": \"Object\", \"Properties\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"IsKey\": true, \"SdsType\": { \"SdsTypeCode\": \"DateTime\" } }, { \"Id\": \"Value\", \"Name\": \"Value\", \"SdsType\": { \"SdsTypeCode\": \"Double\" } } ] } Stream IDs 16 inverter streams are defined: \"BILT.Meter.Primary.Inverter.0.PwrIn\", \"BILT.Meter.Primary.Inverter.0.PwrOut\", \"BILT.Meter.Primary.Inverter.1.PwrIn\", \"BILT.Meter.Primary.Inverter.1.PwrOut\", \"BILT.Meter.Primary.Inverter.2.PwrIn\", \"BILT.Meter.Primary.Inverter.2.PwrOut\", \"BILT.Meter.Secondary.Inverter.0.PwrIn\", \"BILT.Meter.Secondary.Inverter.0.PwrOut\", \"ROSE.Meter.Primary.Inverter.0.PwrIn\", \"ROSE.Meter.Primary.Inverter.0.PwrOut\", \"ROSE.Meter.Primary.Inverter.1.PwrIn\", \"ROSE.Meter.Primary.Inverter.1.PwrOut\", \"WINT.Meter.Primary.Inverter.0.PwrIn\", \"WINT.Meter.Primary.Inverter.0.PwrOut\", \"WINT.Meter.Secondary.Inverter.0.PwrIn\", \"WINT.Meter.Secondary.Inverter.0.PwrOut\", Tags and Metadata Each inverter stream has some descriptive tags assigned, and metadata key-values describing its function. Tags: some subset of [ \"Commercial\", \"Residential\", \"Critical Asset\" ] Metadata: { \"Site\" : one of ( \"Biltmore\" | \"Rosecliff\" | \"Winterthur\" ), \"Measurement\": one of ( \"Power In\" | \"Power Out\" ), \"Meter\": one of ( \"Primary\", \"Secondary\" ), \"Inverter\": one of ( \"0\", \"1\", \"2\" ) \"Nominal Power MW\": \"1.21\" } Weather Streams These streams simulate data collected via OMF from a weather station. There are two \"generations\" represented: Gen2 adds one property and renames another, as compared to Gen1. Tags and Metadata Each weather stream has some descriptive tags assigned, and one metadata key-value indicating its Site. These are the same sites with which the inverters are associated. Tags: some subset of [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\" ] Metadata: { \"Site\" : one of ( \"Biltmore\" | \"Rosecliff\" | \"Winterthur\" ) } Weather, Generation 1 Type { \"Id\": \"docs-omf-weather-gen1\", \"Name\": \"WeatherGen1\", \"SdsTypeCode\": \"Object\", \"Properties\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"IsKey\": true, \"SdsType\": { \"SdsTypeCode\": \"DateTime\" } }, { \"Id\": \"SolarRadiation\", \"Name\": \"Solar Radiation\", \"SdsType\": { \"SdsTypeCode\": \"Int32\" } }, { \"Id\": \"Temperature\", \"Name\": \"Temperature\", \"SdsType\": { \"SdsTypeCode\": \"Double\" } } ] } Stream IDs Two streams of this type are defined: \"WS_BILT\", \"WS_ROSE\", Weather, Generation 2 The latest and greatest Gen2 weather stations report a new property, Cloud Cover , but also rename Temperature to Ambient Temperature . They are otherwise similar to Gen1. Type { \"Id\": \"docs-omf-weather-gen2\", \"Name\": \"WeatherGen2\", \"SdsTypeCode\": \"Object\", \"Properties\": [ { \"Id\": \"Timestamp\", \"Name\": \"Timestamp\", \"IsKey\": true, \"SdsType\": { \"SdsTypeCode\": \"DateTime\" } }, { \"Id\": \"SolarRadiation\", \"Name\": \"Solar Radiation\", \"SdsType\": { \"SdsTypeCode\": \"Int32\" } }, { \"Id\": \"AmbientTemperature\", \"Name\": \"Ambient Temperature\", \"SdsType\": { \"SdsTypeCode\": \"Double\" } }, { \"Id\": \"CloudCover\", \"Name\": \"Cloud Cover\", \"SdsType\": { \"SdsTypeCode\": \"Int32\" } } ] } Stream IDs One stream of this type is defined: \"WS_WINT\""
                                                      },
    "Documentation/DataViews/Data_Items_and_Sections.html":  {
                                                                 "href":  "Documentation/DataViews/Data_Items_and_Sections.html",
                                                                 "title":  "Data Items and Sections",
                                                                 "keywords":  "Data Items and Sections A DataItem is an SdsStream included in the data view. The collection of data items is specified by the data view queries, where the queries define the search criteria and the data items represent the results of the search. The data view can include one or more properties from each data item. Data Items The collection of data items in the data view represents all SdsStreams that match the .queries field of the data view, excluding ones that are \"ineligible\" (see discussion of ineligible data items below). To add data items to a data view, either refine an existing query, or add a new query (refer to queries for which option to choose from). Similarly, to remove data items from a data view, either refine an existing query, or remove a query (this will remove all data items from the query). Note that each query is executed independently to generate the list of data items. It is thus possible to have duplicate data items resulting from different queries. This can be desirable and undesirable depending the use case. Adding Fields Each data item contains information that can be optionally (and explicitly) added to the data view by setting the .field sets field of the data view. Currently, the only supported resource type is stream with the following available fields: Stream id Stream name Stream tags Stream metadata Data from each stream property Adding or Removing SdsStreams When requesting for resolved data items or when getting the data view data , the list of data items reflect the list of SdsStreams that match one or more queries when the data view was last resolved. This means that if new streams were added or existing streams were removed from the Sequential Data Store, the list of data items will only reflect the latest changes if the data view is re-resolved. For more information, refer to the caching section in the resolved data view resource page . Ineligible Data Items The collection of ineligible data items represents SdsStreams that match the queries but cannot be included in the data view. The criteria for ineligibility are: When the SdsStream\u0027s index type is different than the IndexTypeCode specified in the data view. When the SdsType of the stream contains compound indexes. Sections Sectioning is optional when defining the data view. If the .sectioners field is not defined on the data view, the resolved data view shows a single section with all eligible data items. If the .sectioners field is defined, the resolved data view shows multiple sections, each with the list of data items for the section and the .values field showing the matching section\u0027s value(s). In this case, if a data item does not match any section, it is added to all sections."
                                                             },
    "Documentation/DataViews/Data_API.html":  {
                                                  "href":  "Documentation/DataViews/Data_API.html",
                                                  "title":  "Data API",
                                                  "keywords":  "Data API The Data API allows users to retrieve data for a specified data view. This API is one portion of the data views API . Get Data View Data Get data for the provided index parameters with paging. See documentation on paging for further information. Request GET /   api/ api  v1-preview/ v1-preview  tenants/ tenants  {tenantId}/ {tenantId}  namespaces/ namespaces  {namespaceId}/ {namespaceId}  dataviews/ dataviews  {dataViewId}/ {dataViewId}  data/ data  interpolated?startIndex={startIndex}\u0026endIndex={endIndex}\u0026interval={interval}\u0026form={form}\u0026continuationToken={continuationToken}\u0026cache={cache}\u0026count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier [optional] string startIndex The requested start index, inclusive. The default value is the .DefaultStartIndex of the data view. Optional if a default value is specified. [optional] string endIndex The requested end index, inclusive. The default value is the .DefaultEndIndex of the data view. Optional if a default value is specified. [optional] string interval The requested interval between index values. The default value is the .DefaultInterval of the data view. Optional if a default is specified. [optional] string form The requested data output format . Output formats: default , table , tableh , csv , csvh . [optional] string continuationToken Used only when paging . Not specified when requesting the first page of data. [optional] string cache Controls when the data view backing resources are to be refreshed. Used only when requesting the first page of data. Ignored if used with the continuationToken. Values are: Value Description Refresh Force the resource to re-resolve. This is the default value for this API route. Preserve Use cached information, if available. [optional] int count The requested page size. The default value is 1000. The maximum is 250,000. Response The response includes a status code and, in most cases, a body. Status code Body Type Description 200 OK data in the requested format Successfully retrieved data. 400 Bad Request error The request could not be understood by the server due to malformed syntax. 403 Forbidden error User is not authorized for this operation. 404 Not Found error The specified data view identifier is not found. 500 Internal Server Error error An error occurred while processing the request. See the response body for details Response headers Successful (200 OK) responses include one or more header values related to paging. Header Description FirstPage Hyperlink to the first page of data NextPage Hyperlink to the next page of data, if the data spans into an additional page. Absence of this header indicates that there are no additional pages to be retrieved. Example response body in default format An array of json values. Each json property corresponds to a field mapping. Property names are the field mapping .Id s. HTTP 200 OK [ { \"Time\": \"2018-01-01T00:00:00Z\", \"Temperature\": 24, \"Flowrate\": 44, \"Volume\": 245 }, { \"Time\": \"2018-01-01T00:00:01Z\", \"Temperature\": 24, \"Flowrate\": 44, \"Volume\": 245 }, { \"Time\": \"2018-01-01T00:00:02Z\", \"Temperature\": 24, \"Flowrate\": 44, \"Volume\": 245 } ] Example response body with form=table HTTP 200 OK { \"Columns\": [ { \"Name\": \"Time\", \"Type\": \"DateTime\" }, { \"Name\": \"Temperature\", \"Type\": \"Int32\" }, { \"Name\": \"Flowrate\", \"Type\": \"Int32\" }, { \"Name\": \"Volume\", \"Type\": \"Int32\" } ], \"Rows\": [ [ \"2018-01-01T00:00:00Z\", 24, 44, 245 ], [ \"2018-01-01T00:00:01Z\", 24, 44, 245 ], [ \"2018-01-01T00:00:02Z\", 24, 44, 245 ] ] } Example response body with form=tableh HTTP 200 OK { \"Columns\": [ { \"Name\": \"Time\", \"Type\": \"DateTime\" }, { \"Name\": \"Temperature\", \"Type\": \"Int32\" }, { \"Name\": \"Flowrate\", \"Type\": \"Int32\" }, { \"Name\": \"Volume\", \"Type\": \"Int32\" } ], \"Rows\": [ [ \"Time\", \"Temperature\", \"Flowrate\", \"Volume\" ], [ \"2018-01-01T00:00:00Z\", 24, 44, 245 ], [ \"2018-01-01T00:00:01Z\", 24, 44, 245 ], [ \"2018-01-01T00:00:02Z\", 24, 44, 245 ] ] } Example response body with form=csv HTTP 200 OK 2018-01-01T00:00:00Z,24,44,245 2018-01-01T00:00:01Z,24,44,245 2018-01-01T00:00:02Z,24,44,245 Example response body with form=csvh HTTP 200 OK Time,Temperature,Flowrate,Volume 2018-01-01T00:00:00Z,24,44,245 2018-01-01T00:00:01Z,24,44,245 2018-01-01T00:00:02Z,24,44,245"
                                              },
    "Documentation/DataViews/Available_Field_Sets.html":  {
                                                              "href":  "Documentation/DataViews/Available_Field_Sets.html",
                                                              "title":  "Available Field Sets",
                                                              "keywords":  "Available Field Sets Available field sets include fields not currently included in the data view, which are available to be added. The list of field sets is generated based on the .Queries , .Sectioners , and .IndexTypeCode of the defined data view. These fields and field sets can be readily added to the data view .FieldSets . Once the field is added, it is omitted from the list of available field sets. Similarly, if the field is removed from the data view, it is added back to the available field sets. This allows an iterative approach to building the data view by easily adding and removing fields from the data view. Field Set Source Available fields are organized into field sets according to their sources: The index field set represents the index field of the data view. Exactly one index field set is available per data view. Currently, this field is not mapped to anything, since interpolation is the only supported index mode. ```FieldSetSourceType.SectionerValue``` The sectioner value field set represents the matching value for each section. If no sectioners are specified, this field set is not available. Exactly one section value field set is available per data view. The section value field set contains one field per section, with each sectioner referred to by its index: `{ ... Keys: [\"0\"] }` for the 0th sectioner. ```FieldSetSourceType.DataItem``` The data item field set contains fields from the data item resulted from the query. For each query, a field set with unused fields will be returned. The available fields for stream data item include: * Id, name * Tags: one field with union of all tags * Metadata, propertyId: one field for each metadata key or property id ## Data View without Sectioners The example uses the following data view and the streams from the [SDS Example Scenario](xref:DataViewsExampleScenario). Note that the field sets and the sectioners arrays are empty: ```json { \"Id\": \"example_without_sectioners\", \"Name\": \"example_without_sectioners\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [], \"Sectioners\": [], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } Accessing the Get Available Field Sets endpoint will show available fields corresponding to stream id, name, tags, metadata, and each property. Since the index field set is not included in the data view, it is also shown as available. HTTP 200 OK { \"TimeOfResolution\": \"(a timestamp in ISO 8601 format)\", \"Items\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ { \"Source\": \"Id\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Id\" }, { \"Source\": \"Name\", \"Keys\": [], \"Label\": \"{DistinguisherValue} Name\" }, { \"Source\": \"Tags\", \"Keys\": [ \"Weather\", \"Low Resolution\", \"High Resolution\", \"Gen1\", \"Gen2\", ], \"Label\": \"{DistinguisherValue} Tags\" }, { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Timestamp\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"SolarRadiation\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"AmbientTemperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"CloudCover\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" }, { \"Source\": \"PropertyId\", \"Keys\": [ \"Temperature\" ], \"Label\": \"{DistinguisherValue} {FirstKey}\" } ] } ] } Data View with Sectioners This data view is the same as in the first example, except it also has a sectioner , which defines sectioning by the metadata key \"Site\": { \"Id\": \"example_with_sectioners\", \"Name\": \"example_with_sectioners\", \"Description\": null, \"Queries\": [ { Id: \"weather\", Value:\"*weather*\" } ], \"FieldSets\": [] \"Sectioners\": [ { \"Source\": \"Metadata\", \"Keys\": [ \"Site\" ], \"Label\": \"{DistinguisherValue} Id\" } ], \"Shape\": \"Standard\", \"IndexTypeCode\": \"DateTime\" } A field set with SourceType.SectionValue is now shown as one of the available field sets: HTTP 200 OK { \"TimeOfResolution\": \"2019-11-14T20:31:20.856826+00:00\", \"Items\": [ { \"SourceType\": \"Index\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [], \"Label\": \"Timestamp\" } ] }, { \"SourceType\": \"SectionValue\", \"Fields\": [ { \"Source\": \"None\", \"Keys\": [ \"0\" ], \"Label\": \"{SectionerLabel}\" } ] }, { \"SourceType\": \"DataItem\", \"QueryId\": \"weather\", \"Fields\": [ ... ] } ] }"
                                                          },
    "Documentation/samples.html":  {
                                       "href":  "Documentation/samples.html",
                                       "title":  "Samples",
                                       "keywords":  "Samples The OCS-Samples illustrate several ways for applications to interact with the OCS REST API. The examples cover the basics of interacting with OCS, such as: Connecting to OCS Creating SdsTypes and instances of SdsStreams Sending data to and retrieving data from SdsStreams Performing queries against SdsStreams Removing SdsStreams and SdsTypes Currently, the samples are available in these languages: .NET Java Python NodeJs Angular Because the examples are intended for demonstration purposes, they represent some example practices. The patterns may change as OCS continues to develop. Be sure to follow the OSI-Samples repository on GitHub for updates."
                                   },
    "Documentation/SequentialDataStore/SDS_Types.html":  {
                                                             "href":  "Documentation/SequentialDataStore/SDS_Types.html",
                                                             "title":  "Types",
                                                             "keywords":  "Types The Sequential Data Store (SDS) stores streams of events and provides convenient ways to find and associate events. Events are stored in streams, called SdsStreams. An SdsType defines the shape or structure of the event and how to associate events within the SdsStream. SdsTypes can define simple atomic types, such as integers, floats, strings, arrays, and dictionaries, or they can define complex types using SdsTypes. You can define complex, nested types using the Properties collection of an SdsType. An SdsType used to define an SdsStream must have a Key. A Key is a Property, or a combination of Properties that constitute an ordered, unique identity. The Key is ordered, so it functions as an index; it is known as the Primary Index. While a timestamp (DateTime) is a very common type of Key, any type that can be ordered is permitted. Other indexes (secondary indexes), are defined in the SdsStream. For more information, see Indexes . When defining a type, consider how the events will be represented in a stream. The SdsType defines each event in the stream. An event is a single unit whose properties have values that relate to the index; that is, each property of an SdsType event is related to the event\u0027s index. Each event is a single unit. An SdsType is referenced by its identifier or Id field. SdsType identifiers must be unique within a Namespace. An SdsType can also refer other SdsTypes by using their identifiers. This enables type re-usability. Nested types and base types are automatically created as separate types. For more information, see Type Reusability . SdsTypes define how events are associated and read within a collection of events, or SdsStream. The read characteristics when attempting to read non-existent indexes, indexes that fall between, before or after existing indexes, are determined by the interpolation and extrapolation settings of the SdsType. For more information about read characteristics see Interpolation and Extrapolation . SdsTypes are immutable. After an SdsType is created, its definition cannot change. An SdsType must be deleted and recreated if the definition is incorrect. In addition, the SdsType may be deleted only if no streams, stream views, or types reference it. Only SdsTypes used to define SdsStreams or SdsStreamViews are required to be added to the Sequential data store. SdsTypes that define Properties or base types are contained within the parent SdsType and are not required to be added to the Data Store independently. The following table shows the required and optional SdsType fields. Fields that are not included are reserved for internal SDS use. See Search in SDS for limitations on search. Property Type Optionality Searchable Details Id String Required Yes Identifier for referencing the type Name String Optional Yes Friendly name Description String Optional Yes Description text SdsTypeCode SdsTypeCode Required No Numeric code identifying the base SdsType InterpolationMode SdsInterpolationMode Optional No Interpolation setting of the type. Default is Continuous. For more information, see Interpolation . ExtrapolationMode SdsExtrapolationMode Optional No Extrapolation setting of the type. For more information, see Extrapolation . Properties IList\u003cSdsTypeProperty\u003e Required Yes, with limitations List of SdsTypeProperty items Rules for the Type Identifier (SdsType.Id) Is not case sensitive Can contain spaces Cannot contain forward slash (\"/\") (\" \") Can contain a maximum of 100 characters SdsType management using the .NET SDS Client Libraries is performed through the ISdsMetadataService . You can create the ISdsMetadataService using one of the SdsService.GetMetadataService() factory methods. The .NET libraries provide SdsTypeBuilder to help build SdsTypes from .NET types. SdsTypeBuilder is discussed in greater detail below. SdsTypeCode The SdsTypeCode is a numeric identifier used by the Data Store to identify SdsTypes. A SdsTypeCode exists for every supported type. Atomic types, such as strings, floats and arrays, are defined entirely by the SdsTypeCode. Atomic types do not need fields to define the type. Types requiring additional definition, such as enums and objects, are identified using a generic SdsTypeCode, such as ByteEnum, Int32Enum, NullableInt32Enum, or Object, plus additional SdsProperty fields. Supported Types The following types are supported and defined by the SdsTypeCode: Type SdsTypeCode Array 400 Boolean 3 BooleanArray 203 Byte 6 ByteArray 206 ByteEnum 606 Char 4 CharArray 204 DateTime 16 DateTimeArray 216 DateTimeOffset 20 DateTimeOffsetArray 220 DBNull 2 Decimal 15 DecimalArray 215 Double 14 DoubleArray 214 Empty 0 Guid 19 GuidArray 219 IDictionary 402 IEnumerable 403 IList 401 Int16 7 Int16Array 207 Int16Enum 607 Int32 9 Int32Array 209 Int32Enum 609 Int64 11 Int64Array 211 Int64Enum 611 NullableBoolean 103 NullableByte 106 NullableByteEnum 706 NullableChar 104 NullableDateTime 116 NullableDateTimeOffset 120 NullableDecimal 115 NullableDouble 114 NullableGuid 119 NullableInt16 107 NullableInt16Enum 707 NullableInt32 109 NullableInt32Enum 709 NullableInt64 111 NullableInt64Enum 711 NullableSByte 105 NullableSByteEnum 705 NullableSingle 113 NullableTimeSpan 121 NullableUInt16 108 NullableUInt16Enum 708 NullableUInt32 110 NullableUInt32Enum 710 NullableUInt64 112 NullableUInt64Enum 712 Object 1 SByte 5 SByteArray 205 SByteEnum 605 Single 13 SingleArray 213 String 18 StringArray 218 TimeSpan 21 TimeSpanArray 221 UInt16 8 UInt16Array 208 UInt16Enum 608 UInt32 10 UInt32Array 210 UInt32Enum 610 UInt64 12 UInt64Array 212 UInt64Enum 612 Version 22 VersionArray 222 SdsTypeProperty The Properties collection define the fields in an SdsType. The following table shows the required and optional SdsTypeProperty fields. Fields that are not included are reserved for internal SDS use. Property Type Optionality Details Id String Required Identifier for referencing the type Name String Optional Friendly name Description String Optional Description text SdsType SdsType Required Field defining the property\u0027s Type IsKey Boolean Required Identifies the property as the Key (Primary Index) Value Object Optional Value of the property Order Int Optional Order of comparison within a compound index InterpolationMode SdsInterpolationMode Optional Interpolation setting of the property. Default is null. Uom String Optional Unit of Measure of the property The SdsTypeProperty\u0027s identifier follows the same rules as the SdsType\u0027s identifier. IsKey is a Boolean value used to identify the SdsType\u0027s Key. A Key defined by more than one Property is called a compound key. The maximum number of Properties that can define a compound key is three. In a compound key, each Property that is included in the Key is specified as IsKey. The Order field defines the precedence of fields applied to the Index. The Value field is used for properties that represent a value. An example of a property with a value is an enum\u0027s named constant. When representing an enum in a SdsType, the SdsType\u0027s Properties collection defines the enum\u0027s constant list. The SdsTypeProperty\u0027s Identifier represents the constant\u0027s name and the SdsTypeProperty\u0027s Value represents the constant\u0027s value (see the enum State definitions below). InterpolationMode is assigned when the Property of the event should be interpolated in a specific way that differs from the InterpolationMode of the SdsType. InterpolationMode is only applied to a Property that is not part of the Index. If the InterpolationMode is not set, the Property is are interpolated in the manner defined by the SdsType\u0027s IntepolationMode. An SdsType with the InterpolationMode set to Discrete cannot have a Property with an InteroplationMode. For more information on interpolation of events see Interpolation . Uom is the unit of measure for the Property. The Uom of a Property may be specified by the name or the abbreviation. The names and abbreviations of Uoms are case sensitive. The InterpolationMode and Uom of a Property can be overridden on the stream. For more information, see Streams . Supported Units of Measure For a list of units of measures that are supported for an SdsTypeProperty, see Units of Measure . Working with SdsTypes using .NET When working in .NET, use the SdsTypeBuilder to create SdsTypes. The SdsTypeBuilder eliminates potential errors that can occur when working with SdsTypes manually. There are several ways to work with the builder. The most convenient is to use the static methods, as shown here: public enum State { Ok, Warning, Alarm } public class Simple { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public State State { get; set; } public Double Measurement { get; set; } } SdsType simpleType = SdsTypeBuilder.CreateSdsType\u003cSimple\u003e(); simpleType.Id = \"Simple\"; simpleType.Name = \"Simple\"; simpleType.Description = \"Basic sample type\"; SdsTypeBuilder recognizes the System.ComponentModel.DataAnnotations.KeyAttribute and its own OSIsoft.Sds.SdsMemberAttribute . When using the SdsMemberAttribute to specify the Primary Index, set the IsKey to true. The type is created with the following parameters. SdsTypeBuilder automatically generates unique identifiers. Note that the following table contains only a partial list of fields. Field Values Id Simple Name Simple Description Basic sample type Properties Count = 3 [0] Id Time Name Time Description null Order 0 IsKey true SdsType Id c48bfdf5-a271-384b-bf13-bd21d931c1bf Name DateTime Description null Properties null Value null [1] Id State Name State Description null Order 0 IsKey false SdsType Id 02728a4f-4a2d-3588-b669-e08f19c35fe5 Name State Description null Properties Count = 3 [0] Id Name Description Order SdsType Value [1] Id Name Description Order SdsType Value [2] Id Name Description Order SdsType Value Value null [2] Id Measurement Name Measurement Description null Order 0 IsKey false SdsType Id 0f4f147f-4369-3388-8e4b-71e20c96f9ad Name Double Description null Properties null Value null The SdsTypeBuilder also supports derived types. Note that you need not add the base types to the Data Store before using SdsTypeBuilder. Base types are maintained within the SdsType. Working with SdsTypes when not using .NET SdsTypes must be built manually when .NET SdsTypeBuilder is unavailable. The following discussion refers to the following types and are defined in Python and JavaScript samples. Samples in other languages can be found here: Samples . In the sample code, SdsType, SdsTypeProperty, and SdsTypeCode are defined as in the code snippets shown here: Python class SdsTypeCode(Enum): Empty = 0 Object = 1 DBNull = 2 Boolean = 3 Char = 4 ... class SdsTypeProperty(object): \"\"\"SDS type property definition\"\"\" def __init__(self): self.__isKey = False @property def Id(self): return self.__id @Id.setter def Id(self, id): self.__id = id ... @property def IsKey(self): return self.__isKey @IsKey.setter def IsKey(self, iskey): self.__isKey = iskey @property def SdsType(self): return self.__SdsType @SdsType.setter def SdsType(self, SdsType): self.__SdsType=SdsType ... class SdsType(object): \"\"\"SDS type definitions\"\"\" def __init__(self): self.SdsTypeCode = SdsTypeCode.Object @property def Id(self): return self.__id @Id.setter def Id(self, id): self.__id = id ... @property def BaseType(self): return self.__baseType @BaseType.setter def BaseType(self, baseType): self.__baseType = baseType @property def SdsTypeCode(self): return self.__typeCode @SdsTypeCode.setter def SdsTypeCode(self, typeCode): self.__typeCode = typeCode @property def Properties(self): return self.__properties @Properties.setter def Properties(self, properties): self.__properties = properties JavaScript SdsTypeCodeMap: { Empty: 0, \"Object\": 1, DBNull: 2, \"Boolean\": 3, Char: 4, ... SdsTypeProperty: function (SdsTypeProperty) { if (SdsTypeProperty.Id) { this.Id = SdsTypeProperty.Id; } if (SdsTypeProperty.Name) { this.Name = SdsTypeProperty.Name; } if (SdsTypeProperty.Description) { this.Description = SdsTypeProperty.Description; } if (SdsTypeProperty.SdsType) { this.SdsType = SdsTypeProperty.SdsType; } if (SdsTypeProperty.IsKey) { this.IsKey = SdsTypeProperty.IsKey; } }, SdsType: function (SdsType) { if (SdsType.Id) { this.Id = SdsType.Id } if (SdsType.Name) { this.Name = SdsType.Name; } if (SdsType.Description) { this.Description = SdsType.Description; } if (SdsType.SdsTypeCode) { this.SdsTypeCode = SdsType.SdsTypeCode; } if (SdsType.Properties) { this.Properties = SdsType.Properties; } }, Working with the following types (both Python and JavaScript classes are shown): Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class Simple(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getMeasurement, setMeasurement) def getMeasurement(self): return self.__measurement def setMeasurement(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var Simple = function () { this.Time = null; this.State = null; this.Measurement = null; } Define the SdsType as follows: Python # Create the properties # Time is the primary key time = SdsTypeProperty() time.Id = \"Time\" time.Name = \"Time\" time.IsKey = True time.SdsType = SdsType() time.SdsType.Id = \"DateTime\" time.SdsType.Name = \"DateTime\" time.SdsType.SdsTypeCode = SdsTypeCode.DateTime # State is not a pre-defined type. A SdsType must be defined to represent the enum stateTypePropertyOk = SdsTypeProperty() stateTypePropertyOk.Id = \"Ok\" stateTypePropertyOk.Value = State.Ok stateTypePropertyWarning = SdsTypeProperty() stateTypePropertyWarning.Id = \"Warning\" stateTypePropertyWarning.Value = State.Warning stateTypePropertyAlarm = SdsTypeProperty() stateTypePropertyAlarm.Id = \"Alarm\" stateTypePropertyAlarm.Value = State.Alarm stateType = SdsType() stateType.Id = \"State\" stateType.Name = \"State\" stateType.Properties = [ stateTypePropertyOk, stateTypePropertyWarning, \\ stateTypePropertyAlarm ] state = SdsTypeProperty() state.Id = \"State\" state.Name = \"State\" state.SdsType = stateType # Value property is a simple non-indexed, pre-defined type value = SdsTypeProperty() value.Id = \"Measurement\" value.Name = \"Measurement\" value.SdsType = SdsType() value.SdsType.Id = \"Double\" value.SdsType.Name = \"Double\" # Create the Simple SdsType simpleType = SdsType() simpleType.Id = \"Simple\" simpleType.Name = \"Simple\" simpleType.Description = \"Basic sample type\" simpleType.SdsTypeCode = SdsTypeCode.Object simpleType.Properties = [ time ] JavaScript //    Time is the primary key var timeProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Time\", \"IsKey\": true, \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"dateType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.DateTime }) }); //    State is not a pre-defined type. An SdsType must be defined to represent the enum var stateTypePropertyOk = new SdsObjects.SdsTypeProperty({ \"Id\": \"Ok\", \"Value\": State.Ok }); var stateTypePropertyWarning = new SdsObjects.SdsTypeProperty({ \"Id\": \"Warning\", \"Value\": State.Warning }); var stateTypePropertyAlarm = new SdsObjects.SdsTypeProperty({ \"Id\": \"Alarm\", \"Value\": State.Alarm }); var stateType = new SdsObjects.SdsType({ \"Id\": \"State\", \"Name\": \"State\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Int32Enum, \"Properties\": [stateTypePropertyOk, stateTypePropertyWarning, stateTypePropertyAlarm, stateTypePropertyRed] }); //    Measurement property is a simple non-indexed, pre-defined type var measurementProperty = new SdsObjects.SdsTypeProperty({ \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"doubleType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Double }) }); //    Create the Simple SdsType var simpleType = new SdsObjects.SdsType({ \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": \"This is a simple SDS type \", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [timeProperty, stateProperty, measurementProperty] }); Working with a derived class is easy. For the following derived class: class Derived(Simple): @property def Observation(self): return self.__observation @Observation.setter def Observation(self, observation): self.__observation = observation Extend the SdsType as follows: Python # Observation property is a simple non-indexed, standard data type observation = SdsTypeProperty() observation.Id = \"Observation\" observation.Name = \"Observation\" observation.SdsType = SdsType() observation.SdsType.Id = \"String\" observation.SdsType.Name = \"String\" observation.SdsType.SdsTypeCode = SdsTypeCode.String # Create the Derived SdsType derived = SdsType() derived.Id = \"Derived\" derived.Name = \"Derived\" derived.Description = \"Derived sample type\" derived.BaseType = simpleType # Set the base type to the derived type derived.SdsTypeCode = SdsTypeCode.Object derived.Properties = [ observation ] JavaScript var observationProprety = new SdsObjects.SdsTypeProperty({ \"Id\": \"Observation\", \"SdsType\": new SdsObjects.SdsType({ \"Id\": \"strType\", \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.String }) }); var derivedType = new SdsObjects.SdsType({ \"Id\": \"Derived\", \"Name\": \"Derived\", \"Description\": \" Derived sample type\", \"BaseType\": simpleType, \"SdsTypeCode\": SdsObjects.SdsTypeCodeMap.Object, \"Properties\": [ observationProprety ] }); Type Reusability An SdsType can also refer other SdsTypes by using their identifiers. This enables type re-usability. For example, if there is a common index and value property for a group of types that may have additional properties, a base type can be created with those properties. { \"Id\": \"Simple\", \"Name\": \"Simple\", \"SdsTypeCode\": 1, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"IsKey\": true, \"SdsType\": { \"SdsTypeCode\": 16 } }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": { \"SdsTypeCode\": 14 } } ] } If a new type should be created with properties additional to the ones above, a reference to the base type can be added by simply specifying the base type\u0027s Id. { \"Id\": \"Complex\", \"Name\": \"Complex\", \"SdsTypeCode\": 1, \"BaseType\":{ \"Id\":\"Simple\" }, \"Properties\": [ { \"Id\": \"Depth\", \"Name\": \"Depth\", \"SdsType\": { \"SdsTypeCode\": 14 } } ] } The new type may also include the full type definition of the reference type instead of specifying only the Id. For example, { \"Id\": \"Complex\", \"Name\": \"Complex\", \"SdsTypeCode\": 1, \"BaseType\":{ \"Id\": \"Simple\", \"Name\": \"Simple\", \"SdsTypeCode\": 1, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"IsKey\": true, \"SdsType\": { \"SdsTypeCode\": 16 } }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": { \"SdsTypeCode\": 14 } } ] }, \"Properties\": [ { \"Id\": \"Depth\", \"Name\": \"Depth\", \"SdsType\": { \"SdsTypeCode\": 14 } } ] } If the full definition is sent, the referenced types (base type \"Simple\" in the above example) should match the actual type initially created. If the full definition is sent and the referenced types do not exist, they will be created automatically by SDS. Further type creations can reference them as demonstrated above. Note that when trying to get types back from SDS, the results will also include types that were automatically created by SDS. Base types and properties of type Object, Enum, user-defined collections, such as, Array, List and Dictionary will be treated as referenced types. Note that streams cannot be created using these referenced types. If a stream of particular type is to be created, the type should contain at least one property with a valid index type as described in this section, Indexes . The index property may also be in the base type as shown in the example above. This works seamlessly when using any programming language. For example if you are using .NET, public class Basic { [SdsMember(IsKey = true, Order = 0)] public DateTime Time { get; set; } public double Temperature { get; set; } } public class EngineMonitor : Basic { public double PistonSpeed { get; set; } } public class WindShieldMonitor : Basic { public double Luminance { get; set; } } SdsType engineType = SdsTypeBuilder.CreateSdsType\u003cEngineMonitor\u003e(); engineType.Id = \"Engine\"; engineType.BaseType.Id = \"Basic\"; SdsType windShieldType = SdsTypeBuilder.CreateSdsType\u003cWindShieldMonitor\u003e(); windShieldType.Id = \"WindShield\"; windShieldType.BaseType.Id = \"Basic\"; Note that the base type\u0027s Id can also be changed, if necessary, to be more meaningful. SdsType API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsTypes. When working in .NET, convenient SDS Client Libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService() helper, defines the available functions. See Types for general SdsType information. Get Type Returns the type corresponding to the specified typeId within a given namespace. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response body The requested SdsType Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\": \"Simple\", \"Name\": \"Simple\", \"SdsTypeCode\": 1, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"IsKey\": true, \"SdsType\": { \"Id\": \"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\": \"DateTime\", \"SdsTypeCode\": 16 } }, { \"Id\": \"State\", \"Name\": \"State\", \"SdsType\": { \"Id\": \"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\": \"State\", \"SdsTypeCode\": 609, \"Properties\": [ { \"Id\": \"Ok\", \"Value\": 0 }, { \"Id\": \"Warning\", \"Value\": 1 }, { \"Id\": \"Alarm\", \"Value\": 2 } ] } }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": { \"Id\": \"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\": \"Double\", \"SdsTypeCode\": 14 } } ] } .NET Library Task\u003cSdsType\u003e GetTypeAsync(string typeId); Get Type Reference Count Returns a dictionary mapping the object name to the number of references held by streams, stream views and parent types for the specified type. See Streams and Steam Views for more information on the use of types to define streams and stream views. For further details about type referencing please see: Type Reusability . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  ReferenceCount Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response body A dictionary mapping object name to number of references. Example response body: { \"SdsStream\": 3, \"SdsStreamView\": 2, \"SdsType\": 1 } .NET Library Task\u003cIDictionary\u003cstring, int\u003e\u003e GetTypeReferenceCountAsync(string typeId); Get Types Returns a list of types within a given namespace. If specifying the optional search query parameter, the list of types returned will match the search criteria. If the search query parameter is not specified, the list will include all types in the Namespace. See Searching for information about specifying those respective parameters. Note that the results will also include types that were automatically created by SDS as a result of type referencing. For further details about type referencing please see: Type Reusability Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types?query={query}\u0026skip={skip}\u0026count={count}\u0026orderby={orderby} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string query An optional query string to match which SdsTypes will be returned. See the Searching topic for information about specifying the query parameter. int skip An optional value representing the zero-based offset of the first SdsType to retrieve. If not specified, a default value of 0 is used. int count An optional value representing the maximum number of SdsTypes to retrieve. If not specified, a default value of 100 is used. string orderby An optional parameter representing sorted order which SdsTypes will be returned. A field name is required. The sorting is based on the stored values for the given field (of type string). For example, orderby=name would sort the returned results by the name values (ascending by default). Additionally, a value can be provided along with the field name to identify whether to sort ascending or descending, by using values asc or desc , respectively. For example, orderby=name desc would sort the returned results by the name values, descending. If no value is specified, there is no sorting of results. Response The response includes a status code and a response body. Response body A collection of zero or more SdsTypes Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\": \"Simple\", \"Name\": \"Simple\", \"SdsTypeCode\": 1, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"IsKey\": true, \"SdsType\": { \"Id\": \"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\": \"DateTime\", \"SdsTypeCode\": 16 } }, { \"Id\": \"State\", \"Name\": \"State\", \"SdsType\": { \"Id\": \"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\": \"State\", \"SdsTypeCode\": 609, \"Properties\": [ { \"Id\": \"Ok\", \"Value\": 0 }, { \"Id\": \"Warning\", \"Value\": 1 }, { \"Id\": \"Alarm\", \"Value\": 2 } ] } }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": { \"Id\": \"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\": \"Double\", \"SdsTypeCode\": 14 } } ] }, ??? ] .NET Library Task\u003cIEnumerable\u003cSdsType\u003e\u003e GetTypesAsync(string query = \"\", int skip = 0, int count = 100); Get or Create Type Creates the specified type. If a type with a matching identifier already exists, SDS compares the existing type with the type that was sent. If the types are identical, a Found (302) error is returned with the Location header set to the URI where the type may be retrieved using a Get function. If the types do not match, a Conflict (409) error is returned. Note that a Conflict (409) error will also be returned if the type contains reference to any existing type, but the referenced type definition in the body does not match the existing type. You may reference an existing type without including the reference type definition in the body by using only the Ids. For further details about type referencing please see: Type Reusability . For a matching type ( Found ), clients that are capable of performing a redirect that includes the authorization header can automatically redirect to retrieve the type. However, most clients, including the .NET HttpClient, consider redirecting with the authorization token to be a security vulnerability. When a client performs a redirect and strips the authorization header, SDS cannot authorize the request and returns Unauthorized (401). For this reason, it is recommended that when using clients that do not redirect with the authorization header, you should disable automatic redirect and perform the redirect manually. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier. The identifier must match the SdsType.Id field in the request body. Request body The request content is the serialized SdsType. Example SdsType content: { \"Id\": \"Simple\", \"Name\": \"Simple\", \"SdsTypeCode\": 1, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"IsKey\": true, \"SdsType\": { \"Id\": \"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\": \"DateTime\", \"SdsTypeCode\": 16 } }, { \"Id\": \"State\", \"Name\": \"State\", \"SdsType\": { \"Id\": \"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\": \"State\", \"SdsTypeCode\": 609, \"Properties\": [ { \"Id\": \"Ok\", \"Value\": 0 }, { \"Id\": \"Warning\", \"Value\": 1 }, { \"Id\": \"Alarm\", \"Value\": 2 } ] } }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"SdsType\": { \"Id\": \"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\": \"Double\", \"SdsTypeCode\": 14 } } ] } Response The response includes a status code and a response body. Response body The request content is the serialized SdsType. If you are not using the SDS Client Libraries, it is recommended that you use JSON. Example Response body: HTTP/1.1 HTTP 1.1 201 Content-Type: application/json application json { \"Id\": \"Simple\", \"Name\": \"Simple\", \"Description\": null, \"SdsTypeCode\": 1, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": [ { \"Id\": \"Time\", \"Name\": \"Time\", \"Description\": null, \"Order\": 0, \"IsKey\": true, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"19a87a76-614a-385b-ba48-6f8b30ff6ab2\", \"Name\": \"DateTime\", \"Description\": null, \"SdsTypeCode\": 16, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": null, \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"State\", \"Name\": \"State\", \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"e20bdd7e-590b-3372-ab39-ff61950fb4f3\", \"Name\": \"State\", \"Description\": null, \"SdsTypeCode\": 609, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": [ { \"Id\": \"Ok\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 0, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Warning\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 1, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Alarm\", \"Name\": null, \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": null, \"Value\": 2, \"Uom\": null, \"InterpolationMode\": null } ], \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null }, { \"Id\": \"Measurement\", \"Name\": \"Measurement\", \"Description\": null, \"Order\": 0, \"IsKey\": false, \"FixedSize\": 0, \"SdsType\": { \"Id\": \"6fecef77-20b1-37ae-aa3b-e6bb838d5a86\", \"Name\": \"Double\", \"Description\": null, \"SdsTypeCode\": 14, \"IsGenericType\": false, \"IsReferenceType\": false, \"GenericArguments\": null, \"Properties\": null, \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 }, \"Value\": null, \"Uom\": null, \"InterpolationMode\": null } ], \"BaseType\": null, \"DerivedTypes\": null, \"InterpolationMode\": 0, \"ExtrapolationMode\": 0 } .NET Library Task\u003cSdsType\u003e GetOrCreateTypeAsync(SdsType sdsType) If a type with a matching identifier already exists and it matches the type in the request body, the client redirects a GET to the Location header. If the existing type does not match the type in the request body, a Conflict error response is returned and the client library method throws an exception. The .NET SDS Client Libraries manage redirects. Delete Type Deletes a type from the specified tenant and namespace. Note that a type cannot be deleted if any streams, stream views, or other types reference it. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code. .NET Library Task DeleteTypeAsync(string typeId); Get Types Access Control List Get the default ACL for the Types collection. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Types Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body The default ACL for Types .NET Library Task\u003cAccessControlList\u003e GetTypesAccessControlListAsync(); Update Types Access Control List Update the default ACL for the Types collection. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Types Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateTypesAccessControlListAsync(AccessControlList typesAcl); Get Type Access Control List Get the ACL of the specified type. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response Body The ACL for the specified type .NET Library Task\u003cAccessControlList\u003e GetTypeAccessControlListAsync(string typeId); Update Type Access Control List Update the ACL of the specified type. For more information on ACLs, see Access Control . Note that this does not update the ACL for the associated types. For further details about type referencing please see: Type Reusability . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateTypeAccessControlListAsync(string typeId, AccessControlList typeAcl); Get Type Owner Get the Owner of the specified type. For more information on Owners, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response Body The Owner for the specified type .NET Library Task\u003cTrustee\u003e GetTypeOwnerAsync(string typeId); Update Type Owner Update the Owner of the specified type. For more information on Owners, see Access Control . Note that this does not update the Owner for the associated types. For further details about type referencing please see: Type Reusability . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Request body Serialized Owner Response The response includes a status code. .NET Library Task UpdateTypeOwnerAsync(string typeId, Trustee typeOwner); Get Type Access Rights Gets the Access Rights associated with the specified type for the requesting identity. For more information on Access Rights, see Access Control . Request GET api/ api  v1/ v1  /   Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Types/ Types  {typeId}/ {typeId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string typeId The type identifier Response The response includes a status code and a response body. Response Body The Access Rights of the specified type for the requesting identity. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [\"Read\", \"Write\"] .NET Library Task\u003cstring[]\u003e GetTypeAccessRightsAsync(string typeId);"
                                                         },
    "Documentation/SequentialDataStore/SDS_Streams.html":  {
                                                               "href":  "Documentation/SequentialDataStore/SDS_Streams.html",
                                                               "title":  "Streams",
                                                               "keywords":  "Streams SDS stores collections of events and provides convenient ways to find and associating events. Events of consistent structure are stored in streams, called SdsStreams. An SdsType defines the structure of events in an SdsStream. SdsStreams are referenced by their identifier or Id field. SdsStream identifiers must be unique within a Namespace. An SdsStream must include a TypeId that references the identifier of an existing SdsType. When an SdsStream contains data, you must use a stream view to update the stream type. SdsStream management using the .NET SDS Client Libraries is performed through ISdsMetadataService. Create the ISdsMetadataService, using one of the SdsService.GetMetadataService() factory methods. The following table shows the required and optional SdsStream fields. Fields not listed are reserved for internal SDS use. Property Type Optionality Searchable Details Id String Required Yes An identifier for referencing the stream TypeId String Required Yes The SdsType identifier of the type to be used for this stream Name String Optional Yes Friendly name Description String Optional Yes Description text Indexes IList\u003cSdsStreamIndex\u003e Optional No Used to define secondary indexes for stream InterpolationMode SdsInterpolationMode Optional No Interpolation setting of the stream. Default is null. ExtrapolationMode SdsExtrapolationMode Optional No Extrapolation setting of the stream. Default is null. PropertyOverrides IList\u003cSdsStreamPropertyOverride\u003e Optional No Used to define unit of measure and interpolation mode overrides for a stream. Tags * IList\u003cString\u003e Optional Yes A list of tags denoting special attributes or categories. Metadata * IDictionary\u003cString, String\u003e Optional Yes A dictionary of string keys and associated string values. * Notes regarding Tags and Metadata: Stream Tags and Metadata are accessed via the Tags API And Metadata API respectively. However, they are associated with SdsStream objects and can be used as search criteria. Rules for the Stream Identifier (SdsStream.Id) Is not case sensitive Can contain spaces Cannot contain forward slash (\"/\") (\" \") Can contain a maximum of 100 characters Indexes The Key or Primary Index is defined at the SdsType. Secondary Indexes are defined at the SdsStream. Secondary Indexes are applied to a single property; there are no compound secondary indexes. Only SdsTypeCodes that can be ordered are supported for use in a secondary index. Indexes are discussed in greater detail here: Indexes Interpolation and Extrapolation The InterpolationMode, ExtrapolationMode, and PropertyOverrides can be used to determine how a specific stream reads data. These read characteristics are inherited from the type if they are not defined at the stream level. PropertyOverrides PropertyOverrides provide a way to override interpolation behavior and unit of measure for individual SdsType Properties for a specific stream. The SdsStreamPropertyOverride object has the following structure: Property Type Optionality Details SdsTypePropertyId String Required SdsTypeProperty identifier InterpolationMode SdsInterpolationMode Optional Interpolation setting. Default is null Uom String Optional Unit of measure The unit of measure can be overridden for any type property defined by the stream type, including primary keys and secondary indexes. For more information about type property units of measure see Types . Read characteristics of the stream are determined by the type and the PropertyOverrides of the stream. The interpolation mode for non-index properties can be defined and overridden at the stream level. For more information about type read characteristics see Types . When specifying property interpolation overrides, if the SdsType InterpolationMode is Discrete , it cannot be overridden at any level. When InterpolationMode is set to Discrete and an event it not defined for that index, a null value is returned for the entire event. SdsStream API The REST APIs provide programmatic access to read and write SDS data. The APIs in this section interact with SdsStreams. When working in .NET convenient SDS Client libraries are available. The ISdsMetadataService interface, accessed using the SdsService.GetMetadataService( ) helper, defines the available functions. See Streams for general SdsStream information. Get Stream Returns the specified stream. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The requested SdsStream. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Id\":\"Simple\", \"Name\":\"Simple\", \"TypeId\":\"Simple\", } .NET Library Task\u003cSdsStream\u003e GetStreamAsync(string streamId); Get Streams Returns a list of streams. If specifying the optional search query parameter, the list of streams returned will match the search criteria. If the search query parameter is not specified, the list will include all streams in the Namespace. See Searching for information about specifying those respective parameters. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams?query={query}\u0026skip={skip}\u0026count={count}\u0026orderby={orderby} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string query An optional parameter representing a string search. See Searching for information about specifying the search parameter. int skip An optional parameter representing the zero-based offset of the first SdsStream to retrieve. If not specified, a default value of 0 is used. int count An optional parameter representing the maximum number of SdsStreams to retrieve. If not specified, a default value of 100 is used. string orderby An optional parameter representing sorted order which SdsStreams will be returned. A field name is required. The sorting is based on the stored values for the given field (of type string). For example, orderby=name would sort the returned results by the name values (ascending by default). Additionally, a value can be provided along with the field name to identify whether to sort ascending or descending, by using values asc or desc , respectively. For example, orderby=name desc would sort the returned results by the name values, descending. If no value is specified, there is no sorting of results. Response The response includes a status code and a response body. Response body A collection of zero or more SdsStreams. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Id\":\"Simple\", \"TypeId\":\"Simple\" }, { \"Id\":\"Simple with Secondary\", \"TypeId\":\"Simple\", \"Indexes\":[ { \"SdsTypePropertyId\":\"Measurement\" } ] }, { \"Id\":\"Compound\", \"TypeId\":\"Compound\" }, ... ] .NET Library Task\u003cIEnumerable\u003cSdsStream\u003e\u003e GetStreamsAsync(string query = \"\", int skip = 0, int count = 100); Get Stream Type Returns the type definition that is associated with a given stream. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Type Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The requested SdsType. .NET Library Task\u003cSdsType\u003e GetStreamTypeAsync(string streamId); Get or Create Stream Creates the specified stream. If a stream with a matching identifier already exists, SDS compares the existing stream with the stream that was sent. If the streams are identical, a Found (302) error is returned with the Location header set to the URI where the stream may be retrieved using a Get function. If the streams do not match, a Conflict (409) error is returned. For a matching stream (Found), clients that are capable of performing a redirect that includes the authorization header can automatically redirect to retrieve the stream. However, most clients, including the .NET HttpClient, consider redirecting with the authorization token to be a security vulnerability. When a client performs a redirect and strips the authorization header, SDS cannot authorize the request and returns Unauthorized (401). For this reason, it is recommended that when using clients that do not redirect with the authorization header, you should disable automatic redirect. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier. The stream identifier must match the identifier in content. Request body The request content is the serialized SdsStream. Response The response includes a status code and a response body. Response body The newly created SdsStream. .NET Library Task\u003cSdsStream\u003e GetOrCreateStreamAsync(SdsStream SdsStream); If a stream with a matching identifier already exists and it matches the stream in the request body, the client redirects a GET to the Location header. If the existing stream does not match the stream in the request body, a Conflict error response is returned and the client library method throws an exception. Create or Update Stream Creates the specified stream. If a stream with the same Id already exists, the definition of the stream is updated. The following changes are permitted: Name Description Indexes InterpolationMode ExtrapolationMode PropertyOverrides Note that modifying Indexes will result in re-indexing all of the stream\u0027s data for each additional secondary index. For more information on secondary indexes, see Indexes . Unpermitted changes result in an error. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request body The request content is the serialized SdsStream. Response The response includes a status code. .NET Library Task CreateOrUpdateStreamAsync(SdsStream SdsStream); Update Stream Type Updates a stream???s type. The type is modified to match the specified stream view. Defined Indexes and PropertyOverrides are removed when updating a stream type. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Type?streamViewId={streamViewId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string streamViewId The stream view identifier Request body The request content is the serialized SdsStream. Response The response includes a status code. Response body On failure, the content contains a message describing the issue. .NET Library Task UpdateStreamTypeAsync(string streamId, string streamViewId); Delete Stream Deletes a stream. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamAsync(string streamId); Get Streams Access Control List Get the default ACL for the Streams collection. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Streams Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a response body. Response body The default ACL for Streams .NET Library Task\u003cAccessControlList\u003e GetStreamsAccessControlListAsync(); Update Streams Access Control List Update the default ACL for the Streams collection. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  Streams Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateStreamsAccessControlListAsync(AccessControlList streamsAcl); Get Stream Access Control List Get the ACL of the specified stream. For more information on ACLs, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response Body The ACL for the specified stream .NET Library Task\u003cAccessControlList\u003e GetStreamAccessControlListAsync(string streamId); Update Stream Access Control List Update the ACL of the specified stream. For more information on ACLs, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request body Serialized ACL Response The response includes a status code. .NET Library Task UpdateStreamAccessControlListAsync(string streamId, AccessControlList streamAcl); Get Stream Owner Get the Owner of the specified stream. For more information on Owners, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response Body The Owner for the specified stream .NET Library Task\u003cTrustee\u003e GetStreamOwnerAsync(string streamId); Update Stream Owner Update the Owner of the specified stream. For more information on Owners, see Access Control . Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Request body Serialized Owner Response The response includes a status code. .NET Library Task UpdateStreamOwnerAsync(string streamId, Trustee streamOwner); Get Stream Access Rights Gets the Access Rights associated with the specified stream for the requesting identity. For more information on Access Rights, see Access Control . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response Body The Access Rights associated with specified stream for the requesting identity. Example response body: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [\"Read\", \"Write\"] .NET Library Task\u003cstring[]\u003e GetStreamAccessRightsAsync(string streamId);"
                                                           },
    "Documentation/SequentialDataStore/SdsStreamExtra.html":  {
                                                                  "href":  "Documentation/SequentialDataStore/SdsStreamExtra.html",
                                                                  "title":  "Stream Metadata and Tags",
                                                                  "keywords":  "Stream Metadata and Tags SdsStream metadata is represented as a dictionary of string keys and associated string values. It can be used to associate additional information with a stream. SdsStream tags are represented as a list of strings. Tags can be used to categorize or denote special attributes of streams. The SdsStream Metadata API And SdsStream Tags API do not accept the search query parameter in their respective Get calls. However, stream tags and metadata can be used as criteria in search query strings to return SdsStream results with the Stream API. SdsStream Metadata API Get stream metadata Returns the metadata dictionary for the specified stream. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The metadata for the specified SdsStream. Sample response body HTTP/ HTTP  1.1 200 Content-Type: application/ application  json { \"a metadata key\":\"a metadata value\", \"another key\":\"another value\" } .NET Library Task\u003cIDictionary\u003cstring, string\u003e\u003e GetStreamMetadataAsync(string streamId); Security Allowed for administrator and user accounts Get stream metadata value Returns the value for the specified key in the metadata dictionary of the specified stream. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Metadata/ Metadata  {key} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string key The key specifying the metadata value of interest Response The response includes a status code and a response body. Response body The metadata for the specified SdsStream. Sample response body HTTP/ HTTP  1.1 200 Content-Type: application/ application  json { \"a metadata value\" } .NET Library Task\u003cstring\u003e GetStreamMetadataValueAsync(string streamId, string key); Security Allowed for administrator and user accounts Update stream metadata Replaces the metadata for the specified stream with the metadata in the request body. Overwrites any existing metadata; does not merge. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task UpdateStreamMetadataAsync(string streamId, IDictionary\u003cstring, string\u003e metadata); Security Allowed for administrator accounts Patch stream metadata Modifies the metadata based on operations specified in the request body. The request body follows JSON Patch format . Request PATCH api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body A collection of operations to be applied to the metadata collection as specified by the JSON Patch format . .NET Library Task\u003cIDictionary\u003cstring, string\u003e\u003e PatchStreamMetadataAsync(string streamId, MetadataPatchDocument patchDoc); Security Allowed for administrator accounts Delete stream metadata Deletes the metadata for the specified stream. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Metadata Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamMetadataAsync(string streamId); Security Allowed for administrator accounts SdsStream Tags API Get stream tags Returns the tag list for the specified stream. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body. Response body The tags for the specified SdsStream. Sample response body HTTP/ HTTP  1.1 200 Content-Type: application/ application  json [ \"a tag\", \"another tag\" ] .NET Library Task\u003cIList\u003cstring\u003e\u003e GetStreamTagsAsync(string streamId); Security Allowed for administrator and user accounts Update stream tags Replaces the tag list for the specified stream with the tags listed in the request body. Overwrites any existing tags; does not merge. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier The request content is the serialized list of tags. Response The response includes a status code. .NET Library Task UpdateStreamTagsAsync(string streamId, IList\u003cstring\u003e tags); Security Allowed by administrator accounts. Delete stream tags Deletes the tag list for the specified stream. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Tags Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code. .NET Library Task DeleteStreamTagsAsync(string streamId); Security Allowed for administrator accounts."
                                                              },
    "Documentation/SequentialDataStore/Reading_Data_API.html":  {
                                                                    "href":  "Documentation/SequentialDataStore/Reading_Data_API.html",
                                                                    "title":  "API calls for reading data",
                                                                    "keywords":  "API calls for reading data Example Type, Stream, and Data Many of the API methods described below contain example requests and responses in JSON to highlight usage and specific behaviors. The following type, stream, and data are used in the examples. Example Type SimpleType is an SdsType with a single index. This type is defined below in .NET, Python, and Javascript: .NET public enum State { Ok, Warning, Alarm } public class SimpleType { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } public State State { get; set; } [SdsMember(Uom = \"meter\")] public Double Measurement { get; set; } } Python class State(Enum): Ok = 0 Warning = 1 Alarm = 2 class SimpleType(object): Time = property(getTime, setTime) def getTime(self): return self.__time def setTime(self, time): self.__time = time State = property(getState, setState) def getState(self): return self.__state def setState(self, state): self.__state = state Measurement = property(getValue, setValue) def getValue(self): return self.__measurement def setValue(self, measurement): self.__measurement = measurement JavaScript var State = { Ok: 0, Warning: 1, Alarm: 2, } var SimpleType = function () { this.Time = null; this.State = null; this.Value = null; } Example Stream Simple is an SdsStream of type SimpleType . Example Data Simple has stored values as follows: 11/ 11  23/ 23  2017 12:00:00 PM: Ok 0 11/ 11  23/ 23  2017 1:00:00 PM: Ok 10 11/ 11  23/ 23  2017 2:00:00 PM: Ok 20 11/ 11  23/ 23  2017 3:00:00 PM: Ok 30 11/ 11  23/ 23  2017 4:00:00 PM: Ok 40 All times are represented at offset 0, GMT. Get First Value Returns the first value in the stream. If no values exist in the stream, null is returned. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  First Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body containing a serialized event. .NET Library Task\u003cT\u003e GetFirstValueAsync\u003cT\u003e(string streamId, string streamViewId = null); Get Last Value Returns the last value in the stream. If no values exist in the stream, null is returned. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Last Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier Response The response includes a status code and a response body containing a serialized event. .NET Library Task\u003cT\u003e GetLastValueAsync\u003cT\u003e(string streamId, string streamViewId = null); Find Distinct Value Returns a stored event based on the specified index and searchMode . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?index={index}\u0026searchMode={searchMode} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index The index string searchMode The SdsSearchMode , the default is exact Response The response includes a status code and a response body containing a serialized collection with one event. Depending on the request index and searchMode , it is possible to have an empty collection returned. Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?index=2017-11-23T13:00:00Z\u0026searchMode=Next The request has an index that matches the index of an existing event, but since a SdsSearchMode of next was specified, the response contains the next event in the stream after the specified index: Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 } ] Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?index=2017-11-23T13:30:00Z\u0026searchMode=Next The request specifies an index that does not match an index of an existing event. The next event in the stream is retrieved. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 } ] .NET Library Task\u003cT\u003e FindDistinctValueAsync\u003cT\u003e(string streamId, string index, SdsSearchMode searchMode = SdsSearchMode.Exact, string streamViewId = null); Task\u003cT\u003e FindDistinctValueAsync\u003cT, T1\u003e(string streamId, Tuple\u003cT1\u003e index, SdsSearchMode searchMode = SdsSearchMode.Exact, string streamViewId = null); Task\u003cT\u003e FindDistinctValueAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e index, SdsSearchMode searchMode = SdsSearchMode.Exact, string streamViewId = null); Get Values Returns a collection of stored values at indexes based on request parameters. SDS supports three ways of specifying which stored events to return: Filtered : A filtered request accepts a filter expression . Range : A range request accepts a start index and a count. Window : A window request accepts a start index and end index. This request has an optional continuation token for large collections of events. Filtered Returns a collection of stored values as determined by a filter . The filter limits results by applying an expression against event fields. Filter expressions are explained in detail in the Filter expressions section. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?filter={filter} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string filter The filter expression (see Filter expressions ) Response The response includes a status code and a response body containing a serialized collection of events. Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?filter=Measurement gt 10 The events in the stream with Measurement greater than 10 are returned. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T14:00:00Z\", \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"Measurement\": 30 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"Measurement\": 40 } ] Note that State is not included in the JSON as its value is the default value. .NET Library Task\u003cIEnumerable\u003cT\u003e\u003e GetFilteredValuesAsync\u003cT\u003e(string streamId, string filter, string streamViewId = null); Range Returns a collection of stored values as determined by a startIndex and count . Additional optional parameters specify the direction of the range, how to handle events near or at the start index, whether to skip a certain number of events at the start of the range, and how to filter the data. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026count={count}[\u0026skip={skip}\u0026reversed={reversed} \u0026boundaryType={boundaryType}\u0026filter={filter}] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index identifying the beginning of the series of events to return int count The number of events to return int skip Optional value specifying the number of events to skip at the beginning of the result bool reversed Optional specification of the direction of the request. By default, range requests move forward from startIndex, collecting events after startIndex from the stream. A reversed request will collect events before startIndex from the stream. SdsBoundaryType boundaryType Optional SdsBoundaryType specifies the handling of events at or near startIndex string filter Optional filter expression Response The response includes a status code and a response body containing a serialized collection of events. Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T13:00:00Z\u0026count=100 This request will return a response with up to 100 events starting at 13:00 and extending forward toward the end of the stream: Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"Measurement\": 30 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"Measurement\": 40 } ] Note that State is not included in the JSON as its value is the default value. Example To reverse the direction of the request, set reversed to true. The following request will return up to 100 events starting at 13:00 and extending back toward the start of the stream: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T13:00:00Z\u0026count=100\u0026reversed=true Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"Measurement\": 10 }, { \"Time\": \"2017-11-23T12:00:00Z\" } ] Note that State is not included in the JSON as its value is the default value. Further, Measurement is not included in the second, 12:00:00, event as zero is the default value for numbers. The following request specifies a boundary type of Outside for a reversed-direction range request. The response will contain up to 100 events. The boundary type Outside indicates that up to one event outside the boundary will be included in the response. For a reverse direction range request, this means one event forward of the specified start index. In a default direction range request, it would mean one event before the specified start index. GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T13:00:00Z\u0026count=100\u0026reversed=true \u0026boundaryType=2 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 0 } ] The event outside of the index is the next event or the event at 14:00 because the request operates in reverse. Adding a filter to the request means only events that meet the filter criteria are returned: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T13:00:00Z\u0026count=100\u0026reversed=true \u0026boundaryType=2\u0026filter=Measurement gt 10 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 } ] .NET Library Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT\u003e(string streamId, string startIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT\u003e(string streamId, string startIndex, int count, bool reversed, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, int count, bool reversed, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, int count, bool reversed, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT\u003e(string streamId, string startIndex, int count, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, int count, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, int count, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT\u003e(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeFilteredValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetRangeFilteredValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, int skip, int count, bool reversed, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Window Returns a collection of stored events based on the specified startIndex and endIndex . For handling events at and near the boundaries of the window, a single SdsBoundaryType that applies to both the start and end indexes can be passed with the request, or separate boundary types may be passed for the start and end individually. Paging is supported for window requests with a large number of events. To retrieve the next page of values, include the continuationToken from the results of the previous request. For the first request, specify a null or empty string for the continuationToken . Requests GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026endIndex={endIndex} GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026endIndex={endIndex}\u0026boundaryType={boundaryType} GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026startBoundaryType={startBoundaryType} \u0026endIndex={endIndex}\u0026endBoundaryType={endBoundaryType} GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026endIndex={endIndex} \u0026count={count}\u0026continuationToken={continuationToken} GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data ?startIndex={startIndex}\u0026startBoundaryType={startBoundaryType} \u0026endIndex={endIndex}\u0026endBoundaryType={endBoundaryType}\u0026filter={filter}\u0026count={count} \u0026continuationToken={continuationToken} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex Index bounding the beginning of the series of events to return string endIndex Index bounding the end of the series of events to return int count Optional maximum number of events to return. If count is specified, a continuationToken must also be specified. SdsBoundaryType boundaryType Optional SdsBoundaryType specifies handling of events at or near the start and end indexes SdsBoundaryType startBoundaryType Optional SdsBoundaryType specifies the first value in the result in relation to the start index. If startBoundaryType is specified, endBoundaryType must be specified. SdsBoundaryType endBoundaryType Optional SdsBoundaryType specifies the last value in the result in relation to the end index. If startBoundaryType is specified, endBoundaryType must be specified. string filter Optional filter expression string continuationToken Optional token used to retrieve the next page of data. If count is specified, a continuationToken must also be specified. Response The response includes a status code and a response body containing a serialized collection of events. A continuation token can be returned if specified in the request. Example The following requests all stored events between 12:30 and 15:30: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T12:30:00Z\u0026endIndex=2017-11-23T15:30:00Z The response will contain the event stored at the specified index: Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"Measurement\": 30 } ] Note that State is not included in the JSON as its value is the default value. Example When the request is modified to specify a boundary type of Outside, the value before 13:30 and the value after 15:30 are included: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T12:30:00Z\u0026endIndex=2017-11-23T15:30:00Z \u0026boundaryType=2 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T12:00:00Z\" }, { \"Time\": \"2017-11-23T13:00:00Z\", \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"Measurement\": 30 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"Measurement\": 40 } ] Note that State is not included in the JSON as its value is the default value. Further, Measurement is not included in the second, 12:00:00, event as zero is the default value for numbers. If instead a start boundary of Inside, only values inside the start boundary (after 13:30) are included in the result. With an end boundary of Outside one value outside the end index (after 15:30) is included: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T12:30:00Z\u0026\u0026startBoundaryType=1 \u0026endIndex=2017-11-23T15:30:00Z\u0026endBoundaryType=2 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 } ] In order to page the results of the request, a continuation token may be specified. This requests the first page of the first two stored events between start index and end index by indicating count is 2 and continuationToken is an empty string: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T12:30:00Z\u0026endIndex=2017-11-23T15:30:00Z \u0026count=2\u0026continuationToken= Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Results\": [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 } ], \"ContinuationToken\": \"2017-11-23T14:00:00.0000000Z\" } This request uses the continuation token from the previous page to request the next page of stored events: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}}/ {tenantId}}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data ?startIndex=2017-11-23T12:30:00Z\u0026endIndex=2017-11-23T15:30:00Z \u0026count=2\u0026continuationToken=2017-11-23T14:00:00Z Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json { \"Results\": [ { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 30 } ], \"ContinuationToken\": null } In this case, the results contain the final event. The returned continuation token is null. .NET Library Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, SdsBoundaryType startBoundaryType, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType endBoundaryType, string filter, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType boundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType boundaryType, string filter, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT\u003e(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, SdsBoundaryType startBoundaryType, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType endBoundaryType, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, SdsBoundaryType startBoundaryType, T1 endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string streamViewId = null); Task\u003cSdsResultPage\u003cT\u003e\u003e GetWindowFilteredValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, SdsBoundaryType startBoundaryType, Tuple\u003cT1, T2\u003e endIndex, SdsBoundaryType endBoundaryType, string filter, int count, string continuationToken, string streamViewId = null); Get Interpolated Values Returns a collection of values based on request parameters. The stream\u0027s read characteristics determine how events are calculated for indexes at which no stored event exists. Interpolation is not supported for streams with compound indexes. SDS supports two ways of specifying which interpolated events to return: Index Collection : One or more indexes can be passed to the request in order to retrieve events at specific indexes. Interval : An interval can be specified with a start index, end index, and count. This will return the specified count of events evenly spaced from start index to end index. Index Collection Returns events at the specified indexes. If no stored event exists at a specified index, the stream\u0027s read characteristics determine how the returned event is calculated. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Interpolated?index={index}[\u0026index={index}...] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string index One or more indexes Response The response includes a status code and a response body containing a serialized collection of events. Depending on the specified indexes and read characteristics of the stream, it is possible to have less events returned than specified indexes. An empty collection can also be returned. Example Consider a stream of type Simple with the default InterpolationMode of Continuous and ExtrapolationMode of All . In the following request, the specified index matches an existing stored event: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Interpolated?index=2017-11-23T13:00:00Z The response will contain the event stored at the specified index. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 } ] The following request specifies an index for which no stored event exists: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Interpolated?index=2017-11-23T13:30:00Z Because the index is a valid type for interpolation and the stream has a InterpolationMode of Continuous , this request receives a response with an event interpolated at the specified index: Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:30:00Z\", \"State\": 0, \"Measurement\": 15 } ] Consider a stream of type Simple with an InterpolationMode of Discrete and ExtrapolationMode of All . In the following request, the specified indexes only match two existing stored events: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}}/ {tenantId}}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data Interpolated?index=2017-11-23T12:30:00Z\u0026index=2017-11-23T13:00:00Z\u0026index=2017-11-23T14:00:00Z For this request, the response contains events for two of the three specified indexes. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 } ] .NET Library Task\u003cT\u003e GetValueAsync\u003cT\u003e(string streamId, string index, string streamViewId = null); Task\u003cT\u003e GetValueAsync\u003cT, T1\u003e(string streamId, Tuple\u003cT1\u003e index, string streamViewId = null); Task\u003cT\u003e GetValueAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e index, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT\u003e(string streamId, IEnumerable\u003cstring\u003e index, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT, T1\u003e(string streamId, IEnumerable\u003cT1\u003e index, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT, T1, T2\u003e(string streamId, IEnumerable\u003cTuple\u003c T1, T2\u003e\u003e index, string streamViewId = null); Interval Returns events at evenly spaced intervals based on the specified start index, end index, and count. If no stored event exists at an index interval, the stream\u0027s read characteristics determine how the returned event is calculated. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Interpolated?startIndex={startIndex}\u0026endIndex={endIndex}\u0026count={count} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The index defining the beginning of the window string endIndex The index defining the end of the window int count The number of events to return. Read characteristics of the stream determine how the events are constructed. Response The response includes a status code and a response body containing a serialized collection of events. Depending on the read characteristics and input parameters, it is possible for a collection to be returned with less events than specified in the count. For a stream, named Simple, of type Simple for the following request: GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}}/ {tenantId}}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Interpolated?startIndex=2017-11-23T13:00:00Z\u0026endIndex=2017-11-23T15:00:00Z\u0026count=3 the start and end fall exactly on event indexes, and the number of events from start to end match the count of three (3). Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 30 } ] .NET Library Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetValuesAsync\u003cT, T1, T2\u003e(string streamId, Tuple\u003cT1, T2\u003e startIndex, Tuple\u003cT1, T2\u003e endIndex, int count, string streamViewId = null); Get Summaries Returns summary intervals between a specified start and end index. Index types that cannot be interpolated do not support summary requests. Strings are an example of indexes that cannot be interpolated. Summaries are not supported for streams with compound indexes. Interpolating between two indexes that consist of multiple properties is not defined and results in non-determinant behavior. Summary values supported by SdsSummaryType enum: Summary Enumeration value Count 1 Minimum 2 Maximum 4 Range 8 Mean 16 StandardDeviation 64 Total 128 Skewness 256 Kurtosis 512 WeightedMean 1024 WeightedStandardDeviation 2048 WeightedPopulationStandardDeviation 4096 Count, Minimum, Maximum, and Range are based only on stored events and do not include interpolated values. Mean, Standard Deviation, Skewness, and Kurtosis are event-weighted calculations. Total, Weighted Mean, WeightedStandardDeviation, and WeightedPopulationStandardDeviation are index-weighted calculations. Currently, these values can only be calculated for properties of the following types: Type SdsTypeCode Boolean 3 Byte 6 Char 4 Decimal 15 Int16 7 Int32 9 Int64 11 SByte 5 Single 13 UInt16 8 UInt32 10 UInt64 12 DateTime 16 Double 14 DateTimeOffset 20 TimeSpan 21 NullableBoolean 103 NullableByte 106 NullableChar 104 NullableDecimal 115 NullableInt16 107 NullableInt32 109 NullableInt64 111 NullableSByte 105 NullableSingle 113 NullableUInt16 108 NullableUInt32 110 NullableUInt64 112 NullableDateTime 116 NullableDouble 114 NullableDateTimeOffset 120 NullableTimeSpan 121 Note: Properties marked with an InterpolationMode of Discrete do not support summaries. Unsupported properties will be excluded from the summaries returned. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Summaries?startIndex={startIndex}\u0026endIndex={endIndex}\u0026count={count}[\u0026filter={filter}] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The start index for the intervals string endIndex The end index for the intervals int count The number of intervals requested string filter Optional filter expression Response The response includes a status code and a response body containing a serialized collection of SdsIntervals. Each SdsInterval has a start, end, and collection of summary values. Property Details Start The start of the interval End The end of the interval Summaries The summary values for the interval, keyed by summary type. The nested dictionary contains property name keys and summary calculation result values. Example The following request calculates two summary intervals between the startIndex and endIndex : GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Summaries?startIndex=2017-11-23T12:00:00Z\u0026endIndex=2017-11-23T16:00:00Z\u0026count=2 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Start\": { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 0 }, \"End\": { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 }, \"Summaries\": { \"Count\": { \"Time\": 3, \"Measurement\": 3 }, \"Minimum\": { \"Measurement\": 0 }, \"Maximum\": { \"Measurement\": 20 }, \"Range\": { \"Measurement\": 20 }, \"Total\": { \"Measurement\": 20 }, \"Mean\": { \"Measurement\": 10 }, \"StandardDeviation\": { \"Measurement\": 7.0710678118654755 }, \"PopulationStandardDeviation\": { \"Measurement\": 5 }, \"WeightedMean\": { \"Measurement\": 10 }, \"WeightedStandardDeviation\": { \"Measurement\": 7.0710678118654755 }, \"WeightedPopulationStandardDeviation\": { \"Measurement\": 5 }, \"Skewness\": { \"Measurement\": 0 }, \"Kurtosis\": { \"Measurement\": -2 } } }, { \"Start\": { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 20 }, \"End\": { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 }, \"Summaries\": { \"Count\": { \"Time\": 3, \"Measurement\": 3 }, \"Minimum\": { \"Measurement\": 30 }, \"Maximum\": { \"Measurement\": 40 }, \"Range\": { \"Measurement\": 10 }, \"Total\": { \"Measurement\": 60 }, \"Mean\": { \"Measurement\": 30 }, \"StandardDeviation\": { \"Measurement\": 7.0710678118654755 }, \"PopulationStandardDeviation\": { \"Measurement\": 5 }, \"WeightedMean\": { \"Measurement\": 30 }, \"WeightedStandardDeviation\": { \"Measurement\": 7.0710678118654755 }, \"WeightedPopulationStandardDeviation\": { \"Measurement\": 5 }, \"Skewness\": { \"Measurement\": 0 }, \"Kurtosis\": { \"Measurement\": -2 } } } ] SDS also supports summary requests for nullable SdsTypes. It means an SdsType has at least a nullable SdsTypeProperty. Example The following example contains a nullable double property with interpolation mode set to continuous: .NET public class SimpleType { [SdsMember(IsKey = true, Order = 0) ] public DateTime Time { get; set; } [SdsMember(Uom = \"meter\")] public double? Measurement { get; set; } } Measurement has stored values as follows: 11/ 11  23/ 23  2017 12:00:01 PM: Measurement 2 11/ 11  23/ 23  2017 12:00:02 PM: Measurement 2 11/ 11  23/ 23  2017 12:00:03 PM: Measurement null 11/ 11  23/ 23  2017 12:00:04 PM: Measurement 1 11/ 11  23/ 23  2017 12:00:05 PM: Measurement 2 11/ 11  23/ 23  2017 12:00:06 PM: Measurement null 11/ 11  23/ 23  2017 12:00:07 PM: Measurement null 11/ 11  23/ 23  2017 12:00:08 PM: Measurement 3 While calculating weighted summaries, if we encounter a null value at a given index then we would consider interpolation mode of property to find the interpolated value of the given interval. See the table below for [12:00:02 PM, 12:00:03 PM] interval. The values are 2 and null at 12:00:02 and 12:00:03 PM respectively. Interpolation Mode Weight in seconds Value in meter Continuous 0 0 ContinuousNullableLeading StepwiseContinuousLeading 1 2 ContinuousNullableTrailing StepwiseContinuousTrailing 0 0 Similarly, for intervals [12:00:03 PM, 12:00:04 PM] and [12:00:04 PM, 12:00:05 PM] respectively, the table would look like below: Interpolation Mode Weight in seconds Value in meter Continuous 0 0 ContinuousNullableLeading StepwiseContinuousLeading 0 0 ContinuousNullableTrailing StepwiseContinuousTrailing 1 1 Interpolation Mode Weight in seconds Value in meter Continuous 1 1.5 ContinuousNullableLeading StepwiseContinuousLeading 1 1 ContinuousNullableTrailing StepwiseContinuousTrailing 1 2 Note: Non-weighted summaries disregard null values and treat them as non-existent. In the example above, non-weighted summaries for Measurement would be calculated based on (2,2,1,2,3) whereas weighted summaries for Measurement consider null values for its calculation. For more information see Interpolation . The following request calculates one summary interval between the startIndex and endIndex : GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Summaries?startIndex=2017-11-23T12:00:01Z\u0026endIndex=2017-11-23T12:00:08Z\u0026count=1 Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Start\": { \"Time\": \"2017-11-23T12:00:01Z\", \"Measurement\": 2 }, \"End\": { \"Time\": \"2017-11-23T12:00:08Z\", \"Measurement\": 3 }, \"Summaries\": { \"Count\": { \"Time\": 8, \"Measurement\": 5 }, \"Minimum\": { \"Measurement\": 1 }, \"Maximum\": { \"Measurement\": 3 }, \"Range\": { \"Measurement\": 2 }, \"Total\": { \"Measurement\": 7.5 }, \"Mean\": { \"Measurement\": 1.875 }, \"StandardDeviation\": { \"Measurement\": 0.478713553878169 }, \"PopulationStandardDeviation\": { \"Measurement\": 0.41457809879442492 }, \"WeightedMean\": { \"Measurement\": 1.75 }, \"WeightedStandardDeviation\": { \"Measurement\": 0.35355339059327379 }, \"WeightedPopulationStandardDeviation\": { \"Measurement\": 0.25 }, \"Skewness\": { \"Measurement\": 0.49338220021815865 }, \"Kurtosis\": { \"Measurement\": -1.3719008264462809 } } } ] .NET Library Task\u003cIEnumerable\u003cSdsInterval\u003cT\u003e\u003e\u003e GetIntervalsAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cSdsInterval\u003cT\u003e\u003e\u003e GetIntervalsAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, int count, string streamViewId = null); Task\u003cIEnumerable\u003cSdsInterval\u003cT\u003e\u003e\u003e GetFilteredIntervalsAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int count, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cSdsInterval\u003cT\u003e\u003e\u003e GetFilteredIntervalsAsync\u003cT, T1\u003e(string streamId, T1 startIndex, T1 endIndex, int count, string filter, string streamViewId = null); Get Sampled Values Returns representative data sampled by intervals between a specified start and end index. Sampling is driven by a specified property or properties of the stream\u0027s Sds Type. Property types that cannot be interpolated do not support sampling requests. Strings are an example of a property that cannot be interpolated. For more information see Interpolation . Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  {streamId}/ {streamId}  Data/ Data  Sampled?startIndex={startIndex}\u0026endIndex={endIndex}\u0026intervals={intervals}\u0026sampleBy={sampleBy} [\u0026sampleBy={sampleBy}\u0026...\u0026boundaryType={boundaryType}\u0026startBoundaryType={startBoundaryType} \u0026endBoundaryType={endBoundaryType}\u0026filter={filter}] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streamId The stream identifier string startIndex The start index for the intervals string endIndex The end index for the intervals int intervals The number of intervals requested string sampleBy Property or properties to use when sampling SdsBoundaryType boundaryType Optional SdsBoundaryType specifies the handling of events at or near the startIndex and endIndex SdsBoundaryType startBoundaryType Optional SdsBoundaryType specifies the handling of events at or near the startIndex SdsBoundaryType endBoundaryType Optional SdsBoundaryType specifies the handling of events at or near the endIndex string filter Optional filter expression Response The response includes a status code and a response body containing a serialized collection of events. Example The following request returns two sample intervals between the startIndex and endIndex : GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Streams/ Streams  Simple/ Simple  Data/ Data  Sampled?startIndex=2019-01-01T00:00:00Z\u0026endIndex=2019-01-02T00:00:00Z\u0026intervals=2\u0026sampleBy=Measurement Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2019-01-01T00:00:01Z\", \"State\": 1, \"Measurement\": 1 }, { \"Time\": \"2019-01-01T00:11:50Z\", \"State\": 2, \"Measurement\": 0.00006028870675578446 }, { \"Time\": \"2019-01-01T11:55:33Z\", \"Measurement\": 6.277981349066863 }, { \"Time\": \"2019-01-01T12:00:00Z\", \"Measurement\": 3.101013140344655 }, { \"Time\": \"2019-01-01T12:00:01Z\", \"State\": 1, \"Measurement\": 4.101013140344655 }, { \"Time\": \"2019-01-01T12:01:50Z\", \"State\": 2, \"Measurement\": 0.0036776111121028521 }, { \"Time\": \"2019-01-01T23:57:23Z\", \"State\": 2, \"Measurement\": 6.2816589601789659 }, { \"Time\": \"2019-01-02T00:00:00Z\", \"Measurement\": 6.20202628068931 } ] Note that State is not included in the JSON when its value is the default value. .NET Library Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, SdsBoundaryType boundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, SdsBoundaryType startBoundaryType, SdsBoundaryType endBoundaryType, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, SdsBoundaryType boundaryType, string filter, string streamViewId = null); Task\u003cIEnumerable\u003cT\u003e\u003e GetSampledFilteredValuesAsync\u003cT\u003e(string streamId, string startIndex, string endIndex, int intervals, IEnumerable\u003cstring\u003e sampleBy, SdsBoundaryType startBoundaryType, SdsBoundaryType endBoundaryType, string filter, string streamViewId = null); Join Values Returns data from multiple streams, which are joined based on the request specifications. The streams must be of the same SdsType. SDS supports the following types of joins: SdsJoinMode Enumeration value Operation Inner 0 Results include the stored events with common indexes across specified streams. Outer 1 Results include the stored events for all indexes across all streams. Interpolated 2 Results include events for each index across all streams for the request index boundaries. Some events may be interpolated. MergeLeft 3 Results include events for each index across all streams selecting events at the indexes based on left to right order of the streams. MergeRight 4 Results include events for each index across all streams selecting events at the indexes based on right to left order of the streams. SDS supports two types of join requests: GET : The stream, joinMode, start index, and end index are specified in the request URI path. POST : Only the SdsJoinMode is specified in the URI. The streams and read specification for each stream are specified in the body of the request. GET Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams={streams}\u0026joinMode={joinMode}\u0026startIndex={startIndex}\u0026endIndex={endIndex} [\u0026boundaryType={boundaryType}\u0026startBoundaryType={startBoundaryType} \u0026endBoundaryType={endBoundaryType}\u0026filter={filter}\u0026count={count}] Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string streams Commas separated list of stream identifiers SdsJoinMode joinMode Type of join, i.e. inner, outer, etc. string startIndex Index identifying the beginning of the series of events to return string endIndex Index identifying the end of the series of events to return int count Optional maximum number of events to return. SdsBoundaryType boundaryType Optional SdsBoundaryType specifies the handling of events at or near the startIndex and endIndex SdsBoundaryType startBoundaryType Optional SdsBoundaryType specifies the handling of events at or near the startIndex SdsBoundaryType endBoundaryType Optional SdsBoundaryType specifies the handling of events at or near the endIndex string filter Optional filter expression Response The response includes a status code and a response body containing multiple serialized events. See examples for specifics. Examples To join multiple streams, for example Simple1 and Simple2, assume that Simple1 presents the following data: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 } ] And assume that Simple2 presents the following data: HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 50 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 60 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 }, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] The following are responses for various Joins request options: Inner Join Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams=Simple1,Simple2\u0026joinMode=inner \u0026startIndex=0001-01-01T00:00:00.0000000\u0026endIndex=9999-12-31T23:59:59.9999999 Response Measurements from both streams with common indexes. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 60 } ] ] Outer Join Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams=Simple1,Simple2\u0026joinMode=outer \u0026startIndex=0001-01-01T00:00:00.0000000\u0026endIndex=9999-12-31T23:59:59.9999999 Response All Measurements from both Streams, with default values at indexes where a Stream does not have a value. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, null ], [ null, { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 50 } ], [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, null ], [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 60 } ], [ null, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 } ], [ { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 }, null ], [ null, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] ] Interpolated Join Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams=Simple1,Simple2\u0026joinMode=interpolated \u0026startIndex=0001-01-01T00:00:00.0000000\u0026endIndex=9999-12-31T23:59:59.9999999 Response All Measurements from both Streams with missing values interpolated. If the missing values are between valid Measurements within a Stream, they are interpolated. If the missing values are outside of the boundary values, they are extrapolated. Note: The Interpolated SdsJoinMode currently does not support SdsInterpolationModes of the streams. All join requests with interpolations will honor the interpolation mode of the stream type or type property. For more information, see Interpolation . Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 50 } ], [ { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 15 }, { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 50 } ], [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 55 } ], [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 60 } ], [ { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 35 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 } ], [ { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 75 } ], [ { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 40 }, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] ] MergeLeft Join Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams=Simple1,Simple2\u0026joinMode=mergeleft \u0026startIndex=0001-01-01T00:00:00.0000000\u0026endIndex=9999-12-31T23:59:59.9999999 Response This is similar to OuterJoin , but value at each index is the first available value at that index when iterating the given list of streams from left to right. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 50 }, { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 }, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] MergeRight Join Example GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?streams=Simple1,Simple2\u0026joinMode=mergeright \u0026startIndex=0001-01-01T00:00:00.0000000\u0026endIndex=9999-12-31T23:59:59.9999999 Response This is similar to OuterJoin , but value at each index is the first available value at that index when iterating the given list of streams from right to left. Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, { \"Time\": \"2017-11-23T12:00:00Z\", \"State\": 0, \"Measurement\": 50 }, { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 60 }, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 }, { \"Time\": \"2017-11-23T16:00:00Z\", \"State\": 0, \"Measurement\": 40 }, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] POST Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins? joinMode={joinMode} Parameters string tenantId The tenant identifier string namespaceId The namespace identifier SdsJoinMode joinMode Type of join, i.e. inner, outer, etc. Request Body Read options specific to each stream. Response The response includes a status code and a response body containing multiple serialized events. Consider the following outer join request, POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  Bulk/ Bulk  Streams/ Streams  Data/ Data  Joins ?joinMode=outer where in the request body, different start indexes and end indexes are specified per stream, [ { \"StreamId\": \"Simple1\", \"Options\": { \"StartIndex\": \"2017-11-23T11:00:00Z\", \"EndIndex\": \"2017-11-23T14:00:00Z\", \"StartBoundaryType\": \"Exact\", \"EndBoundaryType\": \"Exact\", \"Count\": 100, \"Filter\": \"\" } }, { \"StreamId\": \"Simple2\", \"Options\": { \"StartIndex\": \"2017-11-23T15:00:00Z\", \"EndIndex\": \"2017-11-23T17:00:00Z\", \"StartBoundaryType\": \"Exact\", \"EndBoundaryType\": \"Exact\", \"Count\": 100, \"Filter\": \"\" } } ] Only events within the stream\u0027s specified index boundaries are considered for the outer join operation Response body HTTP/1.1 HTTP 1.1 200 Content-Type: application/json application json [ [ { \"Time\": \"2017-11-23T11:00:00Z\", \"State\": 0, \"Measurement\": 10 }, null ], [ { \"Time\": \"2017-11-23T13:00:00Z\", \"State\": 0, \"Measurement\": 20 }, null ], [ { \"Time\": \"2017-11-23T14:00:00Z\", \"State\": 0, \"Measurement\": 30 }, null ], [ null, { \"Time\": \"2017-11-23T15:00:00Z\", \"State\": 0, \"Measurement\": 70 } ], [ null, { \"Time\": \"2017-11-23T17:00:00Z\", \"State\": 0, \"Measurement\": 80 } ] ] Notice that not all the values from Streams were included since they are restricted by individual queries for each Stream. .NET Library Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, string endIndex); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, string endIndex, int count); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, int count); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsJoinType joinMode, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, int count); Task\u003cIEnumerable\u003cIList\u003cT\u003e\u003e\u003e GetJoinValuesAsync\u003cT\u003e(SdsJoinType joinMode, IList\u003cSdsStreamQuery\u003e sdsStreamsQueryOptions); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(SdsMergeType joinMode, IList\u003cSdsStreamQuery\u003e sdsStreamsQueryOptions); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, string endIndex); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, string endIndex, int count); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, string endIndex, SdsBoundaryType boundaryType, string filter, int count); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter); Task\u003cIList\u003cT\u003e\u003e GetMergeValuesAsync\u003cT\u003e(IEnumerable\u003cstring\u003e streams, SdsMergeType joinMode, string startIndex, SdsBoundaryType startBoundaryType, string endIndex, SdsBoundaryType endBoundaryType, string filter, int count);"
                                                                },
    "Documentation/Identity/Identity_User.html":  {
                                                      "href":  "Documentation/Identity/Identity_User.html",
                                                      "title":  "User",
                                                      "keywords":  "User Users consume resources in a Tenant. They are invited by the Admin of the Tenant and should already have an account in one of the configured Identity Providers for this Tenant. A User is fully provisioned in OSIsoft Cloud Services only after they have accepted the invitation and successfully logged with an Identity Provider. OSIsoft Cloud Services does not maintain User credentials, but it delegates authentication to the Identity Provider the User logged in with at first. Once logged in the User cannot change the Identity Provider it signed up with. A Tenant can only have one User with a given email to an Identity Provider. If a User has multiple aliases in the same Identity Provider, they will not be able to create multiple corresponding OSIsoft Cloud Services users. Users have roles associated with them. These roles determine what a User is authorized to do in the Tenant. Roles are assigned to a User upon creation and can be modified by an Admin. We allow the change of some User fields and the complete deletion of a User. Properties For HTTP requests and responses, the User object has the following properties and JSON-serialized body: Property Type Description Id Guid Gets or sets unique User ID. GivenName string Gets or sets given name of user. Surname string Gets or sets surname of user. Name string Gets or sets name of user. Email string Gets or sets email of user. ContactEmail string Gets or sets contact email for user. User will only be contacted through this email. ContactGivenName string Gets or sets preferred contact name for user. ContactSurname string Gets or sets preferred contact surname for user. ExternalUserId string Gets or sets provider id for user. This is the unique ID we get from the Identity Provider. IdentityProviderId Guid Gets or sets Identity Provider Id used to authenticate User. Will be set once the User accepts an invitation. If not specified when sending the invitation to the User, it can be any of the Identity Provider Ids configured for this Tenant. RoleIds Guid[] Gets or sets list of strings of RoleIds. Serialized Model { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Get Users from a Tenant Get a list of users from a Tenant. Optionally, get a list of requested users. Total number of users in the Tenant set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] Guid[] id Unordered list of User Ids to get. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of users to skip. Ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of users to return. Ignored if a list of Ids is passed. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: List [ { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] }, { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } ] 207 Partial success. Type: MultiStatusResponse { \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"ChildErrors\": [ { \"StatusCode\": 0, \"ModelId\": \"ModelId\", \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"Resolution\": \"Resolution\" }, { \"StatusCode\": 0, \"ModelId\": \"ModelId\", \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"Resolution\": \"Resolution\" } ], \"Data\": [ { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] }, { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } ] } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Get Users\u0027 Invitation Status Get invitation statuses for multiple users. Optionally restrict it only to users of a specific invitation status. The User status can be: InvitationAccepted (0), NoInvitation (1), InvitationNotSent (2), InvitationSent (3), InvitationExpired (4). Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  Status Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] Guid[] id Unordered list of User Ids to get. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of users to skip. Ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of users to return. Ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = \"\"] string[] status Only return statuses that match these values. Possible User statuses are: InvitationAccepted, NoInvitation, InvitationNotSent, InvitationSent, InvitationExpired. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: List [ { \"InvitationStatus\": 0, \"User\": { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } }, { \"InvitationStatus\": 0, \"User\": { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } } ] 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 500 Internal server error. 404 Tenant not found. Get User from a Tenant Get a User from Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: User { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 500 Internal server error. Get User\u0027s Invitation Status Get invitation status for a User. It can be: InvitationAccepted (0), NoInvitation (1), InvitationNotSent (2), InvitationSent (3), InvitationExpired (4). Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Status Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: UserStatus { \"InvitationStatus\": 0, \"User\": { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } } 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 500 Internal server error. Get User\u0027s Preferences Get preferences from a User. User preferences can be any valid JSON object. A common use case is to store UI preferences for the User. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Preferences Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: JObject {} 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 500 Internal server error. Update User\u0027s Preferences Update preferences for a User. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Preferences Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. [FromBody] [Required] JObject preferences JSON object preferences. {} Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: JObject {} 400 Missing preferences. 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Create User Create a User in the Tenant. This endpoint does not create an invitation for the User. You will need to create an invitation in the respective endpoint for this User, otherwise they will not be able to finish the sign-up process. Users have unique Ids in a Tenant. Currently there is a limit of 50000 users per Tenant. For Windows Active Directory users, the externalUserId must be specified. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] UserCreateOrUpdate userCreateOrUpdate UserCreateOrUpdate object. Property Type Required Description Id Guid No Gets or sets user Id for the user. When creating a user, if User ID is not specified, one will be generated. ExternalUserId string No Gets or sets user ExternalUserId for the user. Must be specified if Identity Provider is Windows Active Directory. ContactGivenName string No Gets or sets preferred name to be used when contacting user. ContactSurname string No Gets or sets preferred surname to be used when contacting user. ContactEmail string No Gets or sets preferred contact email to be used. This does not have to be the same as the user\u0027s Identity Provider email. IdentityProviderId Guid No Gets or sets Identity Provider this user will be required to use to login. If null, the Identity Provider Id will be set when creating the Invitation. RoleIds Guid[] No Gets or sets list of strings of RoleIds. { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"ExternalUserId\": \"ExternalUserId\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ContactEmail\": \"user@company.com\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: User { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } 400 Missing or invalid inputs, or the User limit exceeded for Tenant. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Update User in a Tenant Update a User in a Tenant. The Id of a User cannot be changed. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. [FromBody] [Required] UserCreateOrUpdate userCreateOrUpdate UserCreateOrUpdate object. Properties that are not set or are null will not be changed. Property Type Required Description Id Guid No Gets or sets user Id for the user. When creating a user, if User ID is not specified, one will be generated. ExternalUserId string No Gets or sets user ExternalUserId for the user. Must be specified if Identity Provider is Windows Active Directory. ContactGivenName string No Gets or sets preferred name to be used when contacting user. ContactSurname string No Gets or sets preferred surname to be used when contacting user. ContactEmail string No Gets or sets preferred contact email to be used. This does not have to be the same as the user\u0027s Identity Provider email. IdentityProviderId Guid No Gets or sets Identity Provider this user will be required to use to login. If null, the Identity Provider Id will be set when creating the Invitation. RoleIds Guid[] No Gets or sets list of strings of RoleIds. { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"ExternalUserId\": \"ExternalUserId\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ContactEmail\": \"user@company.com\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } Security Allowed for these roles: Account Administrator Returns 200 Updated. Type: User { \"Id\": \"00000000-0000-0000-0000-000000000000\", \"GivenName\": \"Name\", \"Surname\": \"Surname\", \"Name\": \"Name\", \"Email\": \"user@company.com\", \"ContactEmail\": \"user@company.com\", \"ContactGivenName\": \"Name\", \"ContactSurname\": \"Surname\", \"ExternalUserId\": \"ExternalUserId\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ] } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Delete User in a Tenant Delete a User. Admins cannot delete themselves. Deleting a User does not invalidate any of the existing access tokens, but it prevents this User from being able to authenticate in the future. Existing access tokens for the User will be valid until their expiration date. Refresh tokens on behalf of the ser will no longer be valid after the User has been deleted. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for User Validate that a User exists. This endpoint is identical to the GET one, but it does not return an object in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId} Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 User exists. Type: Void 401 Unauthorized. 403 Forbidden. 404 User does not exist. 500 Internal server error. Get Total Count of Users Return total number of users in a Tenant. Optionally, check based on a list of requested users. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] Guid[] id Unordered list of User Ids. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 User not found. 500 Internal server error. Get Header for User\u0027s Preferences Validate that there are preferences for a User. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Preferences Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 500 Internal server error."
                                                  },
    "Documentation/Identity/Identity_Secret.html":  {
                                                        "href":  "Documentation/Identity/Identity_Secret.html",
                                                        "title":  "Secret",
                                                        "keywords":  "Secret Secrets are used to authenticate both Client Credential clients and Hybrid clients. A Secret has an expiration date or can be created to never expire. We advise to avoid creating secrets that do not expire. After a Secret expires it can no longer be used to authenticate the Client. Any access token issued while a Secret is still valid will be active until the token itself expires. The same applies to refresh tokens, which are issued to Hybrid clients. Safe storage of secrets is your responsibility. OSIsoft Cloud Services does not store secret values, so once lost there is no way to retrieve the value of a Secret. Properties For HTTP requests and responses, the Secret object has the following properties and JSON-serialized body: Property Type Description Id int32 Gets or sets the Id for the secret. Note: This is currently an auto-incremented integer. Description string Gets or sets the description. Value string Gets or sets the value. Expiration DateTime Gets or sets the expiration. Type string Gets or sets the type of the client secret. Serialized Model { \"Id\": 0, \"Description\": \"description\", \"Value\": \"Value\", \"Expiration\": \"2019-11-11T14:18:38.0371799-08:00\", \"Type\": \"Type\" } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Get Hybrid Client Secrets Get all secrets for a Hybrid Client. Total number of secrets in the Client set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.044144-08:00\", \"Expires\": false, \"Description\": \"description\" }, { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.0445152-08:00\", \"Expires\": false, \"Description\": \"description\" } ] 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Hybrid Client Secret Get a Hybrid Client Secret. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientSecret { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.0495696-08:00\", \"Expires\": false, \"Description\": \"description\" } 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 500 Internal server error. Add Hybrid Client Secret Add a new secret to a Client Credential Client. A client can have a maximum of 10 secrets. We advise against creating secrets that do not expire. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] ClientSecretCreateOrUpdate clientSecretCreateOrUpdate ClientSecretCreateOrUpdate object. Property Type Required Description Expiration DateTime No Gets or sets expiration date for the client secret. Will be null if the secret does not expire. Expires bool No Gets or sets determines if the secret expires. Defaults to true. If Expires is set to true (or null) and Expiration is not null, expiration of this secret will be enforced. If Expires is set to true (or null) and Expiration is null, a 400 error will be returned. If Expires is set to false and Expiration is not null, a 400 error will be returned. If Expires is set to false and Expiration is null, there will be no expiration of this secret. Description string No Gets or sets description for the client secret. We suggest being as descriptive as possible. This field will make identifying secrets easier. { \"Expiration\": \"2019-11-11T14:18:38.0523153-08:00\", \"Expires\": false, \"Description\": \"description\" } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: ClientSecretResponse { \"Secret\": \"Secret\", \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.0545323-08:00\", \"Expires\": false, \"Description\": \"description\" } 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Update Hybrid Client Secret Update a Hybrid Client Secret. It can take up to one hour for the update to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. [FromBody] [Required] ClientSecretCreateOrUpdate clientSecretCreateOrUpdate ClientSecretCreateOrUpdate object. Properties that are not set or are null will not be changed. Property Type Required Description Expiration DateTime No Gets or sets expiration date for the client secret. Will be null if the secret does not expire. Expires bool No Gets or sets determines if the secret expires. Defaults to true. If Expires is set to true (or null) and Expiration is not null, expiration of this secret will be enforced. If Expires is set to true (or null) and Expiration is null, a 400 error will be returned. If Expires is set to false and Expiration is not null, a 400 error will be returned. If Expires is set to false and Expiration is null, there will be no expiration of this secret. Description string No Gets or sets description for the client secret. We suggest being as descriptive as possible. This field will make identifying secrets easier. { \"Expiration\": \"2019-11-11T14:18:38.0599545-08:00\", \"Expires\": false, \"Description\": \"description\" } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientSecret { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.0600617-08:00\", \"Expires\": false, \"Description\": \"description\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Delete Hybrid Client Secret Delete a Secret from a Hybrid Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued using this Secret will be valid until their expiration. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 204 Success. 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Hybrid Client Secret Validate that a Secret with given Id exists in the Client. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 500 Internal server error. Get Total Count of Hybrid Client Secrets Return total number of Secrets in a Hybrid Client. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  HybridClients/ HybridClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Client Credential Client Secrets Get all secrets for a Client Credential Client. Total number of secrets in the Client set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. From query. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.2949796-08:00\", \"Expires\": false, \"Description\": \"description\" }, { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.2950189-08:00\", \"Expires\": false, \"Description\": \"description\" } ] 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Client Credential Client Secret Get a Client Credential Client Secret. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientSecret { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.3020989-08:00\", \"Expires\": false, \"Description\": \"description\" } 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 500 Internal server error. Add Client Credential Client Secret Add a new Secret to a Client Credential Client. A Client can have a maximum of 10 secrets. We advise against creating secrets that do not expire. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] ClientSecretCreateOrUpdate clientSecretCreateOrUpdate ClientSecretCreateOrUpdate object. Property Type Required Description Expiration DateTime No Gets or sets expiration date for the client secret. Will be null if the secret does not expire. Expires bool No Gets or sets determines if the secret expires. Defaults to true. If Expires is set to true (or null) and Expiration is not null, expiration of this secret will be enforced. If Expires is set to true (or null) and Expiration is null, a 400 error will be returned. If Expires is set to false and Expiration is not null, a 400 error will be returned. If Expires is set to false and Expiration is null, there will be no expiration of this secret. Description string No Gets or sets description for the client secret. We suggest being as descriptive as possible. This field will make identifying secrets easier. { \"Expiration\": \"2019-11-11T14:18:38.3063305-08:00\", \"Expires\": false, \"Description\": \"description\" } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: ClientSecretResponse { \"Secret\": \"Secret\", \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.3064988-08:00\", \"Expires\": false, \"Description\": \"description\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Update Client Credential Client Secret Update a Client Credential Client Secret. It can take up to one hour for the update to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. [FromBody] [Required] ClientSecretCreateOrUpdate clientSecretCreateOrUpdate ClientSecretCreateOrUpdate object. Properties that are not set or are null will not be changed. Property Type Required Description Expiration DateTime No Gets or sets expiration date for the client secret. Will be null if the secret does not expire. Expires bool No Gets or sets determines if the secret expires. Defaults to true. If Expires is set to true (or null) and Expiration is not null, expiration of this secret will be enforced. If Expires is set to true (or null) and Expiration is null, a 400 error will be returned. If Expires is set to false and Expiration is not null, a 400 error will be returned. If Expires is set to false and Expiration is null, there will be no expiration of this secret. Description string No Gets or sets description for the client secret. We suggest being as descriptive as possible. This field will make identifying secrets easier. { \"Expiration\": \"2019-11-11T14:18:38.3099049-08:00\", \"Expires\": false, \"Description\": \"description\" } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientSecret { \"Id\": 0, \"Expiration\": \"2019-11-11T14:18:38.3101142-08:00\", \"Expires\": false, \"Description\": \"description\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Delete Client Credential Client Secret Delete a Secret from a Client Credential Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued using this Secret will be valid until their expiration. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 204 Success. 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Client Credential Client Secret Validate that a Secret with given Id exists in the Client. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets/ Secrets  {secretId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [Required] int32 secretId Id of Secret. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Secret, Client, or Tenant not found. 500 Internal server error. Get Total Count of Client Credential Client Secrets Return total number of Secrets in a Client. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId}/ {clientId}  Secrets Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error."
                                                    },
    "Documentation/Identity/Identity_Invitation.html":  {
                                                            "href":  "Documentation/Identity/Identity_Invitation.html",
                                                            "title":  "Invitation",
                                                            "keywords":  "Invitation Invitations are issued after the creation of a User object in OCS, to begin the provisioning process for a user with one of the Identity Providers in a Tenant. There can only be one Invitation for a User at a time. An invitation can expire, at which time the Admin can either delete it, or extend it. When creating an Invitation an account Admin has the option to resend the Invitation email to the ContactEmail configured for the User the Invitation is attached to. The email can be re-sent by updating the Invitation. When an Invitation expires the User cannot accept it. If the expiration date is extended the User can accept an Invitation. Invitations that are past of their expiration date by more than two weeks will be deleted. The only way to provision a User after this, is to send a new Invitation. Properties For HTTP requests and responses, the Invitation object has the following properties and JSON-serialized body: Property Type Description Id string Gets or sets unique Invitation Id. Issued DateTime Gets or sets invitation issuing timestamp. Expires DateTime Gets or sets invitation expiration timestamp. Accepted DateTime Gets or sets invitation accepted timestamp. State InvitationStates Gets or sets invitation state. Can be None (0), InvitationEmailSent (1), InvitationAccepted (2). TenantId string Gets or sets ID of the Tenant the invitation belongs to. UserId Guid Gets or sets ID of the User whom the invitation was issued to. IdentityProviderId Guid Gets or sets ID of the Identity Provider that must be used to accept the invitation. Serialized Model { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.6161392-08:00\", \"Expires\": \"2019-11-11T14:18:38.616173-08:00\", \"Accepted\": \"2019-11-11T14:18:38.6161783-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Get Invitation Get an Invitation from Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations/ Invitations  {invitationId} Parameters [Required] string tenantId Id of Tenant. [Required] string invitationId Id of Invitation. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.6245292-08:00\", \"Expires\": \"2019-11-11T14:18:38.6245393-08:00\", \"Accepted\": \"2019-11-11T14:18:38.624546-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 401 Unauthorized. 403 Forbidden. 404 Invitation or Tenant not found. 500 Internal server error. Get Invitations Get all non-expired invitations from a Tenant. Optionally include expired invitations. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of invitations to skip. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of invitations to return. [FromQuery] [Optional] [Default = False] bool includeExpiredInvitations Specify whether to return expired invitations. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.6282448-08:00\", \"Expires\": \"2019-11-11T14:18:38.6282685-08:00\", \"Accepted\": \"2019-11-11T14:18:38.6282738-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" }, { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.6282997-08:00\", \"Expires\": \"2019-11-11T14:18:38.628302-08:00\", \"Accepted\": \"2019-11-11T14:18:38.6283059-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } ] 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Update Invitation Update an Invitation. Expired invitations will not be extended. automatically upon updates. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations/ Invitations  {invitationId} Parameters [Required] string tenantId Id of Tenant. [Required] string invitationId Id of Invitation. [FromBody] [Required] InvitationCreateOrUpdate invitationCreateOrUpdate New InvitationCreateOrUpdate object. Properties that are not set or are null will not be changed. Property Type Required Description ExpiresDateTime DateTime No Gets or sets invitation expiration date. Must be in the future. Maximum allowed is two month in the future. Defaults to 21 days on creation. It should be in ISO 8601 and either include a Z at the end to represent UTC timezone or include the offset in hours. If neither is present time will be treated in the local time zone of the server. State InvitationStates No Gets or sets set the state of invitation. For OSISoft internal use only. SendInvitation bool No Gets or sets send an invitation email. Invitation will be sent to the ContactEmail in the User this invitation is attached to. Default is true. IdentityProviderId Guid No Gets or sets Identity Provider to use for accepting this invitation. Required when creating an Invitation. { \"ExpiresDateTime\": \"2019-11-11T14:18:38.6312229-08:00\", \"State\": 0, \"SendInvitation\": false, \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.633862-08:00\", \"Expires\": \"2019-11-11T14:18:38.6338686-08:00\", \"Accepted\": \"2019-11-11T14:18:38.6338746-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Invitation or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Delete Invitation Delete an Invitation. Users who already have an Invitation email will not be able to sign-up once the Invitation is deleted. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations/ Invitations  {invitationId} Parameters [Required] string tenantId Id of Tenant. [Required] string invitationId Id of Invitation. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Invitation or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get header for an Invitation Validate that an Invitation exists. This endpoint is identical to the GET one, but it does not return an object in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations/ Invitations  {invitationId} Parameters [Required] string tenantId Id of Tenant. [Required] string invitationId Id of Invitation. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Invitation or Tenant not found. 500 Internal server error. Get header for Invitations Return total number of non-expired Invitations in a Tenant. Optionally include expired invitations. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Invitations Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = False] bool includeExpiredInvitations Specify to return expired invitations. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Get User\u0027s Invitation Get Invitation for a User. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Invitation Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.7640134-08:00\", \"Expires\": \"2019-11-11T14:18:38.7640582-08:00\", \"Accepted\": \"2019-11-11T14:18:38.7640924-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 401 Unauthorized. 403 Forbidden. 404 Invitation, User, or Tenant not found. 500 Internal server error. Create Invitation Create an Invitation for a User. Should use when no other Invitation exists for the User. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Invitation Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. [FromBody] [Required] InvitationCreateOrUpdate invitationCreateOrUpdate InvitationCreateOrUpdate object. Property Type Required Description ExpiresDateTime DateTime No Gets or sets invitation expiration date. Must be in the future. Maximum allowed is two month in the future. Defaults to 21 days on creation. It should be in ISO 8601 and either include a Z at the end to represent UTC timezone or include the offset in hours. If neither is present time will be treated in the local time zone of the server. State InvitationStates No Gets or sets set the state of invitation. For OSISoft internal use only. SendInvitation bool No Gets or sets send an invitation email. Invitation will be sent to the ContactEmail in the User this invitation is attached to. Default is true. IdentityProviderId Guid No Gets or sets Identity Provider to use for accepting this invitation. Required when creating an Invitation. { \"ExpiresDateTime\": \"2019-11-11T14:18:38.7708735-08:00\", \"State\": 0, \"SendInvitation\": false, \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.7716732-08:00\", \"Expires\": \"2019-11-11T14:18:38.771711-08:00\", \"Accepted\": \"2019-11-11T14:18:38.7717471-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Invitation already exists. 500 Internal server error. Create or Update Invitation Create or update an Invitation for a User. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Invitation Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. [FromBody] [Required] InvitationCreateOrUpdate invitationCreateOrUpdate InvitationCreateOrUpdate object. Property Type Required Description ExpiresDateTime DateTime No Gets or sets invitation expiration date. Must be in the future. Maximum allowed is two month in the future. Defaults to 21 days on creation. It should be in ISO 8601 and either include a Z at the end to represent UTC timezone or include the offset in hours. If neither is present time will be treated in the local time zone of the server. State InvitationStates No Gets or sets set the state of invitation. For OSISoft internal use only. SendInvitation bool No Gets or sets send an invitation email. Invitation will be sent to the ContactEmail in the User this invitation is attached to. Default is true. IdentityProviderId Guid No Gets or sets Identity Provider to use for accepting this invitation. Required when creating an Invitation. { \"ExpiresDateTime\": \"2019-11-11T14:18:38.7776948-08:00\", \"State\": 0, \"SendInvitation\": false, \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } Security Allowed for these roles: Account Administrator Returns 200 Updated. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.7781105-08:00\", \"Expires\": \"2019-11-11T14:18:38.778126-08:00\", \"Accepted\": \"2019-11-11T14:18:38.7781429-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 201 Created. Type: Invitation { \"Id\": \"Id\", \"Issued\": \"2019-11-11T14:18:38.7783963-08:00\", \"Expires\": \"2019-11-11T14:18:38.7784086-08:00\", \"Accepted\": \"2019-11-11T14:18:38.7784222-08:00\", \"State\": 0, \"TenantId\": \"00000000-0000-0000-0000-000000000000\", \"UserId\": \"00000000-0000-0000-0000-000000000000\", \"IdentityProviderId\": \"00000000-0000-0000-0000-000000000000\" } 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 User or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Delete Invitation Delete an Invitation for a User. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Invitation Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Invitation or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get header for User\u0027s Invitation Validate that Invitation exist for a User. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  Users/ Users  {userId}/ {userId}  Invitation Parameters [Required] string tenantId Id of Tenant. [Required] Guid userId Id of User. [FromQuery] [Optional] [Default = False] bool includeExpiredInvitations Specify whether to include expired invitations. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 400 Missing or invalid inputs. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error."
                                                        },
    "Documentation/Identity/Identity_ImplicitClient.html":  {
                                                                "href":  "Documentation/Identity/Identity_ImplicitClient.html",
                                                                "title":  "ImplicitClient",
                                                                "keywords":  "ImplicitClient We suggest using a Authorization Code Client instead of an Implicit Client. Implicit clients are used in Javascript/Browser Javascript Browser (SPA) based applications or native mobile applications with the presence of a User. You can read more about these clients here . These clients are not issued secrets or refresh tokens. Properties For HTTP requests and responses, the ImplicitClient object has the following properties and JSON-serialized body: Property Type Description AllowedCorsOrigins string[] Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. Maximum 10 for client. RedirectUris string[] Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string Gets or sets URI to a page with information about client (used on consent screen). LogoUri string Gets or sets URI to client logo (used on consent screen). Id string Gets or sets client ID for this client. This ID should be a GUID. Name string Gets or sets name of Client. Enabled bool Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] Gets or sets for OSIsoft internal use only. Serialized Model { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Create an Implicit Client Create an Implicit Client in a Tenant. No Secret will be generated for this Client. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] ImplicitClient implicitClient New ImplicitClient object. Property Type Required Description AllowedCorsOrigins string[] No Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. Maximum 10 for client. RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: ImplicitClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 400 Missing or invalid inputs, or Client limit exceeded. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Client Id already exists. 500 Internal server error. Update an Implicit Client Update an Implicit Client. It can take up to one hour for update to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients/ ImplicitClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] ImplicitClient implicitClient Updated Implicit Client values. Properties that are not set or are null will not be changed. Property Type Required Description AllowedCorsOrigins string[] No Gets or sets the values used by the default CORS policy service implementations to build a CORS policy for JavaScript clients. Maximum 10 for client. RedirectUris string[] No Gets or sets the allowed URIs to which return tokens or authorization codes can be returned. Wildcards are ignored. URIs must match exactly what you are redirecting to after login. If URIs do not match, the authentication process will fail with a bad_client error. Maximum 10 per client. PostLogoutRedirectUris string[] No Gets or sets allowed URIs to redirect to after logout. Wildcards are ignored. URIs must match exactly what you are redirecting to after logout. Maximum 10 for client. ClientUri string No Gets or sets URI to a page with information about client (used on consent screen). LogoUri string No Gets or sets URI to client logo (used on consent screen). Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ImplicitClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 400 Missing or invalid inputs. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get an Implicit Client Get an Implicit Client from a Tenant. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients/ ImplicitClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ImplicitClient { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get All Implicit Clients from Tenant Get all Implicit clients from a Tenant. Optionally, get a list of requested clients. Total number of clients in the Tenant set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of ids for all clients to get. Empty or whitespace Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only return Clients that have these tags. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. Will be ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Will be ignored if a list of Ids is passed. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: List [ { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] }, { \"AllowedCorsOrigins\": [ \"String\", \"String\" ], \"RedirectUris\": [ \"String\", \"String\" ], \"PostLogoutRedirectUris\": [ \"String\", \"String\" ], \"ClientUri\": \"ClientUri\", \"LogoUri\": \"LogoUri\", \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } ] 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Delete an Implicit Client Delete an Implicit Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued to this client will be valid until their expiration. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients/ ImplicitClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Implicit Client Validate that an Implicit Client exists. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients/ ImplicitClients  {clientId} Parameters [Required] string tenantId Id of tenant. [Required] string clientId Id of client. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Total Count of Implicit Clients Return total number of Implicit clients in a Tenant. Optionally, check based on a list of requested clients. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ImplicitClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of ids for all clients to get. Empty or whitespace Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only count Clients that have these tags. Security Allowed for these roles: Account Administrator Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error."
                                                            },
    "Documentation/Identity/Identity_ClientCredentialClient.html":  {
                                                                        "href":  "Documentation/Identity/Identity_ClientCredentialClient.html",
                                                                        "title":  "ClientCredentialClient",
                                                                        "keywords":  "ClientCredentialClient Client Credential clients are used for machine-to-machine communication without the presence of a User. These clients are issued an Id and Secret upon creation, which are later used for authentication against OSIsoft Cloud Services. More than one Secret can be created for a Client. You can read more about these clients here . Because they access resources on OSIsoft Cloud Services, and are not associated to users, these clients can be assigned any of the roles in the Tenant. We suggest following a least privilege strategy when assigning roles to these clients, as they are more likely to operate in remote machines with a wider attack surface. Properties For HTTP requests and responses, the ClientCredentialClient object has the following properties and JSON-serialized body: Property Type Description RoleIds Guid[] Gets or sets list of Roles to be assigned to this client. Member role is always required. For security reasons we advise against assigning Admin roles to a client. Id string Gets or sets client ID for this client. This ID should be a GUID. Name string Gets or sets name of Client. Enabled bool Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] Gets or sets for OSIsoft internal use only. Serialized Model { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Authentication All endpoints referenced in this documentation require authenticated access. Authorization header must be set to the access token you retrieve after a successful authentication request. Authorization: Bearer \u003ctoken\u003e Requests made without an access token or an invalid/expired invalid expired token will fail with a 401 Unauthorized response. Requests made with an access token which does not have the correct permissions (see security subsection on every endpoint) will fail with a 403 Forbidden. Read here on how to authenticate against OCS with the various clients and receive an access token in response. Error Handling All responses will have an error message in the body. The exceptions are 200 responses and the 401 Unauthorized response. The error message will look as follows: { \"OperationId\": \"1b2af18e-8b27-4f86-93e0-6caa3e59b90c\", \"Error\": \"Error message.\", \"Reason\": \"Reason that caused error.\", \"Resolution\": \"Possible solution for the error.\" } If and when contacting OSIsoft support about this error, please provide the OperationId. Create Client Credential Client Create a Client Credential Client. A Client Id and Client Secret will be generated to perform authentication. Make sure to store the Secret somewhere safe as we do not store the actual value after the creation step. If you do not have access to the Secret value, we suggest deleting the Secret and adding a new one for this Client. Clients have unique Ids in a Tenant. Currently there is a limit of 50000 clients (of all types) per Tenant. Request POST api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients Parameters [Required] string tenantId Id of Tenant. [FromBody] [Required] ClientCredentialClientCreate clientCredentialClientCreate ClientCredentialClientCreate object. Property Type Required Description SecretDescription string No Gets or sets description for the initial secret for the client. Ensure that this is descriptive enough, as it will be the only way to distinguish between multiple secrets and their usage for a client. SecretExpirationDate DateTime No Gets or sets expiration date for the initial secret for the client. If set to null the secret will never expire. We advise against such practice. RoleIds Guid[] No Gets or sets list of Roles to be assigned to this client. Member role is always required. For security reasons we advise against assigning Admin roles to a client. Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"SecretDescription\": \"description\", \"SecretExpirationDate\": \"2019-11-11T14:18:38.1759021-08:00\", \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 201 Created. Type: ClientResponse { \"Secret\": \"Secret\", \"Id\": 0, \"Description\": \"description\", \"ExpirationDate\": \"2019-11-11T14:18:38.1787205-08:00\", \"Client\": { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } } 400 Missing or invalid inputs, or Client limit exceeded. 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 409 Client Id already exists. 500 Internal server error. Update Client Credential Client Update a Client Credential Client. It can take up to one hour for these values to manifest in the authentication process. Request PUT api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. [FromBody] [Required] ClientCredentialClient updatedClientCredentialClient ClientCredentialClient object. Properties that are not set or are null will not be changed. Property Type Required Description RoleIds Guid[] No Gets or sets list of Roles to be assigned to this client. Member role is always required. For security reasons we advise against assigning Admin roles to a client. Id string No Gets or sets client ID for this client. This ID should be a GUID. Name string Yes Gets or sets name of Client. Enabled bool No Gets or sets whether client is enabled. Client can be used for authentication if set to true. Client cannot be used for authentication if set to false. AccessTokenLifetime int32 No Gets or sets lifetime of access token issued for this client after authentication. Minimum 60 seconds. Maximum 3600 seconds. Defaults to 3600 seconds. Tags string[] No Gets or sets for OSIsoft internal use only. { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } Security Allowed for these roles: Account Administrator Returns 200 Success. Type: ClientCredentialClient { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 400 Missing or invalid inputs. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Client Credential Client Get a Client Credential Client. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: ClientCredentialClient { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get All Client Credential Clients Get a list of Client Credential clients from a Tenant. Optionally, get a list of requested clients. Total number of clients in the Tenant set in the Total-Count header. Request GET api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of Client Credential Client Ids. Empty, whitespace or null Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only return Clients that have these tags. [FromQuery] [Optional] [Default = \"\"] string query Query to execute. Currently not supported. [FromQuery] [Optional] [Default = 0] int32 skip Number of clients to skip. Will be ignored if a list of Ids is passed. [FromQuery] [Optional] [Default = 100] int32 count Maximum number of clients to return. Will be ignored if a list of Ids is passed. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: List [ { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] }, { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } ] 207 Partial success. Type: MultiStatusResponse { \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"ChildErrors\": [ { \"StatusCode\": 0, \"ModelId\": \"ModelId\", \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"Resolution\": \"Resolution\" }, { \"StatusCode\": 0, \"ModelId\": \"ModelId\", \"OperationId\": \"OperationId\", \"Error\": \"Error\", \"Reason\": \"Reason\", \"Resolution\": \"Resolution\" } ], \"Data\": [ { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] }, { \"RoleIds\": [ \"00000000-0000-0000-0000-000000000000\", \"00000000-0000-0000-0000-000000000000\" ], \"Id\": \"Id\", \"Name\": \"Name\", \"Enabled\": false, \"AccessTokenLifetime\": 0, \"Tags\": [ \"String\", \"String\" ] } ] } 401 Unauthorized. 403 Forbidden. 404 Tenant not found. 500 Internal server error. Delete Client Credential Client Delete a Client Credential Client. It can take up to one hour for deletion to manifest in the authentication process. Access tokens issued to this Client will be valid until their expiration. Request DELETE api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Returns 204 Deleted. 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 405 Method not allowed at this base URL. Try the request again at the Global base URL. 500 Internal server error. Get Header for Client Credential Client Validate that a Client Credential Client exists. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients/ ClientCredentialClients  {clientId} Parameters [Required] string tenantId Id of Tenant. [Required] string clientId Id of Client. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error. Get Total Count of Clients Return total number of Client Credential clients in a Tenant. Optionally, check based on a list of requested clients. The value will be set in the Total-Count header. This endpoint is identical to the GET one but it does not return any objects in the body. Request HEAD api/ api  v1/ v1  Tenants/ Tenants  {tenantId}/ {tenantId}  ClientCredentialClients Parameters [Required] string tenantId Id of Tenant. [FromQuery] [Optional] [Default = \"\"] string[] id Unordered list of Client Credential Client Ids. Empty, whitespace or null Ids will be ignored. [FromQuery] [Optional] [Default = \"\"] string[] tag Only count Clients that have these tags. Security Allowed for these roles: Account Administrator Account Member Returns 200 Success. Type: Void 401 Unauthorized. 403 Forbidden. 404 Client or Tenant not found. 500 Internal server error."
                                                                    },
    "Documentation/DataViews/Access_Control_API.html":  {
                                                            "href":  "Documentation/DataViews/Access_Control_API.html",
                                                            "title":  "Access Control API",
                                                            "keywords":  "Access Control API This portion of the overall data views API focuses on securing data views by setting their ownership and permissions. Get Data Views Access Control List Get the default AccessControlList for the DataViews collection. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  DataViews Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Response The response includes a status code and a body. Status code Body Type Description 200 OK AccessControlList The default access control list of the data views collection 403 Forbidden error You are not authorized to view the requested data view collection\u0027s access control list 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ] } Update Data Views Access Control List Update the default AccessControlList for the DataViews collection. Request PUT api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  AccessControl/ AccessControl  DataViews Parameters string tenantId The tenant identifier string namespaceId The namespace identifier Request body An AccessControlList Example request body { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ] } Response The response includes a status code and, in some cases, a body. Status code Body Type Description 204 No Content (empty) Successfully updated the default access control list of the data views collection 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized to update the data views collection\u0027s default access control list 500 Internal Server Error error An error occurred while processing the request. See the response body for details Get Data View Access Control List Get the AccessControlList of the specified data view. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Response The response includes a status code and a body. Status code Body Type Description 200 OK AccessControlList The access control list of the requested data view 403 Forbidden error You are not authorized to view the requested data view\u0027s access control list 404 Not Found error The requested data view was not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ] } Update Data View Access Control List Update the AccessControlList of the specified data view. Request PUT api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  AccessControl Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request body An AccessControlList Example request body { \"RoleTrusteeAccessControlEntries\": [ { \"Trustee\": { \"Type\": 3, \"RoleId\": \"11111111-1111-1111-1111-111111111111\" }, \"AccessType\": 0, \"AccessRights\": 1 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"22222222-2222-2222-2222-222222222222\" }, \"AccessType\": 0, \"AccessRights\": 15 }, { \"Trustee\": { \"Type\": 3, \"RoleId\": \"33333333-3333-3333-3333-333333333333\" }, \"AccessType\": 1, \"AccessRights\": 8 } ] } Response The response includes a status code and, in some cases, a body. Status code Body Type Description 204 No Content (empty) Successfully updated the data view access control list 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized to update the requested data view\u0027s access control list 404 Not Found error The requested data view was not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details Get Data View Access Rights Get the calling user or client\u0027s access rights to the requested data view Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  AccessRights Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Response The response includes a status code and a body. Status code Body Type Description 200 OK string[] A list of access rights to the requested data view 403 Forbidden error You are not authorized to make this request 404 Not Found error The requested data view was not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK [ \"Read\", \"Write\", \"Delete\", \"ManageAccessControl\", \"All\" ] Get Data View Owner Get the owner Trustee of the specified data view. Request GET api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Response The response includes a status code and a body. Status code Body Type Description 200 OK Trustee The owner of the requested data view 403 Forbidden error You are not authorized to view the requested data view\u0027s owner 404 Not Found error The requested data view was not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details Example response body HTTP 200 OK Content-Type: application/json application json { \"Type\": 1, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ObjectId\": \"44444444-4444-4444-4444-444444444444\" } Update Data View Owner Update the owner Trustee of the specified data view. Request PUT api/ api  v1-preview/ v1-preview  Tenants/ Tenants  {tenantId}/ {tenantId}  Namespaces/ Namespaces  {namespaceId}/ {namespaceId}  DataViews/ DataViews  {dataViewId}/ {dataViewId}  owner Parameters string tenantId The tenant identifier string namespaceId The namespace identifier string dataViewId The data view identifier Request body A Trustee Example request body { \"Type\": 1, \"TenantId\": \"55555555-5555-5555-5555-555555555555\", \"ObjectId\": \"44444444-4444-4444-4444-444444444444\" } Response The response includes a status code and, in some cases, a body. Status code Body Type Description 204 No Content (empty) Successfully updated the data view owner 400 Bad Request error The request is not valid. See the response body for details 403 Forbidden error You are not authorized to update the requested data view\u0027s owner 404 Not Found error The requested data view was not found 500 Internal Server Error error An error occurred while processing the request. See the response body for details"
                                                        },
    "Documentation/DataIngress/OMF_Ingress_Specification.html":  {
                                                                     "href":  "Documentation/DataIngress/OMF_Ingress_Specification.html",
                                                                     "title":  "Using OMF with Cloud Services",
                                                                     "keywords":  "Using OMF with Cloud Services The OMF specification (located here ) is generic in that it does not specify a particular back-end system. This topic is a companion to the OMF specification which describes how OMF is interpreted by OSIsoft Cloud Services back-end system. Headers A description of each of the headers can be found in the OMF spec . Note that rather than using a producertoken , data ingress calls to OCS require a bearer token to be attached in the header, as documented in the OCS Quick Start documentation. The bearer token is used to authenticate the sender and to authorize the sender for use with a particular Tenant. The client Id associated with this token is used to route messages to a particular Topic that it is mapped to. The omfversion header must match the version of the OMF spec used to construct the message. Versions 1.0 and 1.1 of the spec are currently supported. Message Types OMF message types fall into three categories: Type, Container, and Data, which are described below. Type messages A Type message is interpreted by OSIsoft Cloud Services as an SdsType in the Sequential Data Store. Because SdsTypes are immutable, update operations are not supported. The keywords in the Type definition are interpreted as follows: id : Corresponds to the SdsType Id field. It must conform to the rules defined for a typeId specified here: Types classification : Only the dynamic classification is currently supported. version : Versioning of SdsTypes is not supported. name : Corresponds to the SdsType Name field. This is the friendly name for the type. description : Corresponds to the SdsType Description field. tags : Currently unsupported. metadata : Currently unsupported. The isindex keyword corresponds to the iskey attribute of an SdsTypeProperty. SdsTypes support clustered indexes which can be specified with multiple properties marked with the isindex keyword with a value of true . For compound indexes, the index property order within the message corresponds to the Order field of an SdsTypeProperty. The isname keyword is not supported. Link Type Link Types are not supported in Sequential Data Store. Span Type Span Types are not supported in Sequential Data Store. Property Types and Formats OMF supports setting the format keyword to specify how a particular JSON type should be interpreted. The following is a mapping for the Sequential Data Store supported types (see Types ): Type Format SdsTypeCode array IEnumerable boolean boolean integer int64 Int64 integer int32 Int32 integer int16 Int16 integer uint64 Uint64 integer uint32 Uint32 number uint16 Uint16 number float64 Double number float32 Single number float16 Single object dictionary Idictionary string String string date-time DateTime Container messages A Container message is interpreted as an SdsStream in the Sequential Data Store. The keywords in the Container definition are interpreted as follows: id : Corresponds to the SdsStream Id field. It must conform to the rules defined for an SdsStream Id specified here: Streams . typeid : Corresponds to the SdsStream TypeId field. typeversion : Versioning of SdsTypes is not supported. name : Corresponds to the SdsStream Name field. This is a friendly name for the stream. description : Corresponds to the SdsStream Description field. tags : Corresponds to the SdsStream Tag field. metadata : Corresponds to the SdsStream Metadata field. Data messages A Data message is mapped to generic Sds values in the Sequential Data Store. The keywords in the Data definitions are interpreted as follows: typeid : Data that is not grouped by containerId is not supported. containerid : Stream Id for the associated Sds Stream. typeversion : Not supported. values : An array of the generic Sds values."
                                                                 }
}
